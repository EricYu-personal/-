<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
		<title>我的世界</title>
		<style>
			body{
				margin: 0;
				overflow: hidden;
				/* 隐藏body窗口区域滚动条 */
			}
			@media screen and (orientation:portrait){
				body{
					animation: rot 1s;
					animation-fill-mode: forwards;
				}
			}
			h1{
				position: absolute;
				width: 100%;
				height: 100%;
				margin: 0;
				padding-top: 20%;
				text-align: center;
				color: #fff;
				background-color: #000;
			}
			
			@keyframes rot{
				from {
					transform: rotate(0deg);
				}
				to {
					transform: rotate(90deg);
				}
			}
			@-moz-keyframes rot{ /* Firefox */
				from {
					transform: rotate(0deg);
				}
				to {
					transform: rotate(90deg);
				}
			}
			@-webkit-keyframes rot{ /* Safari 和 Chrome */
				from {
					transform: rotate(0deg);
				}
				to {
					transform: rotate(90deg);
				}
			}
			@-o-keyframes rot{ /* Opera */
				from {
					transform: rotate(0deg);
				}
				to {
					transform: rotate(90deg);
				}
			}
		</style>
		<!-- <script src="https://cdn.bootcss.com/vConsole/3.3.4/vconsole.min.js"></script>
		<script>new VConsole();</script> -->
		<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
		<script src="./node_modules/stats.js/build/stats.min.js"></script>
		<script src="./node_modules/dat.gui/build/dat.gui.min.js"></script>
		<script src="./node_modules/three/build/three.min.js"></script>
		<script src="./node_modules/three/examples/js/controls/PointerLockControls.js"></script>
	</head>

	<body bgcolor="black">
		<div id="pointer-lock-element"></div>
		<h1 id="schedule">
			<span id="schedule_message">贴图加载中……</span><br/>
			主进度：<span id="schedule1">0</span>%<br/>
			次进度：<span id="schedule2">0</span>%
		</h1>
<script>
/**
* 初始化
*/
var stop = false;
const blocks = [
	{
		name: "空气"
	},
	{
		name: "草方块",
		texture: []
	},
	{
		name: "木板",
		texture: []
	},
	{
		name: "石头",
		texture: []
	},
	{
		name: "岩石",
		texture: []
	}
];
const every = [];
for (let x=-10; x<=10; x++){
	every[x] = [];
	for (let y=0; y<=20; y++){
		every[x][y] = [];
		for (let z=-10; z<=10; z++){
			if (y == 0){
				every[x][y][z] = 3;
			}else if (y == 1){
				if (x < 0){
					every[x][y][z] = 1;
				}else if (x > 6){
					every[x][y][z] = 2;
				}else{
					every[x][y][z] = 4;
				}
			}else{
				every[x][y][z] = 0;
			}
		}
	}
}


/**
* dat.gui
*/
let gui = new dat.GUI({
	name: "信息",
	useLocalStorage: false, // 使用LocalStorage来存储
	closeOnTop: true // 关闭按钮是否在顶部
});

/**
* 创建场景对象Scene
*/
let scene = new THREE.Scene();
scene.fog = new THREE.Fog( 0xffffff, 0.01, 50*100);
//						 雾气颜色，近处的距离，远处的距离(66m)
let scene_folder = gui.addFolder("场景(scene)");
	let scene_fog_folder = scene_folder.addFolder("雾(fog)");
		scene_fog_folder.open();
		scene_fog_folder.add(scene.fog, "far", 10*100, 100*100);
		scene_fog_folder.add(scene.fog, "near", 0.001, 1);

/**
* 创建网格模型
*/
let block_geometry = new THREE.BoxGeometry(100, 100, 100);
// TextureLoader创建一个纹理加载器对象，可以加载图片作为几何体纹理
let textureLoader = new THREE.TextureLoader();
let num = 0;
for (let i=1; i<blocks.length; i++){
	for (let j=1; j<=6; j++){
		textureLoader.load(`./img/blocks/${blocks[i].name}/${j}.png`, function (texture){
			blocks[i].texture[j] = texture;
			
			if (blocks[i].texture.length < 7)
				return;
			//单个block加载完毕
			for (let k=1;k<blocks[i].texture.length;k++)
				if (blocks[i].texture[k] == undefined)
					return;
			blocks[i].material = [
				new THREE.MeshLambertMaterial({ map: blocks[i].texture[1] }),
				new THREE.MeshLambertMaterial({ map: blocks[i].texture[2] }),
				new THREE.MeshLambertMaterial({ map: blocks[i].texture[3] }),
				new THREE.MeshLambertMaterial({ map: blocks[i].texture[4] }),
				new THREE.MeshLambertMaterial({ map: blocks[i].texture[5] }),
				new THREE.MeshLambertMaterial({ map: blocks[i].texture[6] })
			]; //材质对象Material
			document.getElementById("schedule2").innerHTML = Math.round(i/6*100*100)/100;
			
			for (let k=1; k<blocks.length; k++)
				if (blocks[k].material == undefined)
					return;
			//所有block加载完毕
			document.getElementById("schedule_message").innerHTML = "载入方块中……";
			document.getElementById("schedule1").innerHTML = "50";
			x = -10;
			loop = setInterval(function (){
				for (let y=0; y<=20; y++){
					for (let z=-10; z<=10; z++){
						document.getElementById("schedule2").innerHTML = Math.round((x+10)/20*100*100)/100;
						if (every[x][y][z] != 0){ //非真空
							let mesh = new THREE.Mesh(block_geometry, blocks[ every[x][y][z] ].material); //网格模型对象Mesh
							mesh.position.x = x*100;
							mesh.position.y = y*100;
							mesh.position.z = z*100;
							scene.add(mesh); //网格模型添加到场景中
						}
					}
				}
				
				x++;
				console.log("loading:", x);
				if (x > 10){
					console.log("achieve loading");
					document.getElementById("schedule1").innerHTML = "100";
					//纹理贴图加载成功后，调用渲染函数执行渲染操作
					render();
					document.getElementById("schedule").remove();
					clearInterval(loop);
					delete loop;
					delete x;
				}
				
				
				/* for (let x=-10;x<=10;x++){
					console.log("loading:", x);
					for (let y=0;y<=20;y++){
						for (let z=-10;z<=10;z++){
							document.getElementById("schedule1").innerHTML = Math.round(x/20*100*100)/100;
							document.getElementById("schedule2").innerHTML = Math.round(y/20*100*100)/100;
							if (every[x][y][z] == 0) //空气
								continue;
							let mesh = new THREE.Mesh(block_geometry, blocks[ every[x][y][z] ].material); //网格模型对象Mesh
							mesh.position.x = x*100;
							mesh.position.y = y*100;
							mesh.position.z = z*100;
							scene.add(mesh); //网格模型添加到场景中
						}
					}
				}
				//纹理贴图加载成功后，调用渲染函数执行渲染操作
				render();
				document.getElementById("loading").remove(); */
			},0);
		});
	}
}

/* let floor_geometry = new THREE.PlaneGeometry(1000, 1000, 6, 6);
let floor_material = new THREE.MeshBasicMaterial({ color:"#fff"});
//floor_material.wireframe = true; //仅框架
floor_mesh = new THREE.Mesh(floor_geometry, floor_material);
// 由于平地添加后默认是在正前方 所以需要旋转一下
floor_mesh.rotation.x = -0.5 * Math.PI;
floor_mesh.position.y = -10;
scene.add(floor_mesh); */


let line = [];
let line_geometry = [];
let line_material = [];

line_geometry[0] = new THREE.Geometry();
line_geometry[0].vertices.push(new THREE.Vector3( -1000, 0, 0) );
line_geometry[0].vertices.push(new THREE.Vector3( 1000, 0, 0) );
line_material[0] = new THREE.LineBasicMaterial({
	color: 0xffffff
});
line[0] = new THREE.Line(line_geometry[0], line_material[0]);
scene.add(line[0]);

line_geometry[1] = new THREE.Geometry();
line_geometry[1].vertices.push(new THREE.Vector3( 0, 1000, 0) );
line_geometry[1].vertices.push(new THREE.Vector3( 0, -1000, 0) );
line_material[1] = new THREE.LineBasicMaterial({
	color: 0xffffff
});
line[1] = new THREE.Line(line_geometry[1], line_material[1]);
scene.add(line[1]);

line_geometry[2] = new THREE.Geometry();
line_geometry[2].vertices.push(new THREE.Vector3( 0, 0, 1000) );
line_geometry[2].vertices.push(new THREE.Vector3( 0, 0, -1000) );
line_material[2] = new THREE.LineBasicMaterial({
	color: 0xffffff
});
line[2] = new THREE.Line(line_geometry[2], line_material[2]);
scene.add(line[2]);


/**
* 光源设置
*/

//点光源
let point = new THREE.PointLight(0xffffff);
point.position.set(0, 300, 0); //点光源位置
scene.add(point); //点光源添加到场景中

//环境光
let ambient = new THREE.AmbientLight(0x444444);
scene.add(ambient);


/**
* 相机设置
*/
/* let width = window.innerWidth; //窗口宽度
let height = window.innerHeight; //窗口高度
let k = width / height; //窗口宽高比
let s = 1000; //三维场景显示范围控制系数，系数越大，显示的范围越大
//创建相机对象
let camera = new THREE.OrthographicCamera(-s * k, s * k, s, -s, 1, 1000);
camera.position.set(0, 200, 0); //设置相机位置
camera.lookAt(scene.position); //设置相机方向(指向的场景对象) */

const WIDTH = window.innerHeight>window.innerWidth? window.innerHeight: window.innerWidth,
	HEIGHT = window.innerHeight>window.innerWidth? window.innerWidth: window.innerHeight;
let camera = new THREE.PerspectiveCamera(45, WIDTH/HEIGHT, 1, 1000*100);
//								 view_angle, aspect, near, far(1km)
camera.position.set(0, 300, 0); //设置相机位置
camera.lookAt(scene.position); //设置相机方向(指向的场景对象)

/**
* 创建渲染器对象
*/
let renderer = new THREE.WebGLRenderer();
renderer.setSize(WIDTH, HEIGHT);//设置渲染区域尺寸
renderer.setClearColor("#eef", 1); //设置背景颜色
renderer.domElement.style.margin = "0";
document.body.appendChild(renderer.domElement); //body元素中插入canvas对象
renderer.domElement.style.cursor = "none";
//执行渲染操作   指定场景、相机作为参数
renderer.render(scene, camera);

/**
* 判断手机电脑
*/
if (
	!(/ipad|iphone|midp|rv:1.2.3.4|ucweb|android|windows ce|windows mobile/.test(
			navigator.userAgent.toLowerCase()
		)
	)
){
	//电脑
	let mouse = document.createElement("div");
	let parts = [
		document.createElement("div"),	//竖
		document.createElement("div")	//横
	];
	parts[0].style.width = "2px";
	parts[0].style.height = "30px";
	parts[0].style.backgroundColor = "#ffffffaa";
	parts[0].style.position = "absolute";
	parts[0].style.left = "50%";
	parts[0].style.top = "50%";
	parts[0].style.transform = "translate(-50%,-50%)";
	
	parts[1].style.width = "30px";
	parts[1].style.height = "2px";
	parts[1].style.backgroundColor = "#ffffffaa";
	parts[1].style.position = "absolute";
	parts[1].style.left = "50%";
	parts[1].style.top = "50%";
	parts[1].style.transform = "translate(-50%,-50%)";
	
	mouse.appendChild(parts[0]);
	mouse.appendChild(parts[1]);
	mouse.style.width = "30px";
	mouse.style.height = "30px";
	mouse.style.position = "absolute";
	mouse.style.left = "50%";
	mouse.style.top = "50%";
	mouse.style.transform = "translate(-50%,-50%)";
	mouse.id = "mouse";
	mouse.style.cursor = "none";
	
	document.body.appendChild(mouse);
}

/**
* stats
*/
let stats = new Stats();
stats.showPanel(0);
document.body.appendChild(stats.dom);

let watcher = {
	v: {
		x: 0,
		y: 0,
		z: 0
	},
	pos: camera.position,
	lookAt: {
		left_right: 220,
		top_bottom: -30
	},
	look: {
		x: 1,
		y: 0,
		z: 0
	}
};

let watcher_folder = gui.addFolder("玩家/观察者(watcher)");
watcher_folder.open();
	watcher_folder.add(window, "stop").listen();
	let watcher_position_folder = watcher_folder.addFolder("位置/像素");
	watcher_position_folder.open();
		watcher_position_folder.add(watcher.pos, "x", -1000, 1000, 10).listen();
		watcher_position_folder.add(watcher.pos, "y", -1000, 1000, 10).listen();
		watcher_position_folder.add(watcher.pos, "z", -1000, 1000, 10).listen();
	let watcher_lookAt_folder = watcher_folder.addFolder("朝向（球坐标系）");
		watcher_lookAt_folder.add(watcher.lookAt, "left_right", 0, 360).listen();
		watcher_lookAt_folder.add(watcher.lookAt, "top_bottom", -90, 90).listen();
	let watcher_look_folder = watcher_folder.addFolder("朝向（笛卡尔坐标系）");
	watcher_look_folder.open();
		watcher_look_folder.add(watcher.look, "x", 0, 1, 0.01).listen();
		watcher_look_folder.add(watcher.look, "y", 0, 1, 0.01).listen();
		watcher_look_folder.add(watcher.look, "z", 0, 1, 0.01).listen();
let T0 = new Date();//上次时间
function render() {
	let t = new Date()-T0;//时间差
	T0 = new Date();//把本次时间赋值给上次时间
	requestAnimationFrame(render);
	renderer.render(scene, camera);//执行渲染操作
	
	let x =
		Math.cos(watcher.lookAt.left_right/180*Math.PI)*
		Math.cos(watcher.lookAt.top_bottom/180*Math.PI)
	;
	let z =
		Math.sin(watcher.lookAt.left_right/180*Math.PI)*
		Math.cos(watcher.lookAt.top_bottom/180*Math.PI)
	;
	let y = Math.sin(watcher.lookAt.top_bottom/180*Math.PI);
	camera.lookAt(watcher.pos.x+x, watcher.pos.y+y, watcher.pos.z+z);
	watcher.look.x = x;
	watcher.look.y = y;
	watcher.look.z = z;
	point.position.x = watcher.pos.x;
	point.position.y = watcher.pos.y;
	point.position.z = watcher.pos.z;
	
	let h = new Date().getHours();
	if (h > 20 | h < 5){ // 天黑
		renderer.setClearColor("#334", 1);
	}else if (h > 15 | h < 7){ // 日出/日落
		renderer.setClearColor("#b23", 1);
	}else{
		renderer.setClearColor("#eef", 1);
	}
	
	stats.update();
}
// render();
// 间隔30ms周期性调用函数fun
//setInterval("render()",16.7)

/* let controls = new THREE.OrbitControls(camera,renderer.domElement);//创建控件对象
controls.addEventListener('change', render);//监听鼠标、键盘事件 */

document.onkeydown = function (e){
	if (e.keyCode == 27){
		stop = !stop;
		$("canvas:eq(0),#mouse").css("cursor",stop?"default":"none");
		return;
	}
	let x=0, y=0, z=0;
	switch (e.keyCode){
		case 87:
		case 38: //前
			console.log("front:", e.keyCode);
			x = Math.cos( (watcher.lookAt.left_right+0) /180*Math.PI);
			z = Math.sin( (watcher.lookAt.left_right+0) /180*Math.PI);
			break;
		case 83:
		case 40: //后
			console.log("behind:", e.keyCode);
			x = Math.cos( (watcher.lookAt.left_right+180) /180*Math.PI);
			z = Math.sin( (watcher.lookAt.left_right+180) /180*Math.PI);
			break;
		case 65:
		case 37: //左
			console.log("left:", e.keyCode);
			x = Math.cos( (watcher.lookAt.left_right-90) /180*Math.PI);
			z = Math.sin( (watcher.lookAt.left_right-90) /180*Math.PI);
			break;
		case 68:
		case 39: //右
			console.log("right:", e.keyCode);
			x = Math.cos( (watcher.lookAt.left_right+90) /180*Math.PI);
			z = Math.sin( (watcher.lookAt.left_right+90) /180*Math.PI);
			break;
		case 32: //上
			console.log("up:", e.keyCode);
			y = 1;
			break;
		case 16: //下
			console.log("down:", e.keyCode);
			y = -1;
			break;
		case 121: //F10
			if (gui.closed){
				gui.open();
			}else{
				gui.close();
			}
		default:
			console.log("keydown:", e.keyCode);
			break;
	}
	watcher.pos.x += x*3.6;
	watcher.pos.y += y*3.6;
	watcher.pos.z += z*3.6;
	setTimeout(()=>{
		watcher.pos.x += x*3.6;
		watcher.pos.y += y*3.6;
		watcher.pos.z += z*3.6;
	}, 300);
	setTimeout(()=>{
		watcher.pos.x += x*3.6;
		watcher.pos.y += y*3.6;
		watcher.pos.z += z*3.6;
	}, 600);
}


/* let choice_object = get_choice_object()?get_choice_object()[1]:undefined;

let choice_folder = gui.addFolder("选择物体");
choice_folder.open();
	choice_position_folder = choice_folder.addFolder("位置");
	choice_position_folder.open();
		choice_position_folder.add(choice_object?choice_object.object.position:{x:0,y:0,z:0}, "x", -1000, 1000, 100).listen();
		choice_position_folder.add(choice_object?choice_object.object.position:{x:0,y:0,z:0}, "y", -1000, 1000, 100).listen();
		choice_position_folder.add(choice_object?choice_object.object.position:{x:0,y:0,z:0}, "z", -1000, 1000, 100).listen();
	choice_folder.add(choice_object.faceIndex?choice_object:{faceIndex:-1}, "faceIndex", 0, 12).listen(); */
let x0 = null, y0 = null;
$("body").on("mousemove", function (e){
	if (stop)
		return;
	
	let x = e.pageX;
	let y = e.pageY;
	console.log("mousemove:", x, y);
	
	// choice_object = get_choice_object()?get_choice_object()[1]:undefined;
	
	if ( Math.sqrt(Math.pow(x-x0,2)+Math.pow(y-y0,2)) <= 100 & x0 !== null & y0 !== null ){
		let [dx, dy] = [x-x0, y-y0];
		[x0, y0] = [x, y];
		console.log("move:", dx, dy);
		watcher.lookAt.left_right += dx/document.getElementsByTagName("canvas")[0].offsetWidth*360;
		watcher.lookAt.top_bottom -= dy/document.getElementsByTagName("canvas")[0].offsetHeight*360;
		
		if (watcher.lookAt.left_right > 360)
			while (watcher.lookAt.left_right > 360)
				watcher.lookAt.left_right -= 360;
		if (watcher.lookAt.left_right < 0)
			while (watcher.lookAt.left_right < 0)
				watcher.lookAt.left_right += 360;
		
		if (watcher.lookAt.top_bottom > 90)
			watcher.lookAt.top_bottom = 90;
		if (watcher.lookAt.top_bottom < -90)
			watcher.lookAt.top_bottom = -90;
		
	}
	
	[x0,y0] = [x, y];
});

$("canvas:eq(0)").on("mousedown", function (e){
	if (stop)
		return;
	
	if (e.button == 0){ //左键（删除）
		let click = get_choice_object();
		for (let i in click){
			if (click[i].faceIndex){
				if (click[i].object instanceof THREE.Mesh){
					if (Math.sqrt(
						Math.pow(click[i].object.position.x - watcher.pos.x, 2)+
						Math.pow(click[i].object.position.y - watcher.pos.y, 2)+
						Math.pow(click[i].object.position.z - watcher.pos.z, 2)
					) < 500){ //距离小于500
						console.log("delete:", click[i].object.position);
						scene.remove(click[i].object);
						break;
					}
				}
			}
		}
	}else if (e.button == 2){ //右键（放置）
		let click = get_choice_object();
		for (let i in click){
			if (click[i].object instanceof THREE.Mesh){
				if (Math.sqrt(
					Math.pow(click[i].object.position.x - watcher.pos.x, 2)+
					Math.pow((click[i].object.position.y+100) - watcher.pos.y, 2)+
					Math.pow(click[i].object.position.z - watcher.pos.z, 2)
				) < 500){ //距离小于500
					if (click[i].faceIndex == 4 | click[i].faceIndex == 5){ //上
						let mesh = new THREE.Mesh(block_geometry, blocks[3].material); //石头
						mesh.position.x = click[i].object.position.x;
						mesh.position.y = click[i].object.position.y+100;
						mesh.position.z = click[i].object.position.z;
						scene.add(mesh); //网格模型添加到场景中
						break;
					}
				}
			}
		}
	}
	return false;
})


/**
* Touch
*/
let touch_start = {
	t: null,
	pos: {x: null, y: null},
	id: null
};
$("canvas:eq(0)").on("touchstart", function (e){
	if (stop)
		return;
	
	let x = e.originalEvent.targetTouches[0].pageY;
	let y = e.originalEvent.targetTouches[0].pageX;
	console.log("touchstart:", x, y, Number(new Date()));
	
	[x0,y0] = [x, y];
	
	touch_start.t = new Date();
	touch_start.pos = {x,y};
	touch_start.id = setTimeout(()=>{ //长按（删除）
		touch_start.id = null;
		if (Math.sqrt(
			Math.pow(touch_start.pos.x-x, 2)+
			Math.pow(touch_start.pos.y-y, 2)
		) < 36){ //误差36px
			let click = get_choice_object(true, x, y);
			for (let i in click){
				if (click[i].faceIndex){
					if (click[i].object instanceof THREE.Mesh){
						if (Math.sqrt(
							Math.pow(click[i].object.position.x - watcher.pos.x, 2)+
							Math.pow(click[i].object.position.y - watcher.pos.y, 2)+
							Math.pow(click[i].object.position.z - watcher.pos.z, 2)
						) < 500){ //距离小于500
							console.log("delete:", click[i].object.position);
							scene.remove(click[i].object);
							break;
						}
					}
				}
			}
		}
	}, 1000);
	
	return false;
});
$("canvas:eq(0)").on("touchmove", function (e){
	if (stop)
		return false;
	
	if (x0 === null | y0 === null)
		return false;
	
	let x = e.originalEvent.targetTouches[0].pageY;
	let y = e.originalEvent.targetTouches[0].pageX;
	console.log("touchmove:", x, y);
	
	let [dx, dy] = [x-x0, y-y0];
	[x0, y0] = [x, y];
	console.log("move:", dx, dy);
	watcher.lookAt.left_right -= dx/document.getElementsByTagName("canvas")[0].offsetWidth*90;
	watcher.lookAt.top_bottom -= dy/document.getElementsByTagName("canvas")[0].offsetHeight*90;
	
	if (watcher.lookAt.left_right > 360)
		while (watcher.lookAt.left_right > 360)
			watcher.lookAt.left_right -= 360;
	if (watcher.lookAt.left_right < 0)
		while (watcher.lookAt.left_right < 0)
			watcher.lookAt.left_right += 360;
	
	if (watcher.lookAt.top_bottom > 90)
		watcher.lookAt.top_bottom = 90;
	if (watcher.lookAt.top_bottom < -90)
		watcher.lookAt.top_bottom = -90;
	
	if (Math.sqrt(
		Math.pow(touch_start.pos.x-x, 2)+
		Math.pow(touch_start.pos.y-y, 2)
	) >= 100){ //误差100px
		touch_start.pos.x = -666;
		touch_start.pos.y = -666;
	}
	return false;
});
$("canvas:eq(0)").on('touchend', function (e){
	if (stop)
		return;
	
	let x = e.originalEvent.changedTouches[0].pageY;
	let y = e.originalEvent.changedTouches[0].pageX;
	console.log("touchend:", x, y, Number(new Date()));
	
	x0 = null, y0 = null;
	
	if (touch_start.id !== null){ //短按（放置）
		clearTimeout(touch_start.id);
		touch_start.id = null;
		if (Math.sqrt(
			Math.pow(touch_start.pos.x-x, 2)+
			Math.pow(touch_start.pos.y-y, 2)
		) < 36){ //误差36px
			let click = get_choice_object(true, x, y);
			for (let i in click){
				if (click[i].object instanceof THREE.Mesh){
					if (Math.sqrt(
						Math.pow(click[i].object.position.x - watcher.pos.x, 2)+
						Math.pow(click[i].object.position.y - watcher.pos.y, 2)+
						Math.pow(click[i].object.position.z - watcher.pos.z, 2)
					) < 500){ //距离小于500
						console.log("put:", click[i].object.position, click[i].faceIndex);
						if (click[i].faceIndex == 4 | click[i].faceIndex == 5){
							let mesh = new THREE.Mesh(block_geometry, blocks[3].material); //石头
							mesh.position.x = click[i].object.position.x;
							mesh.position.y = click[i].object.position.y+100;
							mesh.position.z = click[i].object.position.z;
							scene.add(mesh); //网格模型添加到场景中
							break;
						}else if (click[i].faceIndex == 0 | click[i].faceIndex == 1){
							let mesh = new THREE.Mesh(block_geometry, blocks[3].material); //石头
							mesh.position.x = click[i].object.position.x+100;
							mesh.position.y = click[i].object.position.y;
							mesh.position.z = click[i].object.position.z;
							scene.add(mesh); //网格模型添加到场景中
							break;
						}else if (click[i].faceIndex == 8 | click[i].faceIndex == 9){
							let mesh = new THREE.Mesh(block_geometry, blocks[3].material); //石头
							mesh.position.x = click[i].object.position.x;
							mesh.position.y = click[i].object.position.y;
							mesh.position.z = click[i].object.position.z+100;
							scene.add(mesh); //网格模型添加到场景中
							break;
						}
					}
				}
			}
		}
	}
});
$("canvas:eq(0)").on('touchcancel', function (e){
	if (stop)
		return;
	
	let x = e.originalEvent.changedTouches[0].pageY;
	let y = e.originalEvent.changedTouches[0].pageX;
	console.log("touchcancel:", x, y, Number(new Date()));
	
	x0 = null, y0 = null;
	
	if (touch_start.id !== null){ //短按（放置）
		clearTimeout(touch_start.id);
		
	}
});


function get_choice_object(phone, x, y){
	let raycaster = new THREE.Raycaster(); //光线投射，用于确定鼠标点击位置
	let mouse = new THREE.Vector2(); //创建二维平面
	mouse.x = phone? 2*(x/WIDTH)-1: 0;
	mouse.y = phone? -2*(y/HEIGHT)+2: 0;
	//mouse.x = phone? (x/window.innerWidth)*0.9-0.6: 0;
	//mouse.y = phone? (y/window.innerHeight)*1.8-0.6: 0;
	console.log("get:", x, y, mouse.x, mouse.y);
	//以camera为z坐标，确定所点击物体的3D空间位置
	raycaster.setFromCamera(mouse, camera);
	//确定所点击位置上的物体数量
	let intersects = raycaster.intersectObjects(scene.children);
	//选中后进行的操作
	if(intersects.length){
		return intersects;
	}
	return undefined;
}

//屏蔽鼠标右键
document.oncontextmenu = function (e){
	//var e = e || window.event;
	//e.returnValue = false;
	return false;
};
//屏蔽选择文字
document.onselectstart = function (){
	return false;
};



                                                var element = document.body;

                                                //输入锁定改变事件
                                                var pointerlockchange = function pointerlockchange() {
                                                            if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {
console.log(802)
                                                                        /* _this.controlsEnabled = true;
                                                                        _this.controls.enabled = true;

                                                                        blocker.style.display = 'none'; */
                                                            } else {
console.log(808)
                                                                       /* _this.controls.enabled = false;

                                                                        blocker.style.display = 'block';

                                                                        instructions.style.display = ''; */
                                                            }
                                                };

                                                //输入锁定改变错误
                                                var pointerlockerror = function pointerlockerror() {
console.log("error")
                                                            instructions.style.display = '';
                                                };

                                                // Hook pointer lock state change events
                                                document.addEventListener('pointerlockchange', pointerlockchange, false);
                                                document.addEventListener('mozpointerlockchange', pointerlockchange, false);
                                                document.addEventListener('webkitpointerlockchange', pointerlockchange, false);

                                                document.addEventListener('pointerlockerror', pointerlockerror, false);
                                                document.addEventListener('mozpointerlockerror', pointerlockerror, false);
                                                document.addEventListener('webkitpointerlockerror', pointerlockerror, false);

                                                document.addEventListener('keydown', function (event) {
                                                            // return _this.onKeyDown(event);
                                                }, false);
                                                document.addEventListener('keyup', function (event) {
                                                            // return _this.onKeyUp(event);
                                                }, false);

                                                //遮罩层事件
                                                element.addEventListener('click', function () {

                                                            // instructions.style.display = 'none';

                                                            // Ask the browser to lock the pointer
                                                            //请求指针锁定
                                                            element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
                                                            element.requestPointerLock();
                                                }, false);


/* // 注意: 截止本文撰写时, 仅有 Mozilla 和 WebKit 支持指针锁定。

// 我们将要使之全屏并指针锁定的元素。
var elem;

document.addEventListener("mousemove", function(e) {
  var movementX = e.movementX       ||
                  e.mozMovementX    ||
                  e.webkitMovementX ||
                  0,
      movementY = e.movementY       ||
                  e.mozMovementY    ||
                  e.webkitMovementY ||
                  0;

  // 打印鼠标移动的增量值。
  console.log("movementX=" + movementX, "movementY=" + movementY);
}, false);

function fullscreenChange() {
  if (document.webkitFullscreenElement === elem ||
      document.mozFullscreenElement === elem ||
      document.mozFullScreenElement === elem) { // 较旧的 API 大写 'S'.
    // 元素进入全屏模式了，现在我们可以请求指针锁定。
    elem.requestPointerLock = elem.requestPointerLock    ||
                              elem.mozRequestPointerLock ||
                              elem.webkitRequestPointerLock;
    elem.requestPointerLock();
  }
}

document.addEventListener('fullscreenchange', fullscreenChange, false);
document.addEventListener('mozfullscreenchange', fullscreenChange, false);
document.addEventListener('webkitfullscreenchange', fullscreenChange, false);

function pointerLockChange() {
  if (document.mozPointerLockElement === elem ||
      document.webkitPointerLockElement === elem) {
    console.log("指针锁定成功了。");
  } else {
    console.log("指针锁定已丢失。");
  }
}

document.addEventListener('pointerlockchange', pointerLockChange, false);
document.addEventListener('mozpointerlockchange', pointerLockChange, false);
document.addEventListener('webkitpointerlockchange', pointerLockChange, false);

function pointerLockError() {
  console.log("锁定指针时出错。");
}

document.addEventListener('pointerlockerror', pointerLockError, false);
document.addEventListener('mozpointerlockerror', pointerLockError, false);
document.addEventListener('webkitpointerlockerror', pointerLockError, false);

function lockPointer() {
  elem = $("canvas")[0];
  // 开始于使元素进入全屏模式。目前的实现
  // 要求元素在请求指针锁定前要处于全屏模式下
  // -- 这在以后可能会发生改变。
  elem.requestFullscreen = elem.requestFullscreen    ||
                           elem.mozRequestFullscreen ||
                           elem.mozRequestFullScreen || // 较旧的 API 把 ‘S’ 大写
                           elem.webkitRequestFullscreen;
  elem.requestFullscreen();
}
document.body.addEventListener("mousedown", function(){
	lockPointer();
	console.log(13);
},true);
 */


</script>
	</body>
</html>
