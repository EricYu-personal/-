<!DOCTYPE html>
<!-- Copyright © 2020 by wzh -->
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport" />
		<title>我的世界</title>
		
		<!--icon-->
		<link rel="icon" href="./img/icon.png" type="image/x-icon"/>
		
		<style>
			@font-face{
				font-family:kt; /*楷体*/
				src:url("./fonts/kt.ttf");
			}
			@font-face{
				font-family:hwxk; /*华文楷体*/
				src:url("./fonts/hwxk.ttf");
			}
			@font-face{
				font-family:fzybxskt; /*方正硬笔行书楷体*/
				src:url("./fonts/fzybxskt.ttf");
			}
			@font-face{
				font-family:fzqtjt; /*方正启体简体*/
				src:url("./fonts/fzqtjt.ttf");
			}
			@font-face{
				font-family:qq1; /*QQ*/
				src:url("./fonts/qq1.ttf");
			}
			@font-face{
				font-family:qq2; /*QQ*/
				src:url("./fonts/qq2.ttf");
			}
			@font-face{
				font-family:huawei; /*QQ*/
				src:url("./fonts/huawei.ttf");
			}
			
			::selection {
			    color: #fff;
			    background: #f9cc9d;
			}
			:not(textarea):not(input){ /* 禁止复制选中 */
				-webkit-touch-callout: none; /* iOS Safari */
				-webkit-user-select: none; /* Chrome/Safari/Opera */
				-khtml-user-select: none; /* Konqueror */
				-moz-user-select: none; /* Firefox */
				-ms-user-select: none; /* Internet Explorer/Edge */
				user-select: none; /* Non-prefixed version, currently not supported by any browser */
			}
			
			body{
				margin: 0;
				overflow: hidden;
				/* 隐藏body窗口区域滚动条 */
			}
			@media not screen and (orientation:portrait){ /* 电脑 */
				#warning{
					display: none;
				}
			}
			h1{
				position: absolute;
				width: 100%;
				height: 100%;
				margin: 0;
				/* font-size: 8.6vmin; */
				font-family: qq1, serif;
				/*padding-top: 20%;*/
				text-align: center;
				color: #fff;
				background-color: #000;
			}
			h1:before{
				content: "\a\a";
				white-space: pre;
			}
			h1:after{
				content: "Copyright © 2020 by wzh";
				white-space: pre;
				font-size: 2vmin;
				
				position: absolute;
				bottom: 6vh;
				left: 50%;
				transform: translateX(-50%)
			}
			b{
				font-family: fzqtjt, serif;
			}
			span{
				font-family: kt, serif;
			}
			#warning > button{
				width: 80%;
				height: 60px;
				position: relative;
				top: 26px;
				font-size: 8vmin;
				font-family: hwxk, serif;
			}
			*{
				font-family: qq2, serif;
				outline: none;
			}
			#control{
				position: absolute;
				bottom: 16%;
				left: 10%;
				background: #aaa;
				opacity: 0.66;
				width: 66px;
				height: 66px;
				border-radius: 50%;
			}
			#jump{
				position: absolute;
				bottom: 16%;
				right: 10%;
				background: #aaa;
				opacity: 0.66;
				width: 46px;
				height: 46px;
				border-radius: 50%;
			}
			
			#tools{
				position: absolute;
				bottom: 12px;
				left: 50%;
				transform: translateX(-50%);
				width: 300px;
				height: 50px;
			}
			#tools > img{
				width: 16%;
				height: 100%;
				display: inline-block;
				margin: 0 -2px;
				border-color: #aaa;
				border-width: 3px;
				border-style: groove;
			}
			
			textarea{
				resize: none;
			}
			
			#bag, #command{
				width: 80vw;
				height: 80vh;
				
				position: absolute;
				left: 50%;
				top: 50%;
				transform: translate(-50%, -50%);
				
				display: none;
				z-index: 1;
				
				background-color: #c4c4c4;
				border: 3px #fff outset;
				padding: 1.6%;
			}
			/*#command{
				width: 86.66%;
				height: 86.66%;
			}*/
			
			#command > textarea{
				width: 100%;
				height: 88.6%;
				
				color: black;
				background-color: #d6d6d6;
				border: 2px #fff inset;
				font-size: 3vw;
			}
			#command > button{
				width: 48%;
				height: 9%;
				margin: 0 0.6%;
				font-size: 5vmin;
			}
			
			#bag > div{
				height: 20%;
				font-size: 3.7vw;
				margin: 6px;
			}
			#bag > div > ul{
				display: -webkit-flex; 
				display: -moz-box;
				display: -mz-flexbox;
				display: flex; 
				
				width: 50%;
				overflow-x: auto;
				overflow: none;
				
				list-style: none;
				margin: 0;
				margin-left: 5.2vw;
				margin-top: -36px;
				padding: 0;
			}
			#bag > div > ul > li{
				float: left;
				flex: 0 0 auto;
			}
			#bag > div > ul > li > *{
				width: 100%;
				height: 100%;
			}
			.thing{
				/* position: absolute; */
				width: 7vw;
				height: 7vw;
				
				display: inline-block;
				border: 3px inset #fff;
				margin: 0.3vw;
			}
			.delete{
				/* position: absolute; */
				width: 7vw;
				height: 7vw;
				
				font-size: 26px;
				display: inline-block;
				border: 3px inset #fff;
				margin: 0.3vw;
			}
		</style>
		
		<script src="./js/jquery.min.js"></script>
		<script>
		if (typeof(require) != "undefined")
			window.$ = window.jQuery = require("./js/jquery.min.js");
		</script>
		<script src="https://cdn.bootcss.com/vConsole/3.3.4/vconsole.min.js"></script>
		<script src="./js/three.min.js"></script>
		<script src="./js/simplex-noise.js"></script>
		<script src="./js/dat.gui.min.js"></script>
		<script src="./js/stats.min.js"></script>
		<!--<script src="./node_modules/three/examples/js/controls/PointerLockControls.js"></script>-->
	</head>
	
	<body bgcolor="black">
		<div id="tools">
			<img/>
			<img/>
			<img/>
			<img/>
			<img src="./img/more.png" onclick="state('bag');" />
		</div>
		
		<div id="command">
			<textarea>
deskgood.goY(10000*100);
deskgood.move(0,10000*100,0);
deskgood.moveTo(0,10000*100);
//这是注释，告诉你这三个命令都可以把deskgood送上万米高空"))</textarea>
			<button onclick="state('command');">关闭</button>
			<button onclick="run($('#command > textarea').val());">运行</button>
		</div>
		<div id="bag">
			<div>
				头：
				<ul>
					<li class="thing"></li>
					<li class="thing"></li>
					<li class="thing"></li>
					<li class="thing"></li>
					<li class="thing"></li>
					<li class="thing"></li>
					<li class="thing"></li>
					<li class="thing"></li>
					<li class="thing"></li>
					<li class="delete"><img src="img/delete.png" /></li>
				</ul>
			</div>
			<div>
				身：
				<ul>
					<li class="thing"></li>
					<li class="delete"><img src="img/delete.png" /></li>
				</ul>
			</div>
			<div>
				腿：
				<ul>
					<li class="thing"></li>
					<li class="delete"><img src="img/delete.png" /></li>
				</ul>
			</div>
			<div>
				脚：
				<ul>
					<li class="thing"></li>
					<li class="delete"><img src="img/delete.png" /></li>
				</ul>
			</div>
		</div>
		<h1 id="schedule" style="z-index: 2;">
			<header>贴图加载中……</header>
			进度：<progress></progress>
			<span>0</span>%<br/>
			<b>生命诚可贵，生命只有一次，请珍爱生命</b>
		</h1>
		<h1 id="warning" style="z-index: 3;">
			推荐使用横屏运行（启用浏览器横屏或<a href="https://github.com/wzh656/MinecraftWeb/releases/download/v0.4.0-alpha/Minecraft-full.apk">下载apk（完整版）</a>or<a href="https://github.com/wzh656/MinecraftWeb/releases/download/v0.4.0-alpha/Minecraft-simplified.apk">（简化版）</a>）<br/>
			<button onclick="this.parentElement.remove();">继续竖屏</button>
		</h1>
		<audio id="bgm" perload loop style="display: none;" src="./music/1.m4a" ></audio>
		<!--<audio id="bgm" autoplay perload loop style="display: none;" src="https://vdse.bdstatic.com/876934f28995e8042230ec598237c67e.mp4?authorization=bce-auth-v1/fb297a5cc0fb434c971b8fa103e8dd7b/2017-05-11T09:02:31Z/-1//ab5b458a478fae53b754e194ab270b96f23aa23ba71c2e63b06fc06d0543040c"></audio>-->
		<noscript><h1 style="z-index: 3;">你的浏览器不支持JavaScript，无法运行！</h1></noscript>
<script>
document.addEventListener("plusready", function(){
	plus.device.setWakelock(true); //屏幕常亮
	
	if (sessionStorage.getItem("already_send") == "true")
		return; //不再发送
	
	let types = {}; 
		types[plus.networkinfo.CONNECTION_UNKNOW] = "Unknown connection";
		types[plus.networkinfo.CONNECTION_NONE] = "None connection";
		types[plus.networkinfo.CONNECTION_ETHERNET] = "Ethernet connection";
		types[plus.networkinfo.CONNECTION_WIFI] = "WiFi connection";
		types[plus.networkinfo.CONNECTION_CELL2G] = "Cellular 2G connection";
		types[plus.networkinfo.CONNECTION_CELL3G] = "Cellular 3G connection";
		types[plus.networkinfo.CONNECTION_CELL4G] = "Cellular 4G connection";
	let data = {
		"device_imei(设备的国际移动设备身份码)": plus.device.imei,
		"device_imsi(设备的国际移动用户识别码)": JSON.stringify(plus.device.imsi),
		"device_model(设备的型号)": plus.device.model,
		"device_vendor(设备的生产厂商)": plus.device.vendor,
		"device_uuid(设备的唯一标识)": plus.device.uuid,
		"screen_currentSize(屏幕信息)": JSON.stringify(plus.screen.getCurrentSize()),
		"networkInfo_currentType(网络信息)": types[plus.networkinfo.getCurrentType()],
		"os_language(系统语言信息)": plus.os.language,
		"os_name(系统的名称)": plus.os.name,
		"os_vendor(系统的供应商信息)": plus.os.vendor,
		"os_version(系统版本信息)": plus.os.version
	};
	console.log($.post("http://api.s.wps.cn/api/form/f39d2d9d/mainPreviewa", data)); //发送信息
	console.log(data);
	sessionStorage.setItem("already_send", "true"); //已发送
});
</script>

<script>
function run(code){
	try{
		eval(code);
	}catch(err){
		console.error("【命令】\n代码运行出错，错误信息（自行翻译）：\n"+err);
		alert("代码运行出错，错误信息（自行翻译,可在VConsole查看）：\n"+err);
		/* $.get("http://fanyi.youdao.com/translate",{
			doctype: "json",
			type: "auto",
			i: err
		},function(data, state, xhr){
			console.log(data);
			try{
				if (state == "success" & !!data.translateResult[0][0].tgt){
					console.error("【命令方块】\n代码运行出错，错误信息：\n"+err+"\n译文（有道翻译提供）："+data.translateResult[0][0].tgt);
					alert("代码运行出错，错误信息（可在VConsole查看）：\n"+err+"\n译文（有道翻译提供）："+data.translateResult[0][0].tgt);
				}else{
					console.error("【命令方块】\n代码运行出错，错误信息（自行翻译）：\n"+err);
					alert("代码运行出错，错误信息（自行翻译,可在VConsole查看）：\n"+err);
				}
			}catch(e){
				console.error("【命令方块】\n代码运行出错，错误信息（自行翻译）：\n"+err);
				alert("代码运行出错，错误信息（自行翻译,可在VConsole查看）：\n"+err);
			}
		}); */
	}
}
function playBGM(){
	let bgm = $("#bgm")[0];
	if (bgm.paused){
		let random = Math.random();
		if (random < 0.5){
			bgm.volume = 1;
			bgm.src = "./music/1.m4a";
			bgm.play();
			console.info("bgm(BackGround Music)", "begin(1.m4a)", "time:"+new Date());
		}else{
			bgm.volume = 1;
			bgm.src = "./music/2.m4a";
			bgm.play();
			console.info("bgm(BackGround Music)", "begin(2.m4a)", "time:"+new Date());
		}
		setTimeout(function(){
			let bgm_folder = gui.addFolder("背景音乐(bgm)")
			bgm_folder.add(bgm, "volume", 0, 1, 0.01).name("音量(volume)");
			bgm_folder.add(bgm, "paused").name("是否暂停(paused)").listen();
			bgm_folder.add({f:()=>{
				bgm.pause();
			}}, "f").name("暂停(pause)");
			bgm_folder.add({f:()=>{
				bgm.play();
			}}, "f").name("播放(play)");
			bgm_folder.add(bgm, "currentTime", 0, bgm.duration, 0.001).name("播放进度(current time)").listen();
			bgm_folder.add(bgm, "src").name("音乐路径(src)");
		},1000);
	}else{
		//console.log("already", bgm.paused);
		bgm.play();
	}
}
document.addEventListener("plusready", playBGM);
document.addEventListener("touchstart", playBGM);

var stop = true;
/**
* 判断手机电脑
*/
if (/ipad|iphone|midp|rv:1.2.3.4|ucweb|android|windows ce|windows mobile/.test(
		navigator.userAgent.toLowerCase()
	)
){ //手机
	let control = document.createElement("div");
	let jump = document.createElement("div");
	
	control.id = "control";
	jump.id = "jump";
	
	document.body.appendChild(control);
	document.body.appendChild(jump);
	
	stop = false;
	
	/*let vconsole = document.createElement("script");
	vconsole.src = "https://cdn.bootcss.com/vConsole/3.3.4/vconsole.min.js";
	vconsole.onload = function(){
		new VConsole();
		document.getElementById("__vconsole").childNodes[1].style.opacity = 0.5;
		document.getElementById("__vconsole").childNodes[1].style.borderRadius = "66px";
	};
	document.body.appendChild(vconsole);*/
	//new VConsole();
}else{ //电脑
	let mouse = document.createElement("div");
	let parts = [
		document.createElement("div"),	//竖
		document.createElement("div")	//横
	];
	parts[0].style.width = "2px";
	parts[0].style.height = "30px";
	parts[0].style.backgroundColor = "rgba(255, 255, 255, 0.666666)";
	parts[0].style.position = "absolute";
	parts[0].style.left = "50%";
	parts[0].style.top = "50%";
	parts[0].style.transform = "translate(-50%,-50%)";
	
	parts[1].style.width = "30px";
	parts[1].style.height = "2px";
	parts[1].style.backgroundColor = "rgba(255, 255, 255, 0.666666)";
	parts[1].style.position = "absolute";
	parts[1].style.left = "50%";
	parts[1].style.top = "50%";
	parts[1].style.transform = "translate(-50%,-50%)";
	
	mouse.appendChild(parts[0]);
	mouse.appendChild(parts[1]);
	mouse.style.width = "30px";
	mouse.style.height = "30px";
	mouse.style.position = "absolute";
	mouse.style.left = "50%";
	mouse.style.top = "50%";
	mouse.style.transform = "translate(-50%,-50%)";
	mouse.id = "mouse";
	mouse.style.cursor = "none";
	
	document.body.appendChild(mouse);
	
	
	let help = document.createElement("h1");
	help.innerHTML = `
		WSAD/↑↓←→: 前后左右; 空格:跳跃; 连按W/ctrl+W:疾跑<br/>
		Esc: 退出锁定鼠标并保存游戏<br/>
		请先点击任意处锁定鼠标以开始游戏`
	;
	help.style.opacity = 0.5;
	help.id = "help";
	document.body.appendChild(help);
	
	//遮罩层事件
	help.addEventListener("click", function (){
		/* if (stop){ //请求解除指针锁定
			document.exitPointerLock =
				document.exitPointerLock ||
				document.mozExitPointerLock ||
				document.webkitExitPointerLock
			;
			document.exitPointerLock();
		}else{ */ 
			//请求指针锁定
			document.body.requestPointerLock =
				document.body.requestPointerLock ||
				document.body.mozRequestPointerLock ||
				document.body.webkitRequestPointerLock
			;
			//解除鼠标锁定
			document.exitPointerLock =
				document.exitPointerLock ||
				document.mozExitPointerLock ||
				document.webkitExitPointerLock
			;
			document.body.requestPointerLock();
			stop = false;
			playBGM();
		// }
	}, false);
	
	//输入锁定改变事件
	let pointerlockchange = function(){
		if (typeof stop == "string")
			return;
		
		if (
			document.pointerLockElement === document.body ||
			document.mozPointerLockElement === document.body ||
			document.webkitPointerLockElement === document.body
		){ //已锁定
			console.log("pointerLock yes");
			stop = false;
			$("#help").css("display", "none");
		}else{ //未锁定
			console.log("pointerLock no");
			stop = true;
			$("#help").css("display", "inline-block");
			save();
		}
	};
	
	//输入锁定改变错误
	let pointerlockerror = function(){
		console.error("鼠标锁定错误");
		alert("鼠标锁定错误\n请重试或切换/升级浏览器");
	};
	
	// Hook pointer lock state change events
	document.addEventListener("pointerlockchange", pointerlockchange, false);
	document.addEventListener("mozpointerlockchange", pointerlockchange, false);
	document.addEventListener("webkitpointerlockchange", pointerlockchange, false);
	
	document.addEventListener("pointerlockerror", pointerlockerror, false);
	document.addEventListener("mozpointerlockerror", pointerlockerror, false);
	document.addEventListener("webkitpointerlockerror", pointerlockerror, false);
}


/**
* dat.gui
*/
let gui = new dat.GUI({
	name: "控制/调试",
	useLocalStorage: false, // 使用LocalStorage来存储
	closeOnTop: true // 关闭按钮是否在顶部
});
gui.close();


/**
* 初始化
*/
function Thing(opinion){
	//物品ID
	this.id = Number(opinion.id);
	//this.id = Thing.prototype.idLength++; //同时自增
	
	//名称
	if (opinion.name){
		this.name = String(opinion.name);
	}
	
	//方块
	this.block = {};
	if (opinion.block){
		if (opinion.block.face){ //贴图 位置
			this.block.face = [];
			for (let i=0; i<opinion.block.face.length; i++)
				this.block.face[i] = opinion.block.face[i];
		}
		this.block.editFace = (index, value)=>{
			if (index != undefined){ //有索引（单个）
				if (value != undefined){ //赋值
					this.block.face[index] = value;
				}else{ //取值
					return this.block.face[index];
				}
			}else{ //无索引（所有）
				if (value != undefined){ //赋值
					for (let i=0; i<value.length; i++)
						this.block.face[i] = value[i];
				}else{
					return this.block.face;
				}
			}
			return this;
		}
		
		if (opinion.block.texture){ //贴图 数据
			this.block.texture = [];
			for (let i=0; i<opinion.block.texture.length; i++)
				if (opinion.block.texture[i])
					this.block.texture[i] = opinion.block.texture[i];
		}
		this.block.setTexture = (texture, index)=>{
			if (!this.block.texture){
				this.block.texture = [];
			}
			if (index != undefined){ //有索引
				this.block.texture[index] = texture;
			}else{ //无索引
				for (let i=0; i<texture.length; i++){
					this.block.texture[i] = texture[i];
				}
			}
			return this;
		}
		this.block.deleteTexture = (index)=>{
			if (index != undefined){ //有索引
				this.block.texture[index].dispose(); //清除内存
				delete this.block.texture[index];
			}else{ //无索引
				for (let i of this.block.texture)
					i.dispose(); //清除内存
				delete this.block.texture;
			}
			return this;
		}
		
		if (opinion.block.material){ //材质
			this.block.material = opinion.block.material;
		}
		this.block.makeMaterial = ()=>{
			this.block.material = [
				new THREE.MeshLambertMaterial({ map:this.block.texture[0], transparent:true/*, visible:false*/ }),
				new THREE.MeshLambertMaterial({ map:this.block.texture[1], transparent:true/*, visible:false*/ }),
				new THREE.MeshLambertMaterial({ map:this.block.texture[2], transparent:true/*, visible:false*/ }),
				new THREE.MeshLambertMaterial({ map:this.block.texture[3], transparent:true/*, visible:false*/ }),
				new THREE.MeshLambertMaterial({ map:this.block.texture[4], transparent:true/*, visible:false*/ }),
				new THREE.MeshLambertMaterial({ map:this.block.texture[5], transparent:true/*, visible:false*/ })
			]; //材质对象 MeshLambertMaterial
			return this;
		}
		this.block.deleteMaterial = ()=>{
			for (let i of this.block.material)
				i.dispose(); //清除内存
			delete this.block.material;
			return this;
		}
		
		if (opinion.block.mesh){ //网格模型
			this.block.mesh = opinion.block.mesh;
		}
		this.block.makeMesh = (geometry)=>{
			if (geometry){
				this.block.mesh = new THREE.Mesh(geometry, this.block.material); //网格模型对象Mesh
			}else{ //使用默认
				this.block.mesh = new THREE.Mesh(Thing.prototype.geometry, this.block.material); //网格模型对象Mesh
			}
			this.block.mesh.castShadow = true;
			this.block.mesh.receiveShadow = true;
			return this;
		}
		this.block.deleteMesh = (index)=>{
			this.block.mesh.material.dispose();
			this.block.mesh.geometry.dispose(); //清除内存
			delete this.block.mesh;
			return this;
		}
	}
	
	//持有时的效果
	this.hold = {};
	if (opinion.hold){
		if (opinion.hold.tool){
			this.hold.tool = opinion.hold.tool;
		}
		if (opinion.hold.head){
			this.hold.head = opinion.hold.head;
		}
		if (opinion.hold.body){
			this.hold.body = opinion.hold.body;
		}
		if (opinion.hold.leg){
			this.hold.leg = opinion.hold.leg;
		}
		if (opinion.hold.foot){
			this.hold.foot = opinion.hold.foot;
		}
	}
}
//Thing.prototype.idLength = 0;
Thing.prototype.geometry = new THREE.BoxGeometry(100, 100, 100);


function BlockMap(size, seed){
	//一区块大小
	this.size = {};
	this.size.x = Math.round(size[1].x - size[0].x);
	this.size.y = Math.round(size[1].y - size[0].y);
	this.size.z = Math.round(size[1].z - size[0].z);
	this.size[0] = {};
	this.size[1] = {};
	this.size[0].x = Math.round(size[0].x); //-8
	this.size[0].y = Math.round(size[0].y); //0
	this.size[0].z = Math.round(size[0].z); //-8
	this.size[1].x = Math.round(size[1].x); //8
	this.size[1].y = Math.round(size[1].y); //32
	this.size[1].z = Math.round(size[1].z); //8
	
	//所有方块
	this.map = [];
	//活动区块
	this.activeBlock = [];
	//种子设置
	if (seed){
		/* h:height, s:scale{
			ave: 均值,
			de: 最大波动程度,
			q: 波动程度
		}*/
		this.seed = {
			seed: seed.seed,
			h: {
				ave: seed.height.ave,
				de: seed.height.de,
				q: seed.height.q
			},
			s: {
				ave: seed.scale.ave,
				de: seed.scale.de,
				q: seed.scale.q
			}
		};
		this.seed.noise = new SimplexNoise(this.seed.seed);
	}
	
	
	
	//获取方块（不可编辑）
	this.get = (x, y, z)=>{
		[x, y, z] = [x, y, z].map(Math.round); //规范化
		
		try{
			if (this.map[x][y][z] == undefined){
				return null;
			}else{
				return this.map[x][y][z];
			}
		}catch(err){ //超过范围
			return null;
		}
	};
	
	//添加方块
	this.add = (thing, pos)=>{
		[pos.x, pos.y, pos.z] = [pos.x, pos.y, pos.z].map(Math.round); //规范化
		
		//console.log(thing.block.mesh, pos)
		thing.block.mesh.position.x = pos.x*100;
		thing.block.mesh.position.y = pos.y*100;
		thing.block.mesh.position.z = pos.z*100;
		//thing.block.visible = false; //默认不绘制
		
		scene.add(thing.block.mesh); //网格模型添加到场景中
		//thing.block.mesh = thing.block.mesh;
		this.map[pos.x][pos.y][pos.z] = thing;
	};
	//根据 模板和ID 添加方块
	this.addID = (id, pos, template)=>{
		if (!id)
			return; //ID为0（空气）
		//try{
		this.add(
			new Thing(template[id])
				.block.makeMaterial()
				.block.deleteTexture()
				.block.makeMesh(),
			{
				x:pos.x,
				y:pos.y,
				z:pos.z,
			}
		); //以模板建立
		//}catch(err){console.info(template[id], template[id].block.texture, id, err)}
	};
	
	//删除方块
	this.delete = (x, y, z)=>{
		[x, y, z] = [x, y, z].map(Math.round); //规范化
		
		if (!this.get(x,y,z)) // 没有方块/不在范围
			return;
		
		for (let i of this.map[x][y][z].block.mesh.material)
			i.dispose();
		this.map[x][y][z].block.mesh.geometry.dispose(); //清除内存
		scene.remove(this.map[x][y][z].block.mesh);
		this.map[x][y][z] = null;
	};
	
	
	//初始化区块
	this.initBlock = (x, z)=>{
		[x, z] = [x, z].map(Math.round); //规范化
		
		let ox = x*this.size.x,
			oz = z*this.size.z; //区块中心坐标
		for (let dx=this.size[0].x; dx<=this.size[1].x; dx++){
			this.map[ox+dx] = this.map[ox+dx] || [];
			for (let dy=this.size[0].y; dy<=this.size[1].y; dy++){
				this.map[ox+dx][dy] = this.map[ox+dx][dy] || [];
				for (let dz=this.size[0].z; dz<=this.size[1].z; dz++){
					this.map[ox+dx][dy][oz+dz] = null;
				}
			}
		}
	};
	
	//加载区块（同步）
	this.loadBlock = (x, z)=>{
		[x, z] = [x, z].map(Math.round); //规范化
		let ox = x*this.size.x,
			oz = z*this.size.z, //区块中心坐标
			t = this.seed; //临时变量
			
		if (this.activeBlock.every(function(value, index, arr){
			return value[0] != x || value[1] != z;
		})) //每个都不一样（不存在）
			this.activeBlock.push([x,z]);
		
		for (let dx=this.size[0].x; dx<=this.size[1].x; dx++){
			for (let dz=this.size[0].z; dz<=this.size[1].z; dz++){
				let height = t.noise.noise3D(0.6, (ox+dx)/t.h.q, (oz+dz)/t.h.q) *t.h.de + t.h.ave;
				let grass = false;
				for (let dy=this.size[1].y; dy>=this.size[0].y; dy--){ //注意：从上到下
					let earth = height - height * (t.noise.noise3D(6.6, (ox+dx)/t.s.q, (oz+dz)/t.s.q) *t.s.de + t.s.ave);
					if (dy > height){
						// 空气/真空 (null)：不用加载
					}else if (dy > earth){
						if (grass){
							this.addID(2, {
								x: ox+dx,
								y: dy,
								z: oz+dz
							}, template); //泥土
						}else{
							this.addID(1, {
								x: ox+dx,
								y: dy,
								z: oz+dz
							}, template); //草方块
							grass = true;
						}
					}else{
						this.addID(4, {
							x: ox+dx,
							y: dy,
							z: oz+dz
						}, template); //石头
					}
				}
			}
		}
	}
	//加载区块（异步）
	this.loadBlockAsync = (x, z, callback)=>{
		[x, z] = [x, z].map(Math.round); //规范化
		let ox = x*this.size.x,
			oz = z*this.size.z, //区块中心坐标
			t = this.seed; //临时变量
		
		if (callback){ //有回调（必须setInterval）
			let dx = this.size[0].x;
			let loadBlock_id = setInterval(()=>{
				if (dx > this.size[1].x){
					clearInterval(loadBlock_id);
					
					if (this.activeBlock.every(function(value, index, arr){
						return value[0] != x || value[1] != z;
					})) //每个都不一样（不存在）
						this.activeBlock.push([x,z]);
					
					if (callback)
						callback();
					return;
				}
				
				//正常代码
				for (let dz=this.size[0].z; dz<=this.size[1].z; dz++){
					let height = t.noise.noise3D(0.6, (ox+dx)/t.h.q, (oz+dz)/t.h.q) *t.h.de + t.h.ave;
					let grass = false;
					for (let dy=this.size[1].y; dy>=this.size[0].y; dy--){ //注意：从上到下
						let earth = height - height * (t.noise.noise3D(6.6, (ox+dx)/t.s.q, (oz+dz)/t.s.q) *t.s.de + t.s.ave);
						if (dy > height){
							// 空气/真空 (null)：不用加载
						}else if (dy > earth){
							if (grass){
								this.addID(2, {
									x: ox+dx,
									y: dy,
									z: oz+dz
								}, template); //泥土
							}else{
								this.addID(1, {
									x: ox+dx,
									y: dy,
									z: oz+dz
								}, template); //草方块
								grass = true;
							}
						}else{
							this.addID(4, {
								x: ox+dx,
								y: dy,
								z: oz+dz
							}, template); //石头
						}
					}
				}
				
				dx++;
			},0);
		}else{ //无回调（不分顺序）
			if (this.activeBlock.every(function(value, index, arr){
				return value[0] != x || value[1] != z;
			})) //每个都不一样（不存在）
				this.activeBlock.push([x,z]);
			
			for (let dx=this.size[0].x; dx<=this.size[1].x; dx++){
				setTimeout(()=>{
					
					//正常代码
					for (let dz=this.size[0].z; dz<=this.size[1].z; dz++){
						let height = t.noise.noise3D(0.6, (ox+dx)/t.h.q, (oz+dz)/t.h.q) *t.h.de + t.h.ave;
						let grass = false;
						for (let dy=this.size[1].y; dy>=this.size[0].y; dy--){ //注意：从上到下
							let earth = height - height * (t.noise.noise3D(6.6, (ox+dx)/t.s.q, (oz+dz)/t.s.q) *t.s.de + t.s.ave);
							if (dy > height){
								// 空气/真空 (null)：不用加载
							}else if (dy > earth){
								if (grass){
									this.addID(2, {
										x: ox+dx,
										y: dy,
										z: oz+dz
									}, template); //泥土
								}else{
									this.addID(1, {
										x: ox+dx,
										y: dy,
										z: oz+dz
									}, template); //草方块
									grass = true;
								}
							}else{
								this.addID(4, {
									x: ox+dx,
									y: dy,
									z: oz+dz
								}, template); //石头
							}
						}
					}
					
				},0);
			}
		}
	};
	
	//卸载区块（同步）
	this.unloadBlock = (x, z)=>{
		[x, z] = [x, z].map(Math.round); //规范化
		let ox = x*this.size.x,
			oz = z*this.size.z; //区块中心坐标
		
		for (let i in this.activeBlock)
			if (this.activeBlock[i][0] == x && this.activeBlock[i][1] == z)
				this.activeBlock.splice(i,1); //从i开始删除一个元素
		
		for (let dx=this.size[0].x; dx<=this.size[1].x; dx++){
			for (let dy=this.size[0].y; dy<=this.size[1].y; dy++){
				for (let dz=this.size[0].z; dz<=this.size[1].z; dz++){
					if (this.map[ox+dx][dy][oz+dz] != null){
						for (let i of this.map[ox+dx][dy][oz+dz].block.mesh.material)
							i.dispose();
						this.map[ox+dx][dy][oz+dz].block.mesh.geometry.dispose(); //清除内存
						scene.remove(this.map[ox+dx][dy][oz+dz].block.mesh);
					}
					delete this.map[ox+dx][dy][oz+dz];
				}
			}
		}
	};
	//卸载区块（异步）
	this.unloadBlockAsync = (x, z, callback)=>{
		[x, z] = [x, z].map(Math.round); //规范化
		let ox = x*this.size.x,
			oz = z*this.size.z; //区块中心坐标
		
		for (let i in this.activeBlock)
			if (this.activeBlock[i][0] == x && this.activeBlock[i][1] == z)
				this.activeBlock.splice(i,1); //从i开始删除一个元素
		
		if (callback){ //有回调（必须setInterval）
			let dx = this.size[0].x;
			let unloadBlock_id = setInterval(()=>{
				if (dx > this.size[1].x){
					clearInterval(unloadBlock_id);
					if (callback)
						callback();
					return;
				}
				
				//正常代码
				for (let dy=this.size[0].y; dy<=this.size[1].y; dy++){
					for (let dz=this.size[0].z; dz<=this.size[1].z; dz++){
						if (this.map[ox+dx][dy][oz+dz] != null){ //非空气
							for (let i of this.map[ox+dx][dy][oz+dz].block.mesh.material)
								i.dispose();
							this.map[ox+dx][dy][oz+dz].block.mesh.geometry.dispose(); //清除内存
							scene.remove(this.map[ox+dx][dy][oz+dz].block.mesh);
						}
						delete this.map[ox+dx][dy][oz+dz];
					}
				}
				
				dx++;
			},0);
		}else{ //无回调（不分顺序）
			for (let dx=this.size[0].x; dx<=this.size[1].x; dx++){
				setTimeout(()=>{
					
					//正常代码
					for (let dy=this.size[0].y; dy<=this.size[1].y; dy++){
						for (let dz=this.size[0].z; dz<=this.size[1].z; dz++){
							if (this.map[ox+dx][dy][oz+dz] != null){ //非空气
								for (let i of this.map[ox+dx][dy][oz+dz].block.mesh.material)
									i.dispose();
								this.map[ox+dx][dy][oz+dz].block.mesh.geometry.dispose(); //清除内存
								scene.remove(this.map[ox+dx][dy][oz+dz].block.mesh);
							}
							delete this.map[ox+dx][dy][oz+dz];
						}
					}
					
				},0);
			}
		}
	};
	
	
	//更新方块
	this.update = (x, y, z)=>{
		[x, y, z] = [x, y, z].map(Math.round); //规范化
		
		if (!this.get(x,y,z)) // 没有方块/不在范围
			return;
		
		this.map[x][y][z].block.material[0].visible = this.get(x+1, y, z)==null;
		this.map[x][y][z].block.material[1].visible = this.get(x-1, y, z)==null;
		this.map[x][y][z].block.material[2].visible = this.get(x, y+1, z)==null;
		this.map[x][y][z].block.material[3].visible = this.get(x, y-1, z)==null;
		this.map[x][y][z].block.material[4].visible = this.get(x, y, z+1)==null;
		this.map[x][y][z].block.material[5].visible = this.get(x, y, z-1)==null;
	};
	
	//更新方块及周围
	this.updateRound = (x,y,z)=>{
		this.update(x, y, z);
		this.update(x+1, y, z);
		this.update(x-1, y, z);
		this.update(x, y+1, z);
		this.update(x, y-1, z);
		this.update(x, y, z+1);
		this.update(x, y, z-1);
	};
	
	//更新区块内所有方块（同步）
	this.updateBlock = (x, z)=>{
		let ox = x*this.size.x,
			oz = z*this.size.z; //区块中心坐标
		
		for (let dx=this.size[0].x; dx<=this.size[1].x; dx++){
			for (let dy=this.size[0].y; dy<=this.size[1].y; dy++){
				for (let dz=this.size[0].z; dz<=this.size[1].z; dz++){
					this.update(ox+dx, dy, oz+dz);
				}
			}
		}
	};
	//更新区块内所有方块（异步）
	this.updateBlockAsync = (x, z, callback)=>{
		let ox = x*this.size.x,
			oz = z*this.size.z; //区块中心坐标
		
		if (callback){ //有回调（必须setInterval）
			let dx = this.size[0].x;
			let updateBlock_id = setInterval(()=>{
				if (dx > this.size[1].x){
					clearInterval(updateBlock_id);
					callback();
					return;
				}
				
				//正常代码
				for (let dy=this.size[0].y; dy<=this.size[1].y; dy++){
					for (let dz=this.size[0].z; dz<=this.size[1].z; dz++){
						this.update(ox+dx, dy, oz+dz);
					}
				}
				
				dx++;
			},0);
		}else{ //无回调（不分顺序）
			for (let dx=this.size[0].x; dx<=this.size[1].x; dx++){
				setTimeout(()=>{
					
					//正常代码
					for (let dy=this.size[0].y; dy<=this.size[1].y; dy++){
						for (let dz=this.size[0].z; dz<=this.size[1].z; dz++){
							this.update(ox+dx, dy, oz+dz);
						}
					}
					
				},0);
			}
		}
		
		/* for (let dx=this.size[0].x; dx<=this.size[1].x; dx++){
			for (let dy=this.size[0].y; dy<=this.size[1].y; dy++){
				for (let dz=this.size[0].z; dz<=this.size[1].z; dz++){
					this.update(ox+dx, dy, oz+dz);
				}
			}
		} */
	};
	
	/* //保存为数组字符串
	this.save = ()=>{
		let arr = [];
		for (let x=this.size[0].x; x<=this.size[1].x; x++){
			for (let y=this.size[0].y; y<=this.size[1].y; y++){
				for (let z=this.size[0].z; z<=this.size[1].z; z++){
					arr.push(this.map[x][y][z]);
				}
			}
		}
		return JSON.stringify(arr);
		//localStorage.setItem("我的世界.存档.方块", JSON.stringify(arr));
	};
	//加载保存的数组字符串
	this.useSave = (arr)=>{
		//let arr = JSON.parse(localStorage.getItem("我的世界.存档.方块"));
		let index = 0;
		for (let x=this.size[0].x; x<=this.size[1].x; x++){
			for (let y=this.size[0].y; y<=this.size[1].y; y++){
				for (let z=this.size[0].z; z<=this.size[1].z; z++){
					this.map[x][y][z] = arr[index++];
				}
			}
		}
	}; */
}

const face_url = [
	["side.png", "side.png", "up.png", "down.png", "side.png", "side.png"],
	["face.png", "face.png", "face.png", "face.png", "face.png", "face.png"]
];
const template = []; //模板
template.push(new Thing({
	id: 0,
	name: "空气"
}));
template.push(new Thing({
	id: 1,
	name: "草方块",
	block: {
		face: face_url[0]
	}
}));
template.push(new Thing({
	id: 2,
	name: "泥土",
	block: {
		face: face_url[1]
	}
}));
template.push(new Thing({
	id: 3,
	name: "木板",
	block: {
		face: face_url[1]
	}
}));
template.push(new Thing({
	id: 4,
	name: "石头",
	block: {
		face: face_url[1]
	}
}));
template.push(new Thing({
	id: 5,
	name: "原石",
	block: {
		face: face_url[1]
	}
}));
template.push(new Thing({
	id: 6,
	name: "沙子",
	block: {
		face: face_url[1]
	}
}));
template.push(new Thing({
	id: 7,
	name: "砖",
	block: {
		face: face_url[1]
	}
}));
template.push(new Thing({
	id: 8,
	name: "仙人掌",
	block: {
		face: face_url[0]
	}
}));
template.push(new Thing({
	id: 9,
	name: "命令方块",
	block: {
		face: face_url[0]
	}
}));

let map = new BlockMap([
	{x: -8, y: 0, z: -8},
	{x: 8, y: 32, z: 8}
],{
	seed: prompt("请输入种子\n（取消或输入为空则随机生成）") || undefined,
	height: {
		ave: 10,
		de: 5,
		q: 66
	},
	scale: {
		ave: 0.266,
		de: 0.16,
		q: 66
	}
});
document.title = "我的世界:"+(map.seed.seed? map.seed.seed: "随机世界");

function save(){
	return;
	localStorage.setItem("我的世界.存档.方块", map.save());
	localStorage.setItem("我的世界.存档.玩家.位置", JSON.stringify(deskgood.pos));
	localStorage.setItem("我的世界.存档.玩家.朝向", JSON.stringify(deskgood.lookAt));
	localStorage.setItem("我的世界.存档.玩家.物品.工具栏", JSON.stringify({
		tools: deskgood.tools,
		choice: deskgood.choice
	}));
	console.log("备份成功");
}
setInterval(save, 60*1000);
gui.add({f:function(){
	run(prompt("请输入命令：","deskgood.goY(3000*100);"))
}}, "f").name("运行(run)命令");
gui.add(window, "save").name("保存(save)");
gui.add(location, "reload").name("刷新(reload)");
window.addEventListener("beforeunload", save);


/**
* 创建场景对象Scene
*/
let scene = new THREE.Scene();
scene.fog = new THREE.Fog("#fff", 0.01, 200*100);
//						 雾气颜色，近处的距离，远处的距离(66m)
let scene_folder = gui.addFolder("场景(scene)");
	scene_folder.add(scene.children, "length", 0, 10000).name("物体(object)个数").listen();
	let scene_fog_folder = scene_folder.addFolder("雾(fog)");
		scene_fog_folder.add(scene.fog, "far", 15*100, 1000*100, 100);
		scene_fog_folder.add(scene.fog, "near", 0.001, 10);
		scene_fog_folder.addColor(scene.fog, "color");


/**
 * 天气(sprite精灵)
 */
weather = Math.random()<0.25? 0: Math.random()*Math.random()*Math.random()/300*1000;//Math.abs(1-(Math.log(Math.random()+0.003)+6)/6);
console.info(`降水概率:${weather}滴/s/m²`, `降水范围：地图有效区域（<x:${map.size[0].x}~${map.size[1].x}>*<z:${map.size[0].z}~${map.size[1].z}>）`);
let sprite_system = [],
	sprite_lastTime = null,
	sprite_material = new THREE.SpriteMaterial({
		color: "#4c51a7", //设置精灵矩形区域颜色
		//rotation: Math.PI/180*45, //旋转精灵对象45度，弧度值
		//map: texture, //设置精灵纹理贴图
	});
setInterval(function(){
	if (sprite_lastTime == null)
		sprite_lastTime = new Date();
	let t = Math.round((new Date() - sprite_lastTime)/1000*map.size.x*map.size.z*weather);
	sprite_lastTime = new Date();
	
	if (stop)
		return;
	
	//雨滴降落
	for (let i=0; i<sprite_system.length; i++){
		//sprite_system[i].v -= 9.8*t/1000*100;
		sprite_system[i].position.y -= 10*1000*t/1000*(Math.random()*0.2+0.9); //10m/s //sprite_system[i].v*t/1000;
		if (/*!map.get(
				sprite_system[i].position.x/100,
				sprite_system[i].position.y/100,
				sprite_system[i].position.z/100
			)||*/
			sprite_system[i].position.y < 0
		){ // 有方块/超出界限
			sprite_system[i].material.dispose(); //清除内存
			scene.remove(sprite_system[i]);
			sprite_system.splice(i,1);
		}
	}
	
	while (t--){
		if (Math.random() <= weather){
			//创建精灵模型对象，不需要几何体geometry参数
			let sprite = new THREE.Sprite(sprite_material);
			scene.add(sprite);
			let pX = Math.random()*2000-1000, //[-1000,1000)
				pY = Math.random()*150*100+200*100, //[150m,200m)
				pZ = Math.random()*2000-1000; //[-1000,1000)
			
			sprite.position.set(pX, pY, pZ); //设置精灵位置
			//控制精灵大小，比如可视化中精灵大小表征数据大小
			sprite.scale.set(Math.random()*3+3, Math.random()*26+10, 1); //只需要设置x、y两个分量就可以 x:[3,6) y:[10,36)
			sprite_system.push(sprite);
		}
	}
}, 0);

let weather_folder = gui.addFolder("天气(weather)");
	weather_folder.add(window, "weather", 0, 1/300*1000, 1e-3).name("降水系数").onChange((value)=>{weather = Math.pow(value*300/1000,3)/300*1000});
	weather_folder.add(sprite_system, "length", 0, 1000, 1).name("雨滴(sprite)个数").listen();
	weather_folder.add({clean: function(){
		for (let i in sprite_system){
			scene.remove(sprite_system[i]);
		}
		sprite_system.splice(0, sprite_system.length);
	}},"clean").name("清空(clean)");


/**
* 创建网格模型
*/
// let block_geometry = new THREE.BoxGeometry(100, 100, 100);
// TextureLoader创建一个纹理加载器对象，可以加载图片作为几何体纹理
// let num = 0;
let block_load = {
	i: 1,
	id: null
}
// for (let i=1; i<template.length; i++){
$("#schedule progress")[0].max = template.length;
block_load.id = setInterval(function(){
	for (let j=0; j<6; j++){
		template[block_load.i].block.setTexture(
			new THREE.TextureLoader()
				.load(`./img/blocks/${block_load.i}/${template[block_load.i].block.face[j]}`), j);
		//$("#schedule2").text( Math.round( (j+1)/6*100 *100)/100 );
	}
	
	//单个block加载完毕
	$("#schedule span").text( Math.round( block_load.i++/(template.length-1)*100 *100)/100 );
	$("#schedule progress")[0].value = block_load.i;
	//$("#schedule2").text(0);
	
	if (block_load.i >= template.length){ //所有block加载完毕
		clearInterval(block_load.id);
		delete block_load;
		$("#schedule header").text("载入方块中……");
		
		map.initBlock(0, 0); //初始化区块
		map.loadBlockAsync(0, 0, function(){
			map.updateBlockAsync(0, 0); //更新区块
			$("#schedule span").text("100");
			$("#schedule progress")[0].value = template.length;
			setTimeout(function(){
				render(); //纹理贴图加载成功后，调用渲染函数执行渲染操作
				$("#schedule").remove();
			},0);
		}); //用噪声填充区块
	}
},0);

/* let textureLoader = new THREE.TextureLoader();
for (let i=1; i<template.length; i++){
	for (let j=0; j<6; j++){
		textureLoader.load(`./img/blocks/${i}/${template[i].block.face[j]}`, function (texture){
			template[i].block.setTexture(texture, j);
			
			if (template[i].block.texture.length < 6)
				return;
			for (let k=0; k<template[i].block.texture.length; k++)
				if (!template[i].block.texture[k])
					return;
			
			//单个block加载完毕
			//template[i].block.makeMaterial().block.deleteTexture();
			//template[i].block.makeMesh().deleteMaterial();
			$("#schedule2").text( Math.round(i/template.length*100*100)/100 );
			
			for (let k=1; k<template.length; k++)
				if (!template[k].block.texture/*material*//*)
					return;
			
			//所有block加载完毕
			$("#schedule_message").text("载入方块中……");
			$("#schedule1").text("50");
			if (localStorage.getItem("我的世界.存档.方块")){
				map.useSave( JSON.parse(localStorage.getItem("我的世界.存档.方块")) );
				console.log("achieve loading");
				$("#schedule1").text("100");
				//纹理贴图加载成功后，调用渲染函数执行渲染操作
				render();
				$("#schedule").remove();
			}else{ //初始化地形
				map.loadBlock(0, 0);
				map.initBlock(0, 0);
				
				$("#schedule1").text("100");
				//纹理贴图加载成功后，调用渲染函数执行渲染操作
				render();
				$("#schedule").remove();
				/*let load = {
					x: null,
					loop: null
				}
				load.x = map.size[0].x;
				load.loop = setInterval(function (){
					for (let y=map.size[0].y; y<=map.size[1].y; y++){
						for (let z=map.size[0].z; z<=map.size[1].z; z++){
							let id = 0;
							if (y == 0){
								id = 3;
							}else if (y == 1){
								if (load.x < 0){
									id = 1;
								}else if (load.x > 6){
									id = 2;
								}else{
									id = 4;
								}
							}else if (y < 6){
								id = 6;
							}
							if (id != 0)
								map.add(new Thing(template[id]).block.makeMaterial().block.deleteTexture().block.makeMesh(), {x:load.x, y, z}); //以模板建立
								//map.update(load.x ,y ,z); //刷新是否添加方块
								// template[id].block.deleteMesh();
						}
					}
					
					$("#schedule2").text( Math.round((load.x-map.size[0].x)/map.size.x*100*100)/100 );
					
					console.log("finish loading:", load.x);
					if (++load.x > map.size[1].x){
						console.log("achieve loading");
						map.updateAll();
						$("#schedule1").text("100");
						//纹理贴图加载成功后，调用渲染函数执行渲染操作
						render();
						$("#schedule").remove();
						clearInterval(load.loop);
						/* delete load.loop;
						delete load.x; *//*
					}
				},0);*//*
			}
		});
	}
} */

/* let floor_geometry = new THREE.PlaneGeometry(1000, 1000, 6, 6);
let floor_material = new THREE.MeshBasicMaterial({ color:"#fff"});
//floor_material.wireframe = true; //仅框架
floor_mesh = new THREE.Mesh(floor_geometry, floor_material);
// 由于平地添加后默认是在正前方 所以需要旋转一下
floor_mesh.rotation.x = -0.5 * Math.PI;
floor_mesh.position.y = -10;
scene.add(floor_mesh); */


// 改变AxesHelper构造函数的参数，可以改变三维坐标轴的大小
// 参数设置坐标轴大小:1000
var axesHelper = new THREE.AxesHelper(1666);
scene.add(axesHelper);


/**
* 光源设置
*/

/*//点光源
let point = new THREE.PointLight(0xffffff);
point.position.set(0, 10*100, 0); //点光源位置
scene.add(point); //点光源添加到场景中*/
let scene_light_folder = scene_folder.addFolder("光源(light)");

//平行光
var directionalLight = new THREE.DirectionalLight("#fff", 1);
directionalLight.position.set(2, 1, 2);
directionalLight.castShadow = true;
directionalLight.onlyShadow = true;
directionalLight.shadow.mapSize.width = Math.pow(2, 10);  // default:512
directionalLight.shadow.mapSize.height = Math.pow(2, 10); // default:512
directionalLight.shadow.camera.near = 0.5;
directionalLight.shadow.camera.far = 200*100;
directionalLight.shadow.camera.left = -200*100;
directionalLight.shadow.camera.right = 200*100;
directionalLight.shadow.camera.top = 200*100;
directionalLight.shadow.camera.bottom = -200*100;
message(`
<font style="font-size:16px">
	如果设备
		<font style="font-size:20px;">性能差</font>
		，使用光影效果将会导致
		<font style=\"font-size:20px;\">卡顿</font>。<br/>
		点此可
		<a onclick="directionalLight.castShadow=false;message('妈妈再也不用担心手机卡还发烫了（只担心画质丑的一批）','short',3000);" style="color:blue; text-decoration:underline;">
			关闭光影
		</a>
	</font>`,"long", 5000);
/* document.addEventListener("plusready", function(){
	plus.nativeUI.toast(
		
		{
			type:"richtext",
			duration:"long",
			verticalAlign: "top",
			richTextStyle:{align:"center"}
		}
	);
}); */
scene.add(directionalLight);
// 光照指向平地
//directionalLight.target = ;
let scene_light_directionalLight_folder = scene_light_folder.addFolder("平行光(directionalLight)");
	scene_light_directionalLight_folder.add(directionalLight, "castShadow").name("阴影");
	let scene_light_directionalLight_mapSize_folder = scene_light_directionalLight_folder.addFolder("阴影贴图大小(mapSize)");
		scene_light_directionalLight_mapSize_folder.add(directionalLight.shadow.mapSize, "width", Math.pow(2,9), Math.pow(2,12), Math.pow(2,9));
		scene_light_directionalLight_mapSize_folder.add(directionalLight.shadow.mapSize, "height", Math.pow(2,9), Math.pow(2,12), Math.pow(2,9));
	let scene_light_directionalLight_position_folder = scene_light_directionalLight_folder.addFolder("位置(position)");
		scene_light_directionalLight_position_folder.add(directionalLight.position, "x", -3, 3, 0.1);
		scene_light_directionalLight_position_folder.add(directionalLight.position, "y", -3, 3, 0.1);
		scene_light_directionalLight_position_folder.add(directionalLight.position, "z", -3, 3, 0.1);

//辅助线
//var directionalLight_CameraHelper = new THREE.CameraHelper(directionalLight.shadow.camera);
//scene.add(directionalLight_CameraHelper);

//户外光源
var hemiLight = new THREE.HemisphereLight("#87ceeb", "#f5deb3", 0.4/*"#aaf", "#888", 1*/);
hemiLight.position.set(0,500,0);
scene.add(hemiLight);

let scene_light_hemiLight_folder = scene_light_folder.addFolder("户外光源(hemiLight)");
	let scene_light_hemiLight_position_folder = scene_light_hemiLight_folder.addFolder("位置(position)");
		scene_light_hemiLight_position_folder.add(hemiLight.position, "x", -3, 3, 0.1);
		scene_light_hemiLight_position_folder.add(hemiLight.position, "y", -3, 3, 0.1);
		scene_light_hemiLight_position_folder.add(hemiLight.position, "z", -3, 3, 0.1);

//环境光
let ambient = new THREE.AmbientLight(0x444444);
scene.add(ambient);

let scene_light_ambient_folder = scene_light_folder.addFolder("环境光(ambient)");
	scene_light_ambient_folder.addColor(ambient, "color");

/**
* 相机设置
*/
/* let width = window.innerWidth; //窗口宽度
let height = window.innerHeight; //窗口高度
let k = width / height; //窗口宽高比
let s = 1000; //三维场景显示范围控制系数，系数越大，显示的范围越大
//创建相机对象
let camera = new THREE.OrthographicCamera(-s * k, s * k, s, -s, 1, 1000);
camera.position.set(0, 200, 0); //设置相机位置
camera.lookAt(scene.position); //设置相机方向(指向的场景对象) */

let WIDTH = window.innerWidth,
	HEIGHT = window.innerHeight;

var camera = new THREE.PerspectiveCamera(45, WIDTH/HEIGHT, 1, 1000*100);
//								 view_angle, aspect, near, far(1km)
camera.position.set(0, 20*100, 0); //设置相机位置
camera.lookAt(scene.position); //设置相机方向(指向的场景对象)
/*setTimeout(function(){
	console.info(camera);
},1000);*/

/**
* 创建渲染器对象
*/
let renderer = new THREE.WebGLRenderer();
renderer.setSize(WIDTH, HEIGHT);//设置渲染区域尺寸
renderer.setClearColor("#eef", 1); //设置背景颜色
renderer.domElement.style.margin = "0";
document.body.appendChild(renderer.domElement); //body元素中插入canvas对象
renderer.domElement.style.cursor = "none";
renderer.shadowMapEnabled = true; //阴影
//执行渲染操作   指定场景、相机作为参数
renderer.render(scene, camera);

renderer.color = {
	get clearColor(){
		return renderer.getClearColor();
	},
	set clearColor(value){
		console.log("set clear color:", value);
		renderer.setClearColor(
			"rgb("+
				Math.round(value.r)+","+
				Math.round(value.g)+","+
				Math.round(value.b)+
			")"
		, 1);
	}
};
let renderer_folder = gui.addFolder("渲染器(renderer)");
	renderer_folder.addColor(renderer.color, "clearColor");

window.onresize = function(){
	WIDTH = window.innerWidth;
	HEIGHT = window.innerHeight;
	renderer.setSize(window.innerWidth, window.innerHeight);
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix(); //更新投影矩阵
};


/**
* 背景
*/
function dateToNumber(h=0, m=0, s=0){
	return (s/60+m)/60+h;
}
//0~5:45	5:45	6:15		6:45~18:25	18:55		19:25		19:25~24
//天黑		日出(R)	日出(G,B)	白天		日落(G,B)	日落(R)		天黑
setTimeout(function(){
	let h = new Date();
	//h = (h.getSeconds()+h.getMilliseconds()/1000)/60*24
	h = h.getHours() + h.getMinutes()/60 + h.getSeconds()/3600;
	if (h > dateToNumber(19,25) | h < dateToNumber(5,45)){ // 天黑
		ambient.color = new THREE.Color("#223");
		//renderer.setClearColor("#334", 1);
	}else if (h > dateToNumber(18,25) | h < dateToNumber(6,45)){ // 日出/日落
		ambient.color = new THREE.Color("#f9a");
		//renderer.setClearColor("#a34", 1);
	}else{ //白天
		ambient.color = new THREE.Color("#aac");
		//renderer.setClearColor("#eef", 1);
	}
	renderer.setClearColor(
		"rgb("+
			Math.round(Math.min( 230/(1+Math.pow(6,-36/30*(h- dateToNumber(5,45) )))+10, 230-(230/(1+Math.pow(6,-36/30*(h- dateToNumber(19,25) ))))+10 ))+","+
			Math.round(Math.min( 230/(1+Math.pow(6,-36/30*(h- dateToNumber(6,15) )))+10, 230-(230/(1+Math.pow(6,-36/30*(h- dateToNumber(18,55) ))))+10 ))+","+
			Math.round(Math.min( 230/(1+Math.pow(6,-36/30*(h- dateToNumber(6,15) )))+20, 230-(230/(1+Math.pow(6,-36/30*(h- dateToNumber(18,55) ))))+20 ))+
		")"
	);
}, 0);
setInterval(function(){
	let h = new Date();
	// h = (h.getSeconds()+h.getMilliseconds()/1000)/60*24
	h = h.getHours() + h.getMinutes()/60 + h.getSeconds()/3600;
	if (h > dateToNumber(19,25) | h < dateToNumber(5,45)){ // 天黑
		ambient.color = new THREE.Color("#223");
		//renderer.setClearColor("#334", 1);
	}else if (h > dateToNumber(18,25) | h < dateToNumber(6,45)){ // 日出/日落
		ambient.color = new THREE.Color("#f9a");
		//renderer.setClearColor("#a34", 1);
	}else{ //白天
		ambient.color = new THREE.Color("#aac");
		//renderer.setClearColor("#eef", 1);
	}
	renderer.setClearColor(
		"rgb("+
			Math.round(Math.min( 230/(1+Math.pow(6,-36/30*(h- dateToNumber(5,45) )))+10, 230-(230/(1+Math.pow(6,-36/30*(h- dateToNumber(19,25) ))))+10 ))+","+
			Math.round(Math.min( 230/(1+Math.pow(6,-36/30*(h- dateToNumber(6,15) )))+10, 230-(230/(1+Math.pow(6,-36/30*(h- dateToNumber(18,55) ))))+10 ))+","+
			Math.round(Math.min( 230/(1+Math.pow(6,-36/30*(h- dateToNumber(6,15) )))+20, 230-(230/(1+Math.pow(6,-36/30*(h- dateToNumber(18,55) ))))+20 ))+
		")"
	);
	/*console.log(
		"time:"+h,
		"\nR:",
		230/(1+Math.pow(6,-36/30*(h- dateToNumber(5,45) )))+10, 230-(230/(1+Math.pow(6,-36/30*(h- dateToNumber(19,25) ))))+10,
		"\nG:",
		230/(1+Math.pow(6,-36/30*(h- dateToNumber(6,15) )))+10, 230-(230/(1+Math.pow(6,-36/30*(h- dateToNumber(18,55) ))))+10,
		"\nB:",
		230/(1+Math.pow(6,-36/30*(h- dateToNumber(6,15) )))+20, 230-(230/(1+Math.pow(6,-36/30*(h- dateToNumber(18,55) ))))+20,
		"\nRESULT:",
		"rgb("+
			Math.round(Math.min( 230/(1+Math.pow(6,-36/30*(h- dateToNumber(5,45) )))+10, 230-(230/(1+Math.pow(6,-36/30*(h- dateToNumber(19,25) ))))+10 ))+","+
			Math.round(Math.min( 230/(1+Math.pow(6,-36/30*(h- dateToNumber(6,15) )))+10, 230-(230/(1+Math.pow(6,-36/30*(h- dateToNumber(18,55) ))))+10 ))+","+
			Math.round(Math.min( 230/(1+Math.pow(6,-36/30*(h- dateToNumber(6,15) )))+20, 230-(230/(1+Math.pow(6,-36/30*(h- dateToNumber(18,55) ))))+20 ))+
		")"
	);*/
}, 5*1000); // 5s/次


/**
* stats
*/
let stats = new Stats();
stats.showPanel(0);
document.body.appendChild(stats.dom);


/**
* 玩家(deskgood)
*/
function ray(start, end, near, far){
	if (start.x === undefined) start.x = deskgood.pos.x;
	if (start.y === undefined) start.y = deskgood.pos.y;
	if (start.z === undefined) start.z = deskgood.pos.z;
	if (end.x === undefined) end.x = 0;
	if (end.y === undefined) end.y = 0;
	if (end.z === undefined) end.z = 0;
	/* if (!end.y)
		console.log("ray", start, end,far) */
	
	let ray = new THREE.Raycaster(
		new THREE.Vector3(start.x, start.y, start.z),
		new THREE.Vector3(end.x, end.y, end.z),
		near,
		far
	);
	ray.camera = camera;
	let objs = ray.intersectObjects(scene.children);
	return objs.filter(obj => obj.faceIndex !== null); //过滤
}

var deskgood = {
	v: {
		x: 0,
		y: 0,
		z: 0
	},
	pos: camera.position,
	/*size: {
		"x+": 50,
		"x-": 50,
		"y+": 50,
		"y-": 150,
		"z+": 50,
		"z-": 50
	},*/
	jump_v: 5,
	up: camera.up,
	lookAt: {
		left_right: 0,
		top_bottom: -10,
		/* _left_right: 0,
		_top_bottom: -10,
		get left_right(){
			return this._left_right;
		},
		set left_right(value){
			this._left_right = value;
			deskgood.look_refresh();
		},
		get top_bottom(){
			return this._top_bottom;
		},
		set top_bottom(value){
			this._top_bottom = value;
			deskgood.look_refresh();
		} */
	},
	look: {
		x: 1,
		y: 0,
		z: 0
	},
	tools: [0,0,0,0],
	choice: 0,
	sensitivity: 1, //灵敏度
	tools_choice_refresh(){
		for (let i in deskgood.tools){
			$("#tools > img:eq("+i+")")
				.css("borderColor", (i==deskgood.choice)?"#fff":"#aaa")
				.css("borderWidth", (i==deskgood.choice)?"6px":"3px");
		}
	},
	tools_things_refresh(){
		for (let i in deskgood.tools)
			$("#tools > img")[i].src =
				deskgood.tools[i] == 0?
					"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8/AwAI/AL+eMSysAAAAABJRU5ErkJggg==" //透明图片
				:
					"./img/blocks/"+
					deskgood.tools[i]+
					"/"+
					template[ deskgood.tools[i] ].block.face[0]
			;
	},
	look_refresh(x,y,z){
		if (x != undefined | y != undefined | z != undefined){
			[x,y,z] = [x||deskgood.look.x, y||deskgood.look.y, z||deskgood.look.z];
			let v = new THREE.Vector3(x,y,z).setLength(1); //单位向量（标准化）
			camera.lookAt(deskgood.pos.x+v.x, deskgood.pos.y+v.y, deskgood.pos.z+v.z);
			[deskgood.look.x, deskgood.look.y, deskgood.look.z] = [v.x, v.y, v.z];
		}else{
			let x =
				Math.cos(deskgood.lookAt.left_right/180*Math.PI)*
				Math.cos(deskgood.lookAt.top_bottom/180*Math.PI)
			;
			let z =
				Math.sin(deskgood.lookAt.left_right/180*Math.PI)*
				Math.cos(deskgood.lookAt.top_bottom/180*Math.PI)
			;
			let y = Math.sin(deskgood.lookAt.top_bottom/180*Math.PI);
			camera.lookAt(deskgood.pos.x+x, deskgood.pos.y+y, deskgood.pos.z+z);
			[deskgood.look.x, deskgood.look.y, deskgood.look.z] = [x,y,z];
		}
	},
	move (x=deskgood.pos.x, y=deskgood.pos.y, z=deskgood.pos.z){
		[x, z] = [x, z].map(
			value => value+(0.1*Math.random()-0.05)
		); //随机化
		
		try{
			if (
				map.map[Math.round(x/100)]
					[Math.round(y/100)]
					[Math.round(z/100)]
				!== undefined
				&&
				map.activeBlock.some((item, index, value)=>{
					return item[0] == Math.round(x/100/map.size.x) &&
						item[1] == Math.round(z/100/map.size.z);
				}) //含有
			){
				[deskgood.pos.x, deskgood.pos.y, deskgood.pos.z] = [x,y,z];
			}else{
				throw "";
			}
		}catch(err){
			/* 未加载区块，禁止进入 */
		}
	},
	go (x=0, y=0, z=0){
		[x, y, z] = [x, y, z].map(
			value => value*(Math.random()*0.2+0.9)
		); //随机化
		
		let rt = [0,0,0]; //返回值
		//X
		if (x > 0){
			//上半身
			let objs = ray(
				{x: deskgood.pos.x-50},
				{x: 1},
				0,
				x+60
			);
			if (objs.length){ //被阻挡
				let fx = Math.min(...objs.map(v => v.point.x))-10; //获取碰撞点，计算移动位置
				rt[0] = fx-(deskgood.pos.x+x);
				deskgood.moveX(fx);
				console.log("x+ 上 碰撞",x, objs, objs.map(v => v.object.position), objs.map(v => v.point.x), fx, rt[0])
			}else{ //无阻挡
				deskgood.moveX(deskgood.pos.x+x);
			}
			//下半身
			objs = ray(
				{x: deskgood.pos.x-50, y: deskgood.pos.y-100},
				{x: 1},
				0,
				x+60
			);
			if (objs.length){ //被阻挡
				let fx = Math.min(...objs.map(v => v.point.x))-10; //获取碰撞点，计算移动位置
				rt[0] = fx-(deskgood.pos.x+x);
				deskgood.moveX(fx);
				console.log("x+ 下 碰撞",x, objs, objs.map(v => v.object.position), objs.map(v => v.point.x), fx, rt[0])
			}else{ //无阻挡
				deskgood.moveX(deskgood.pos.x+x);
			}
		}else if (x < 0){
			//上半身
			let objs = ray(
				{x: deskgood.pos.x+50},
				{x: -1},
				0,
				-x+60
			);
			if (objs.length){ //被阻挡
				let fx = Math.max(...objs.map(v => v.point.x))+10; //获取碰撞点，计算移动位置
				rt[0] = fx-(deskgood.pos.x+x);
				deskgood.moveX(fx);
				console.log("x- 上 碰撞",x, objs, objs.map(v => v.object.position), objs.map(v => v.point.x), fx, rt[0])
			}else{ //无阻挡
				deskgood.moveX(deskgood.pos.x+x);
				// console.log("x- 上 无碰撞",x)
			}
			//下半身
			objs = ray(
				{x: deskgood.pos.x+50, y: deskgood.pos.y-100},
				{x: -1},
				0,
				-x+60
			);
			if (objs.length){ //被阻挡
				let fx = Math.max(...objs.map(v => v.point.x))+10; //获取碰撞点，计算移动位置
				rt[0] = fx-(deskgood.pos.x+x);
				deskgood.moveX(fx);
				console.log("x- 下 碰撞",x, objs, objs.map(v => v.object.position), objs.map(v => v.point.x), fx, rt[0])
			}else{ //无阻挡
				deskgood.moveX(deskgood.pos.x+x);
				// console.log("x- 下 无碰撞",x)
			}
		}
		
		//Y
		if (y > 0){ //上
			let objs = ray(
				{y: deskgood.pos.y+50},
				{y: 1},
				0,
				y
			);
			if (objs.length){ //被阻挡
				/*let fy = Math.min(...ray(
					{y: deskgood.pos.y+50},
					{y: 1}
				).map(v => v.point.y))-50;*/
				let fy = Math.min(...objs.map(v => v.point.y))-50; //获取碰撞点，计算移动位置
				rt[1] = fy-(deskgood.pos.y+y);
				deskgood.moveY(fy);
			}else{ //无阻挡
				deskgood.moveY(deskgood.pos.y+y);
			}
		}else if (y < 0){ //下
			let objs = ray(
				{y: deskgood.pos.y-150},
				{y: -1},
				0,
				-y
			);
			if (objs.length){ //被阻挡
				/*let fy = Math.max(...ray(
					{y: deskgood.pos.y-150},
					{y: -1}
				).map(v => v.point.y))+150;*/
				let fy = Math.max(...objs.map(v => v.point.y))+150; //获取碰撞点，计算移动位置
				rt[1] = fy-(deskgood.pos.y+y);
				deskgood.moveY(fy);
			}else{ //无阻挡
				deskgood.moveY(deskgood.pos.y+y);
			}
		}
		
		//z
		if (z > 0){
			//上半身
			let objs = ray(
				{z: deskgood.pos.z-50},
				{z: 1},
				0,
				z+60
			);
			if (objs.length){ //被阻挡
				let fz = Math.min(...objs.map(v => v.point.z))-10; //获取碰撞点，计算移动位置
				rt[2] = fz-(deskgood.pos.z+z);
				deskgood.moveZ(fz);
				console.log("z+ 上 碰撞",z, objs, objs.map(v => v.object.position), objs.map(v => v.point.z), fz, rt[2])
			}else{ //无阻挡
				deskgood.moveZ(deskgood.pos.z+z);
			}
			//下半身
			objs = ray(
				{z: deskgood.pos.z-50, y: deskgood.pos.y-100},
				{z: 1},
				0,
				z+60
			);
			if (objs.length){ //被阻挡
				let fz = Math.min(...objs.map(v => v.point.z))-10; //获取碰撞点，计算移动位置
				rt[2] = fz-(deskgood.pos.z+z);
				deskgood.moveZ(fz);
				console.log("z+ 下 碰撞",z, objs, objs.map(v => v.object.position), objs.map(v => v.point.z), fz, rt[2])
			}else{ //无阻挡
				deskgood.moveZ(deskgood.pos.z+z);
			}
		}else if (z < 0){
			//上半身
			let objs = ray(
				{z: deskgood.pos.z+50},
				{z: -1},
				0,
				-z+60
			);
			if (objs.length){ //被阻挡
				let fz = Math.max(...objs.map(v => v.point.z))+10; //获取碰撞点，计算移动位置
				rt[2] = fz-(deskgood.pos.z+z);
				deskgood.moveZ(fz);
				console.log("z- 上 碰撞",z, objs, objs.map(v => v.object.position), objs.map(v => v.point.z), fz, rt[2])
			}else{ //无阻挡
				deskgood.moveZ(deskgood.pos.z+z);
				// console.log("z- 上 无碰撞",z)
			}
			//下半身
			objs = ray(
				{z: deskgood.pos.z+50, y: deskgood.pos.y-100},
				{z: -1},
				0,
				-z+60
			);
			if (objs.length){ //被阻挡
				let fz = Math.max(...objs.map(v => v.point.z))+10; //获取碰撞点，计算移动位置
				rt[2] = fz-(deskgood.pos.z+z);
				deskgood.moveZ(fz);
				console.log("z- 下 碰撞",z, objs, objs.map(v => v.object.position), objs.map(v => v.point.z), fz, rt[2])
			}else{ //无阻挡
				deskgood.moveZ(deskgood.pos.z+z);
				// console.log("z- 下 无碰撞",z)
			}
		}
		
		let block = [];
		block.push([
			Math.round(deskgood.pos.x/100/map.size.x),
			Math.round(deskgood.pos.z/100/map.size.z)
		]);
		block.push([
			Math.round((deskgood.pos.x+300)/100/map.size.x),
			Math.round(deskgood.pos.z/100/map.size.z)
		]);
		block.push([
			Math.round((deskgood.pos.x-300)/100/map.size.x),
			Math.round(deskgood.pos.z/100/map.size.z)
		]);
		block.push([
			Math.round(deskgood.pos.x/100/map.size.x),
			Math.round((deskgood.pos.z+300)/100/map.size.z)
		]);
		block.push([
			Math.round(deskgood.pos.x/100/map.size.x),
			Math.round((deskgood.pos.z-300)/100/map.size.z)
		]);
		block.push([
			Math.round((deskgood.pos.x+300)/100/map.size.x),
			Math.round((deskgood.pos.z+300)/100/map.size.z)
		]);
		block.push([
			Math.round((deskgood.pos.x+300)/100/map.size.x),
			Math.round((deskgood.pos.z-300)/100/map.size.z)
		]);
		block.push([
			Math.round((deskgood.pos.x-300)/100/map.size.x),
			Math.round((deskgood.pos.z+300)/100/map.size.z)
		]);
		block.push([
			Math.round((deskgood.pos.x-300)/100/map.size.x),
			Math.round((deskgood.pos.z-300)/100/map.size.z)
		]);
		//////////////////////////////////////////////////////block[0]
		if (map.activeBlock.every(function(value, index, arr){
			return value[0] != block[0][0] || value[1] != block[0][1];
		})){ //每个都不一样（不存在）
			map.initBlock(...block[0]);
			map.loadBlockAsync(...block[0], function(){
				map.updateBlockAsync(...block[0]); //更新区块
			}); //用噪声填充区块
		//////////////////////////////////////////////////////block[1]
		}else if (map.activeBlock.every(function(value, index, arr){
			return value[0] != block[1][0] || value[1] != block[1][1];
		})){
			map.initBlock(...block[1]);
			map.loadBlockAsync(...block[1], function(){
				map.updateBlockAsync(...block[1]); //更新区块
			}); //用噪声填充区块
		//////////////////////////////////////////////////////block[2]
		}else if (map.activeBlock.every(function(value, index, arr){
			return value[0] != block[2][0] || value[1] != block[2][1];
		})){
			map.initBlock(...block[2]);
			map.loadBlockAsync(...block[2], function(){
				map.updateBlockAsync(...block[2]); //更新区块
			}); //用噪声填充区块
		//////////////////////////////////////////////////////block[3]
		}else if (map.activeBlock.every(function(value, index, arr){
			return value[0] != block[3][0] || value[1] != block[3][1];
		})){
			map.initBlock(...block[3]);
			map.loadBlockAsync(...block[3], function(){
				map.updateBlockAsync(...block[3]); //更新区块
			}); //用噪声填充区块
		//////////////////////////////////////////////////////block[4]
		}else if (map.activeBlock.every(function(value, index, arr){
			return value[0] != block[4][0] || value[1] != block[4][1];
		})){
			map.initBlock(...block[4]);
			map.loadBlockAsync(...block[4], function(){
				map.updateBlockAsync(...block[4]); //更新区块
			}); //用噪声填充区块
		//////////////////////////////////////////////////////block[5]
		}else if (map.activeBlock.every(function(value, index, arr){
			return value[0] != block[5][0] || value[1] != block[5][1];
		})){
			map.initBlock(...block[5]);
			map.loadBlockAsync(...block[5], function(){
				map.updateBlockAsync(...block[5]); //更新区块
			}); //用噪声填充区块
		//////////////////////////////////////////////////////block[6]
		}else if (map.activeBlock.every(function(value, index, arr){
			return value[0] != block[6][0] || value[1] != block[6][1];
		})){
			map.initBlock(...block[6]);
			map.loadBlockAsync(...block[6], function(){
				map.updateBlockAsync(...block[6]); //更新区块
			}); //用噪声填充区块
		//////////////////////////////////////////////////////block[7]
		}else if (map.activeBlock.every(function(value, index, arr){
			return value[0] != block[7][0] || value[1] != block[7][1];
		})){
			map.initBlock(...block[7]);
			map.loadBlockAsync(...block[7], function(){
				map.updateBlockAsync(...block[7]); //更新区块
			}); //用噪声填充区块
		//////////////////////////////////////////////////////block[8]
		}else if (map.activeBlock.every(function(value, index, arr){
			return value[0] != block[8][0] || value[1] != block[8][1];
		})){
			map.initBlock(...block[8]);
			map.loadBlockAsync(...block[8], function(){
				map.updateBlockAsync(...block[8]); //更新区块
			}); //用噪声填充区块
		}
		
		for (let i of map.activeBlock)
			if (
				(i[0] != 0 || i[1] != 0)&&
				block.every((value, index, arr)=>{
					return i[0] != value[0] || i[1] != value[1];
				}) //不与block任何相等
			)
				map.unloadBlockAsync(...i); //卸载区块
		
		return rt;
		
		/*if (x & z)
			console.log(x,y,z);
		
		let rt = [false, false, false];
		//x
		if (x > 0){ //向前
			for (var i=deskgood.pos.x; i<=deskgood.pos.x+x; i+=dx){
				if (map.get(i/100,
						deskgood.pos.y/100,
						deskgood.pos.z/100)
					!=
						null
				){
					rt[0] = true;
					console.log("撞到脸，s:"+((deskgood.pos.x+x)-i));
					break;
				}
				if (map.get((i+10)/100,
						deskgood.pos.y/100-1,
						deskgood.pos.z/100)
					!=
						null
				){
					rt[0] = true;
					console.log("撞到脚，s:"+((deskgood.pos.x+x)-i));
					break;
				}
			}
			deskgood.pos.x = i;
		}else if (x < 0){ //向后
			for (var i=deskgood.pos.x; i>=deskgood.pos.x+x; i-=dx){
				if (map.get((i-10)/100,
						deskgood.pos.y/100,
						deskgood.pos.z/100)
					!=
						null
				){
					rt[0] = true;
					console.log("撞到后脑，s:"+(i-(deskgood.pos.x+x)));
					break;
				}
				if (map.get((i-10)/100,
						deskgood.pos.y/100-1,
						deskgood.pos.z/100)
					!=
						null
				){
					rt[0] = true;
					console.log("撞到脚，s:"+(i-(deskgood.pos.x+x)));
					break;
				}
			}
			deskgood.pos.x = i;
		}
		//y
		if (y > 0){ //向上
			for (var j=deskgood.pos.y; j<=deskgood.pos.y+y; j+=dy){
				if (map.get(deskgood.pos.x/100,
						j/100,
						deskgood.pos.z/100)
					!=
						null
				){
					rt[1] = true;
					let s = (deskgood.pos.y-150+y)-j;
					if (s)
						console.log("撞到天花板，s:", s);
					break;
				}
			}
			deskgood.pos.y = j;
		}else if (y < 0){ //向下
			for (var j=deskgood.pos.y-150; j>=deskgood.pos.y-150+y; j-=dy){
				if (map.get(deskgood.pos.x/100,
						j/100,
						deskgood.pos.z/100)
					!=
						null
				){
					rt[1] = true;
					let s = j-(deskgood.pos.y-150+y);
					if (s)
						// console.log("撞到地面，s:", s);
					break;
				}
			}
			deskgood.pos.y = j+150;
		}
		
		//z
		if (z > 0){ //向右
			for (var k=deskgood.pos.z; k<=deskgood.pos.z+z; k+=dz){
				if (map.get((k+10)/100,
						deskgood.pos.y/100,
						deskgood.pos.z/100)
					!=
						null
				){
					rt[2] = true;
					console.log("撞到头，s:"+((deskgood.pos.z+z)-i));
					break;
				}
				if (map.get((k+10)/100,
						deskgood.pos.y/100-1,
						deskgood.pos.z/100)
					!=
						null
				){
					rt[2] = true;
					debugger
					console.log("撞到腿，s:"+((deskgood.pos.z+z)-k));
					break;
				}
			}
			deskgood.pos.z = k;
		}else if (z < 0){ //向左
			for (var k=deskgood.pos.z; k>=deskgood.pos.z+z; k-=dz){
				if (map.get((k-10)/100,
						deskgood.pos.y/100,
						deskgood.pos.z/100)
					!=
						null
				){
					rt[2] = true;
					console.log("撞到头，s:"+(k-(deskgood.pos.z+z)));
					break;
				}
				if (map.get((k-10)/100,
						deskgood.pos.y/100-1,
						deskgood.pos.z/100)
					!=
						null
				){
					rt[2] = true;
					console.log("撞到腿，s:"+(k-(deskgood.pos.z+z)));
					break;
				}
			}
			deskgood.pos.z = k;
		}
		return rt;*/
	}
}
deskgood.moveTo = deskgood.move;
deskgood.moveX = x=>deskgood.move(x);
deskgood.moveY = y=>deskgood.move(undefined, y);
deskgood.moveZ = z=>deskgood.move(undefined, undefined, z);
deskgood.goX = x=>deskgood.go(x);
deskgood.goY = y=>deskgood.go(0,y);
deskgood.goZ = z=>deskgood.go(0,0,z);

//读取
if (localStorage.getItem("我的世界.存档.玩家.位置")){
	deskgood.pos.x = JSON.parse(localStorage.getItem("我的世界.存档.玩家.位置")).x;
	deskgood.pos.y = JSON.parse(localStorage.getItem("我的世界.存档.玩家.位置")).y;
	deskgood.pos.z = JSON.parse(localStorage.getItem("我的世界.存档.玩家.位置")).z;
}
if (localStorage.getItem("我的世界.存档.玩家.朝向")){
	deskgood.lookAt.left_right = JSON.parse(localStorage.getItem("我的世界.存档.玩家.朝向")).left_right;
	deskgood.lookAt.top_bottom = JSON.parse(localStorage.getItem("我的世界.存档.玩家.朝向")).top_bottom;
}
if (localStorage.getItem("我的世界.存档.玩家.物品.工具栏")){
	deskgood.tools = JSON.parse(localStorage.getItem("我的世界.存档.玩家.物品.工具栏")).tools;
	deskgood.choice = Number(JSON.parse(localStorage.getItem("我的世界.存档.玩家.物品.工具栏")).choice);
}

for (let i in deskgood.tools){
	/* if (deskgood.tools[i] != 0){
		$("#tools > img")[i].src = "./img/blocks/"+deskgood.tools[i]+"/"+template[deskgood.tools[i]].face[0];
	} */
	$("#tools > img")[i].onclick = ()=>{
		deskgood.choice = i;
		deskgood.tools_choice_refresh();
	};
}

//初始化
deskgood.tools_choice_refresh();
deskgood.tools_things_refresh();
deskgood.look_refresh();

//gui
let deskgood_folder = gui.addFolder("玩家/观察者(deskgood)");
deskgood_folder.open();
	deskgood_folder.add(window, "stop").listen();
	deskgood_folder.add(deskgood, "sensitivity", 0.1, 10).name("灵敏度");
	deskgood_folder.add(deskgood, "jump_v", 1, 10).name("跳跃速度");
	let deskgood_position_folder = deskgood_folder.addFolder("位置/px");
	deskgood_position_folder.open();
		deskgood_position_folder.add(deskgood.pos, "x", -1000, 1000, 0.01).listen();
		deskgood_position_folder.add(deskgood.pos, "y", -1000, 2000, 0.01).listen();
		deskgood_position_folder.add(deskgood.pos, "z", -1000, 1000, 0.01).listen();
	let deskgood_v_folder = deskgood_folder.addFolder("速度/(m/s)");
		deskgood_v_folder.add(deskgood.v, "x", -10, 10, 1e-3).listen();
		deskgood_v_folder.add(deskgood.v, "y", -100, 100, 1e-3).listen().onChange((value) => {
			deskgood.v.y = Math.pow(Math.abs(value)/100,3)*100*value/Math.abs(value);
		});
		deskgood_v_folder.add(deskgood.v, "z", -10, 10, 1e-3).listen();
	let deskgood_lookAt_folder = deskgood_folder.addFolder("朝向（球坐标系）");
		deskgood_lookAt_folder.add(deskgood.lookAt, "left_right", 0, 360).listen().name("左右（水平）");
		deskgood_lookAt_folder.add(deskgood.lookAt, "top_bottom", -90, 90).listen().name("上下（竖直）");
	let deskgood_look_folder = deskgood_folder.addFolder("朝向（笛卡尔坐标系）");
		deskgood_look_folder.add(deskgood.look, "x", -1, 1, 0.01).listen().onChange(x => deskgood.look_refresh(x));
		deskgood_look_folder.add(deskgood.look, "y", -1, 1, 0.01).listen().onChange(y => deskgood.look_refresh(undefined, y));
		deskgood_look_folder.add(deskgood.look, "z", -1, 1, 0.01).listen().onChange(z => deskgood.look_refresh(undefined, undefined, z));
	let deskgood_up_folder = deskgood_folder.addFolder("天旋地转（小心头晕）");
		deskgood_up_folder.add(deskgood.up, "x", -1, 1, 0.01).onChange(function(){
			message("<font size=\"16\">头晕别怪我</font>", "short", 3000);
			/* plus.nativeUI.toast(
				"<font size=\"16\">头晕别怪我</font>",
				{
					type: "richtext",
					verticalAlign: "top",
					richTextStyle: {align:"center"}
				}
			); }catch(err){} */
		});
		deskgood_up_folder.add(deskgood.up, "y", -1, 1, 0.01).onChange(function(){
			message("<font size=\"16\">头晕别怪我</font>", "short", 3000);
				/* plus.nativeUI.toast(
					"<font size=\"16\">头晕别怪我</font>",
					{
						type: "richtext",
						verticalAlign: "top",
						richTextStyle: {align:"center"}
					}
				); }catch(err){} */
			});
		deskgood_up_folder.add(deskgood.up, "z", -1, 1, 0.01).onChange(function(){
			message("<font size=\"16\">头晕别怪我</font>", "short", 3000);
				/* plus.nativeUI.toast(
					"<font size=\"16\">头晕别怪我</font>",
					{
						type: "richtext",
						verticalAlign: "top",
						richTextStyle: {align:"center"}
					}
				); }catch(err){} */
			});
	let deskgood_tools_folder = deskgood_folder.addFolder("工具栏(tools)");
	deskgood_tools_folder.open();
		deskgood_tools_folder.add(deskgood, "choice", 0, 3, 1).listen().name("选择工具").onChange(deskgood.tools_choice_refresh);
		let deskgood_tools_things_folder = deskgood_tools_folder.addFolder("物品");
		deskgood_tools_things_folder.open();
			deskgood_tools_things_folder.add(deskgood.tools, 0, 0, 9, 1).listen().onChange(deskgood.tools_things_refresh);
			deskgood_tools_things_folder.add(deskgood.tools, 1, 0, 9, 1).listen().onChange(deskgood.tools_things_refresh);
			deskgood_tools_things_folder.add(deskgood.tools, 2, 0, 9, 1).listen().onChange(deskgood.tools_things_refresh);
			deskgood_tools_things_folder.add(deskgood.tools, 3, 0, 9, 1).listen().onChange(deskgood.tools_things_refresh);


/* //多线程
let deskgood_worker = null;
if(deskgood_worker == null){
	deskgood_worker = new Worker("./js/deskgood.js");
}
deskgood_worker.postMessage([deskgood.pos, deskgood.v]);
deskgood_worker.onmessage = function(e){
	// deskgood.go(...e.data);
	// deskgood.pos.x = e.data[0].x;
	// deskgood.pos.y = e.data[0].y;
	// deskgood.pos.z = e.data[0].z;
	// deskgood.v.x = e.data[1].x;
	// deskgood.v.y = e.data[1].y;
	// deskgood.v.z = e.data[1].z;
}; */

let T0 = new Date();//上次时间
function render(){
	let t = new Date()-T0;//时间差
	T0 = new Date();//把本次时间赋值给上次时间
	requestAnimationFrame(render);
	renderer.render(scene, camera);//执行渲染操作
	
	let warn = [];
	try{
		if (map.get(deskgood.pos.x/100,
				deskgood.pos.y/100,
				deskgood.pos.z/100)
			!=
				null
		){ //头被卡住
			warn.push("头被卡住？");
			message("<font size=\"16\">想窒息吗？还往头上放方块，看你怎么出来！</font>", "short", 0);
			/* try{
				plus.nativeUI.toast(
					"<font size=\"16\">想窒息吗？还往头上放方块，看你怎么出来！</font>",
					{
						type:"richtext",
						verticalAlign: "top",
						richTextStyle:{align:"center"}
					}
				);
			}catch(err){} */
			setTimeout(function(){
				try{ plus.nativeUI.closeToast(); }catch(err){}
			},1);
		}
		if (map.get(deskgood.pos.x/100,
				deskgood.pos.y/100-1,
				deskgood.pos.z/100)
			!=
				null
		){ //脚被卡住
			warn.push("脚被卡住？");
		}
	}catch(err){}
	if (warn.length && !stop){
		if (!map.get(deskgood.pos.x/100,
			deskgood.pos.y/100,
			deskgood.pos.z/100
		) &&
		!map.get(deskgood.pos.x/100,
			deskgood.pos.y/100+1,
			deskgood.pos.z/100
		)) deskgood.v.y += deskgood.jump_v*t/1000*6*(Math.random()*0.2+0.9); //自动跳跃
		
		if (warn[0] & warn[1]){
			console.warn(warn[0], warn[1]);
		}else{
			console.warn(warn[0]);
		}
	}
	
	if (!stop){
		let ρ = 1.25*(Math.random()*0.2+0.9), //空气密度/(kg/m³)
			c = 0.4*(Math.random()*0.2+0.9), //空气阻力系数
			s = [0.5, 0.2, 0.5], //面积/m²
			v = [deskgood.v.x, deskgood.v.y, deskgood.v.z], //速度/(m/s)
			Fw = [], //空气阻力/N
			m = 50, //质量/m
			Aw = [] //空气阻力产生的加速度/(m/s²)
		for (let i=0; i<3; i++){
			Fw[i] = (1/2) * c * ρ * s[i] * v[i]*v[i]; //F = (1/2)CρSV²
			Aw[i] = Fw[i] / m; //F=ma => a=F/m
		}
		
		deskgood.v.y -= 9.8*t/1000*(Math.random()*0.2+0.9); //重力加速度
		deskgood.v.x +=
			Math.abs(Aw[0]*t/1000) < Math.abs(deskgood.v.x)?
				Aw[0]*t/1000
			:
				-deskgood.v.x
		;
		deskgood.v.y +=
			Math.abs(Aw[1]*t/1000) < Math.abs(deskgood.v.y)?
				Aw[1]*t/1000
			:
				-deskgood.v.y
		;
		deskgood.v.z +=
			Math.abs(Aw[2]*t/1000) < Math.abs(deskgood.v.z)?
				Aw[2]*t/1000
			:
				-deskgood.v.z
		;
		//console.info("aw:",Aw, "Fw:",Fw, "v:", deskgood.v)
		
		let rt = deskgood.go(deskgood.v.x*100*t/1000, deskgood.v.y*100*t/1000, deskgood.v.z*100*t/1000);
		//					m/s*100*ms/1000 => cm/s*s => cm => px
		if (rt[0]) deskgood.v.x = 0;
		if (rt[1]) deskgood.v.y = 0;
		if (rt[2]) deskgood.v.x = 0;
	}
	
	
	stats.update();
}
// render();
// 间隔30ms周期性调用函数fun
//setInterval("render()",16.7)

/* let controls = new THREE.OrbitControls(camera,renderer.domElement);//创建控件对象
controls.addEventListener("change", render);//监听鼠标、键盘事件 */

function state(id, pointerLock){
	if ($("#"+id).css("display") != "none"){ //已显示
		$("#"+id).css("display", "none");
		stop = false;
		document.body.requestPointerLock();
		console.log(id, ":close");
	}else{ //未显示
		$("#"+id).css("display", "block");
		stop = id;
		document.exitPointerLock();
		console.log(id, ":open");
	}
	
	return;
}

let keydown = {
	key: new Set(),
	double_run: [],
	t0: null
};
document.addEventListener("keydown", function (e){
	if (e.keyCode == 69){ //E 切换背包
		if (stop == "bag" | stop == false){
			console.log("E:", keydown.key);
			state("bag");
			return false;
		}
	}
	if (e.keyCode == 27 & stop == "command"){ //ESC 退出命令方块
		state("command");
		return false;
	}
	
	if (stop){
		keydown.double_run = [];
		return false;
	}
	
	if (e.keyCode == 27){ //ESC 暂停游戏
		console.log("ESC:", keydown.key);
		
		stop = true;
		$("canvas:eq(0),#mouse").css("cursor", "default");
		save();
		document.exitPointerLock();
		
		return false;
	}
	if (e.keyCode == 121){ //F10 打开gui
		console.log("F10:", keydown.key);
		if (gui.closed){
			gui.open();
		}else{
			gui.close();
		}
		return false;
	}
	if (e.keyCode == 87 | e.keyCode == 38){
		if (keydown.double_run.length == 0){
			keydown.double_run[0] = +new Date();
		}else if (keydown.double_run.length == 2 && +new Date()-keydown.double_run[1] < 500){ //连按
			keydown.double_run = true;
			console.log("run");
		}
	}
	
	keydown.key.add(e.keyCode);
	
	return false;
});
document.addEventListener("keyup", function (e){
	keydown.key.delete(e.keyCode);
	
	if (e.keyCode == 87 | e.keyCode == 38){
		if (keydown.double_run.length == 1 && +new Date()-keydown.double_run[0] < 500){
			keydown.double_run[1] = +new Date();
		}else{
			keydown.double_run = [];
		}
	}
	return false;
});
let last_jump = +new Date()-1000;
setInterval(function(){
	if (stop){
		keydown.key = new Set();
		keydown.t0 = null;
		return;
	}
	let t;
	if (keydown.t0){
		t = +new Date()-keydown.t0;
		keydown.t0 = +new Date();
	}else{
		keydown.t0 = +new Date();
		return;
	}
	
	let x=0, y=0, z=0;
	
	if (keydown.key.size)
		console.log("keydown:", keydown.key);
	
	if ((keydown.key.has(87) | keydown.key.has(38)) & keydown.key.has(17)){ //control 按下
		keydown.double_run = true;
		console.log("run");
	}
	
	if (keydown.key.has(87) | keydown.key.has(38)){ //前
		console.log("front:", keydown.key);
		x += Math.cos( (deskgood.lookAt.left_right+0) /180*Math.PI) *(keydown.double_run==true?3:1) *(Math.random()*0.2+0.9);
		z += Math.sin( (deskgood.lookAt.left_right+0) /180*Math.PI) *(keydown.double_run==true?3:1) *(Math.random()*0.2+0.9);
	}
	if (keydown.key.has(83) | keydown.key.has(40)){ //后
		console.log("behind:", keydown.key);
		x += Math.cos( (deskgood.lookAt.left_right+180) /180*Math.PI) *(Math.random()*0.2+0.9);
		z += Math.sin( (deskgood.lookAt.left_right+180) /180*Math.PI) *(Math.random()*0.2+0.9);
	}
	if (keydown.key.has(65) | keydown.key.has(37)){ //左
		console.log("left:", keydown.key);
		x += Math.cos( (deskgood.lookAt.left_right-90) /180*Math.PI) *(Math.random()*0.2+0.9);
		z += Math.sin( (deskgood.lookAt.left_right-90) /180*Math.PI) *(Math.random()*0.2+0.9);
	}
	if (keydown.key.has(68) | keydown.key.has(39)){ //右
		console.log("right:", keydown.key);
		x += Math.cos( (deskgood.lookAt.left_right+90) /180*Math.PI) *(Math.random()*0.2+0.9);
		z += Math.sin( (deskgood.lookAt.left_right+90) /180*Math.PI) *(Math.random()*0.2+0.9);
	}
	if (keydown.key.has(32)){ //上
		console.log("up:", keydown.key);
		y += 1*(Math.random()*0.2+0.9);
	}
	if (keydown.key.has(16)){ //下
		console.log("down:", keydown.key);
		y += -1*(Math.random()*0.2+0.9);
	}
	
	/* x = x*10 + (x>0? 10: x<0? -10: 0);
	z = z*10 + (z>0? 10: z<0? -10: 0);
	
	try{
		if (
			map.get((deskgood.pos.x+x)/100,
				deskgood.pos.y/100,
				deskgood.pos.z/100)
			!=
				null
		){ //无法向X移动
			x = 0;
		}
	}catch(err){}
	try{
		if (map.get((deskgood.pos.x+x)/100,
				deskgood.pos.y/100-1,
				deskgood.pos.z/100)
			!=
				null
		){ //无法向X移动
			x = 0;
		}
	}catch(err){}
	
	try{
		if (map.get(deskgood.pos.x/100,
				deskgood.pos.y/100,
				(deskgood.pos.z+z)/100)
			!=
				null
		){ //无法向Z移动
			z = 0;
		}
	}catch(err){}
	try{
		if (map.get(
				deskgood.pos.x/100,
				deskgood.pos.y/100-1,
				(deskgood.pos.z+z)/100)
			!=
				null
		){ //无法向Z移动
			z = 0;
		}
	}catch(err){}
	
	x -= (x>0? 10: x<0? -10: 0);
	z -= (z>0? 10: z<0? -10: 0);
	
	deskgood.pos.x += x*(Math.random()*0.2+0.9);
	deskgood.pos.z += z*(Math.random()*0.2+0.9); */
	
	if (x && z)
		console.log("go",x,z);
	
	if (x || y || z)
		deskgood.go(x*t*0.1, 0, z*t*0.1); // 1m/s = 100px/s = 0.1px/ms
	
	try{
		if (map.get(deskgood.pos.x/100,
				deskgood.pos.y/100-1.6,
				deskgood.pos.z/100)
			!=
				null
		){ //脚下有方块
			if (+new Date()-last_jump >= 1000 & y != 0){
				console.log("jump");
				deskgood.v.y += y * deskgood.jump_v*(Math.random()*0.2+0.9);
				last_jump = +new Date();
			}
		}
	}catch(err){}
}, 16.667);

/* let choice_object = get_choice_object()?get_choice_object()[1]:undefined;

let choice_folder = gui.addFolder("选择物体");
choice_folder.open();
	choice_position_folder = choice_folder.addFolder("位置");
	choice_position_folder.open();
		choice_position_folder.add(choice_object?choice_object.object.position:{x:0,y:0,z:0}, "x", -1000, 1000, 100).listen();
		choice_position_folder.add(choice_object?choice_object.object.position:{x:0,y:0,z:0}, "y", -1000, 1000, 100).listen();
		choice_position_folder.add(choice_object?choice_object.object.position:{x:0,y:0,z:0}, "z", -1000, 1000, 100).listen();
	choice_folder.add(choice_object.faceIndex?choice_object:{faceIndex:-1}, "faceIndex", 0, 12).listen(); */
/* let mouse = {
	x0: null,
	y0: null
}; */

document.addEventListener("mousemove", function (e){
	if (stop)
		return;
	
	if (e.path[0] != document.getElementById("help") & e.path[0] != document.body){
		return;
	}
	
	let dx =
		e.movementX ||
		e.mozMovementX ||
		e.webkitMovementX ||
		0
	;
	let dy =
		e.movementY ||
		e.mozMovementY ||
		e.webkitMovementY ||
		0
	;
	
	// 打印鼠标移动的增量值。
	// console.log("mousemove:", dx, dy);
	/* let [x, y] = [e.pageX, e.pageY];
	console.log("mousemove:", x, y); */
	
	// choice_object = get_choice_object()?get_choice_object()[1]:undefined;
	
	/* if (
		Math.sqrt(Math.pow(dx,2)+Math.pow(dy.y0,2)) <= 100 & //
		mouse.x0 !== null & mouse.y0 !== null
	){ */
		// let [dx, dy] = [x-mouse.x0, y-mouse.y0];
		// [mouse.x0, mouse.y0] = [x, y];
		// console.log("move:", dx, dy);
		deskgood.lookAt.left_right += dx/document.getElementsByTagName("canvas")[0].offsetWidth*360*deskgood.sensitivity;
		deskgood.lookAt.top_bottom -= dy/document.getElementsByTagName("canvas")[0].offsetHeight*360*deskgood.sensitivity;
		
		if (deskgood.lookAt.left_right > 360)
			while (deskgood.lookAt.left_right > 360)
				deskgood.lookAt.left_right -= 360;
		if (deskgood.lookAt.left_right < 0)
			while (deskgood.lookAt.left_right < 0)
				deskgood.lookAt.left_right += 360;
		
		if (deskgood.lookAt.top_bottom > 89.9)
			deskgood.lookAt.top_bottom = 89.9;
		if (deskgood.lookAt.top_bottom < -89.9)
			deskgood.lookAt.top_bottom = -89.9;
		
		deskgood.look_refresh(); //刷新
	// }
	
	// [mouse.x0,mouse.y0] = [x, y];
});

$(document).on("mousewheel DOMMouseScroll", function(event){ //on也可以 bind监听
	if (stop)
		return;
	//Chorme
	let wheel = event.originalEvent.wheelDelta;
	let detal = event.originalEvent.detail;
	let up = function(){
		deskgood.choice --;
		if (deskgood.choice < 0)
			deskgood.choice = 3;
	};
	let down = function(){
		deskgood.choice ++;
		if (deskgood.choice > 3)
			deskgood.choice = 0;
	};
	if (event.originalEvent.wheelDelta){ //判断浏览器IE,谷歌滚轮事件
		if (wheel > 0) { //当滑轮向上滚动时
			console.log("上滚轮");
			up();
			deskgood.tools_choice_refresh();
		}  
		if (wheel < 0) { //当滑轮向下滚动时
			console.log("下滚轮");
			down();
			deskgood.tools_choice_refresh();
		}  
	}else if (event.originalEvent.detail){ //Firefox滚轮事件
		if (detal > 0) { //当滑轮向下滚动时
			console.log("下滚轮");
			down();
			deskgood.tools_choice_refresh();
		}
		if (detal < 0) { //当滑轮向上滚动时
			console.log("上滚轮");
			up();
			deskgood.tools_choice_refresh();
		}
	}  
});

document.addEventListener("mousedown", function (e){
	if (stop)
		return;
	
	if (e.path[0] !== document.body)
		return;
	
	if (e.button == 0){ //左键（删除）
		let click = get_choice_object();
		for (let i in click){
			if (click[i].faceIndex){
				if (click[i].object instanceof THREE.Mesh){
					let x = click[i].object.position.x,
						y = click[i].object.position.y,
						z = click[i].object.position.z;
					if (Math.sqrt(
						Math.pow(x - deskgood.pos.x, 2)+
						Math.pow(y - deskgood.pos.y, 2)+
						Math.pow(z - deskgood.pos.z, 2)
					) < 500){ //距离小于500
						/*let free = -1;
						if (deskgood.tools[deskgood.choice] == 0){
							free = deskgood.choice;
						}else{
							for (let j in deskgood.tools){
								if (deskgood.tools[j] == 0){
									free = j;
									break;
								}
							}
						}*/
						let free = deskgood.tools[deskgood.choice]==0? deskgood.choice: deskgood.tools.indexOf(0);
						if (free == -1){
							console.info("not free!");
							message("<font style=\"font-size:14px\">两只手拿4m³方块已经够多了，反正我是拿不下了</font>", "short", 3000);
						}else{
							console.log("delete:", click[i].object.position);
							deskgood.tools[free] = map.get(x/100, y/100, z/100).id; //放在手中
							deskgood.tools_things_refresh(); //刷新方块
							map.delete(x/100, y/100, z/100); //删除方块
							map.updateRound(x/100, y/100, z/100); //刷新方块及周围
							/*scene.remove(click[i].object);
							every[ click[i].object.position.x/100 ][ click[i].object.position.y/100 ][ click[i].object.position.z/100 ] = 0;*/
							/* if (
								every[ click[i].object.position.x/100+1 ][ click[i].object.position.y/100 ][ click[i].object.position.z/100 ] 
							) */
						}
						break;
					}
				}
			}
		}
	}else if (e.button == 2){ //右键（放置）
		let click = get_choice_object();
		for (let i in click){
			if (click[i].object instanceof THREE.Mesh){
				let x = click[i].object.position.x,
					y = click[i].object.position.y,
					z = click[i].object.position.z;
				if (
					Math.sqrt(
						Math.pow(x - deskgood.pos.x, 2)+
						Math.pow(y - deskgood.pos.y, 2)+
						Math.pow(z - deskgood.pos.z, 2)
				) < 500){ //距离<500
					if (map.get(x/100, y/100, z/100) &&
						map.get(x/100, y/100, z/100).id == 9
					){ //命令方块
						state("command");
						return;
					}
				}
				if (deskgood.tools[deskgood.choice] == 0) //空气
					return;
				switch (click[i].faceIndex){
					case 0:
					case 1:
						x += 100;
						break;
					case 2:
					case 3:
						x -= 100;
						break;
					case 4:
					case 5:
						y += 100;
						break;
					case 6:
					case 7:
						y -= 100;
						break;
					case 8:
					case 9:
						z += 100;
						break;
					case 10:
					case 11:
						z -= 100;
						break;
					default:
						return console.error("faceIndex wrong:", click[i].faceIndex);
				}
				if (Math.sqrt(
					Math.pow(x-deskgood.pos.x, 2)+
					Math.pow(y-deskgood.pos.y, 2)+
					Math.pow(z-deskgood.pos.z, 2)
				) < 500){ //距离<5m
					map.addID(deskgood.tools[deskgood.choice], {
						x: x/100,
						y: y/100,
						z: z/100
					}, template);
					/* map.add(new Thing(template[ deskgood.tools[deskgood.choice] ]).block.makeMaterial().block.deleteTexture().block.makeMesh(), {
						x: x/100,
						y: y/100,
						z: z/100
					}); */
					map.updateRound(x/100, y/100, z/100); //刷新方块及周围
					deskgood.tools[deskgood.choice] = 0; //删除手里的方块
					deskgood.tools_things_refresh(); //刷新方块
					break; //跳出 寻找有效放置的 循环
				}
				/*if (click[i].faceIndex == 0 | click[i].faceIndex == 1){
					x += 100;
					if (Math.sqrt(
						Math.pow((click[i].object.position.x+100) - deskgood.pos.x, 2)+
						Math.pow(click[i].object.position.y - deskgood.pos.y, 2)+
						Math.pow(click[i].object.position.z - deskgood.pos.z, 2)
					) < 500){ //距离<500
						let thing = new Thing(template[ deskgood.tools[deskgood.choice] ]);
						thing.block.makeMesh();
						let mesh = new THREE.Mesh(block_geometry, template[ deskgood.tools[deskgood.choice] ].material);
						mesh.position.x = click[i].object.position.x+100;
						mesh.position.y = click[i].object.position.y;
						mesh.position.z = click[i].object.position.z;
						
						mesh.castShadow = true;
						mesh.receiveShadow = true;
						
						scene.add(mesh); //网格模型添加到场景中
						every[ click[i].object.position.x/100+1 ][ click[i].object.position.y/100 ][ click[i].object.position.z/100 ] = deskgood.tools[deskgood.choice];
						deskgood.tools[deskgood.choice] = 0; //删除手里的方块
						deskgood.tools_things_refresh(); //刷新方块
						break;
					}
				}else if (click[i].faceIndex == 2 | click[i].faceIndex == 3){
					x -= 100;
					if (Math.sqrt(
						Math.pow((click[i].object.position.x-100) - deskgood.pos.x, 2)+
						Math.pow(click[i].object.position.y - deskgood.pos.y, 2)+
						Math.pow(click[i].object.position.z - deskgood.pos.z, 2)
					) < 500){ //距离<500
						let mesh = new THREE.Mesh(block_geometry, template[ deskgood.tools[deskgood.choice]].material);
						mesh.position.x = click[i].object.position.x-100;
						mesh.position.y = click[i].object.position.y;
						mesh.position.z = click[i].object.position.z;
						
						mesh.castShadow = true;
						mesh.receiveShadow = true;
						
						scene.add(mesh); //网格模型添加到场景中
						every[ click[i].object.position.x/100-1 ][ click[i].object.position.y/100 ][ click[i].object.position.z/100 ] = deskgood.tools[deskgood.choice];
						deskgood.tools[deskgood.choice] = 0; //删除手里的方块
						deskgood.tools_things_refresh(); //刷新方块
						break;
					}
				}else if (click[i].faceIndex == 4 | click[i].faceIndex == 5){
					if (Math.sqrt(
						Math.pow(click[i].object.position.x - deskgood.pos.x, 2)+
					 	Math.pow((click[i].object.position.y+100) - deskgood.pos.y, 2)+
						Math.pow(click[i].object.position.z - deskgood.pos.z, 2)
					) < 500){ //距离<500
						let mesh = new THREE.Mesh(block_geometry, template[ deskgood.tools[deskgood.choice]].material);
						mesh.position.x = click[i].object.position.x;
						mesh.position.y = click[i].object.position.y+100;
						mesh.position.z = click[i].object.position.z;
						
						mesh.castShadow = true;
						mesh.receiveShadow = true;
						
						scene.add(mesh); //网格模型添加到场景中
						every[ click[i].object.position.x/100 ][ click[i].object.position.y/100+1 ][ click[i].object.position.z/100 ] = deskgood.tools[deskgood.choice];
						deskgood.tools[deskgood.choice] = 0; //删除手里的方块
						deskgood.tools_things_refresh(); //刷新方块
						break;
					}
				}else if (click[i].faceIndex == 6 | click[i].faceIndex == 7){
					if (Math.sqrt(
						Math.pow(click[i].object.position.x - deskgood.pos.x, 2)+
						Math.pow((click[i].object.position.y-100) - deskgood.pos.y, 2)+
						Math.pow(click[i].object.position.z - deskgood.pos.z, 2)
					) < 500){ //距离<500
						let mesh = new THREE.Mesh(block_geometry, template[ deskgood.tools[deskgood.choice]].material);
						mesh.position.x = click[i].object.position.x;
						mesh.position.y = click[i].object.position.y-100;
						mesh.position.z = click[i].object.position.z;
						
						mesh.castShadow = true;
						mesh.receiveShadow = true;
						
						scene.add(mesh); //网格模型添加到场景中
						every[ click[i].object.position.x/100 ][ click[i].object.position.y/100-1 ][ click[i].object.position.z/100 ] = deskgood.tools[deskgood.choice];
						deskgood.tools[deskgood.choice] = 0; //删除手里的方块
						deskgood.tools_things_refresh(); //刷新方块
						break;
					}
				}else if (click[i].faceIndex == 8 | click[i].faceIndex == 9){
					if (Math.sqrt(
						Math.pow(click[i].object.position.x - deskgood.pos.x, 2)+
						Math.pow(click[i].object.position.y - deskgood.pos.y, 2)+
						Math.pow((click[i].object.position.z+100) - deskgood.pos.z, 2)
					) < 500){ //距离<500
						let mesh = new THREE.Mesh(block_geometry, template[ deskgood.tools[deskgood.choice]].material);
						mesh.position.x = click[i].object.position.x;
						mesh.position.y = click[i].object.position.y;
						mesh.position.z = click[i].object.position.z+100;
						
						mesh.castShadow = true;
						mesh.receiveShadow = true;
						
						scene.add(mesh); //网格模型添加到场景中
						every[ click[i].object.position.x/100 ][ click[i].object.position.y/100 ][ click[i].object.position.z/100+1 ] = deskgood.tools[deskgood.choice];
						deskgood.tools[deskgood.choice] = 0; //删除手里的方块
						deskgood.tools_things_refresh(); //刷新方块
						break;
					}
				}else if (click[i].faceIndex == 10 | click[i].faceIndex == 11){
					if (Math.sqrt(
						Math.pow(click[i].object.position.x - deskgood.pos.x, 2)+
						Math.pow(click[i].object.position.y - deskgood.pos.y, 2)+
						Math.pow((click[i].object.position.z-100) - deskgood.pos.z, 2)
					) < 500){ //距离<500
						let mesh = new THREE.Mesh(block_geometry, template[ deskgood.tools[deskgood.choice]].material);
						mesh.position.x = click[i].object.position.x;
						mesh.position.y = click[i].object.position.y;
						mesh.position.z = click[i].object.position.z-100;
						
						mesh.castShadow = true;
						mesh.receiveShadow = true;
						
						scene.add(mesh); //网格模型添加到场景中
						every[ click[i].object.position.x/100 ][ click[i].object.position.y/100 ][ click[i].object.position.z/100-1 ] = deskgood.tools[deskgood.choice];
						deskgood.tools[deskgood.choice] = 0; //删除手里的方块
						deskgood.tools_things_refresh(); //刷新方块
						break;
					}
				}*/
			}
		}
	}
	return false;
});


/**
* Touch
*/
let touch_control = {
	x0: null,
	y0: null,
	x: null,
	y: null,
	t0: null,
	loop: null
};
$("#control").on("touchstart", function(e){
	if (stop)
		return;
	
	let x = e.originalEvent.targetTouches[0].clientX,
		y = e.originalEvent.targetTouches[0].clientY;
	console.log("touchstart(control):", x, y);
	
	[touch_control.x0, touch_control.y0, touch_control.t0] = [x, y, +new Date()];
	
	touch_control.loop = setInterval(function(){
		if (touch_control.x0 !== null &
			touch_control.y0 !== null &
			touch_control.x !== null &
			touch_control.y !== null
		){
			let t = +new Date()-touch_control.t0;
			touch_control.t0 = +new Date();
			let dx = touch_control.x-touch_control.x0,
				dy = touch_control.y-touch_control.y0;
			let r = (
				dx>0? Math.atan(dy/dx)+Math.PI/2:
				dx<0? Math.atan(dy/dx)-Math.PI/2:
					dy>0? 0:
					dy<0? 180:
					0
			);
			let l = Math.sqrt(
				Math.pow(dx, 2)+
				Math.pow(dy, 2)
			);
			l = l>100? 0.26*t: l*t/866;
			let x = Math.cos( deskgood.lookAt.left_right/180*Math.PI+r )*l;
			let z = Math.sin( deskgood.lookAt.left_right/180*Math.PI+r )*l;
			
			console.log("touch control to move:", x, z);
			
			deskgood.go(x, 0, z);
			
			/*x += x>0? 10: x<0? -10: 0;
			z += z>0? 10: z<0? -10: 0;
			
			if (x > 0){
				for (var i=deskgood.pos.x; i<=deskgood.pos.x+x; i+=2){
					try{
						if (
							every
								[Math.round(i/100)]
								[Math.round(deskgood.pos.y/100)]
								[Math.round(deskgood.pos.z/100)]
							!=
								0
						) break;
						if (
							every
								[Math.round(i/100)]
								[Math.round(deskgood.pos.y/100)-1]
								[Math.round(deskgood.pos.z/100)]
							!=
								0
						) break;
					}catch(err){}
				}
			}else{
				for (var i=deskgood.pos.x; i>=deskgood.pos.x+x; i-=2){
					try{
						if (
							every
								[Math.round(i/100)]
								[Math.round(deskgood.pos.y/100)]
								[Math.round(deskgood.pos.z/100)]
							!=
								0
						) break;
						if (
							every
								[Math.round(i/100)]
								[Math.round(deskgood.pos.y/100)-1]
								[Math.round(deskgood.pos.z/100)]
							!=
								0
						) break;
					}catch(err){}
				}
			}
			if (z > 0){
				for (var j=deskgood.pos.z; j<=deskgood.pos.z+z; j+=2){
					try{
						if (
							every
								[Math.round(deskgood.pos.x/100)]
								[Math.round(deskgood.pos.y/100)]
								[Math.round(j/100)]
							!=
								0
						) break;
						if (
							every
								[Math.round(deskgood.pos.x/100)]
								[Math.round(deskgood.pos.y/100)-1]
								[Math.round(j/100)]
							!=
								0
						) break;
					}catch(err){}
				}
			}else{
				for (var j=deskgood.pos.z; j>=deskgood.pos.z+z; j-=2){
					try{
						if (
							every
								[Math.round(deskgood.pos.x/100)]
								[Math.round(deskgood.pos.y/100)]
								[Math.round(j/100)]
							!=
								0
						) break;
						if (
							every
								[Math.round(deskgood.pos.x/100)]
								[Math.round(deskgood.pos.y/100)-1]
								[Math.round(j/100)]
							!=
								0
						) break;
					}catch(err){}
				}
			}
			
			i -= deskgood.pos.x;
			j -= deskgood.pos.z;
			
			i -= i>0? 10: i<0? -10: 0;
			j -= j>0? 10: j<0? -10: 0;
			
			deskgood.pos.x += i*(Math.random()*0.2+0.9);
			deskgood.pos.z += j*(Math.random()*0.2+0.9);*/
		}
	}, 16.667);
	
	return false;
});
$("#control").on("touchmove", function(e){
	if (stop)
		return;
	
	let x = e.originalEvent.targetTouches[0].clientX;
	let y = e.originalEvent.targetTouches[0].clientY;
	console.log("touchmove(control):", x, y);
	
	[touch_control.x, touch_control.y] = [x, y];
	
	return false;
});
$("#control").on("touchend", function(e){
	let x = e.originalEvent.changedTouches[0].clientX,
		y = e.originalEvent.changedTouches[0].clientY;
	console.log("touchend(control):", x, y);
	
	clearInterval(touch_control.loop);
	touch_control.x0 = touch_control.y0 = touch_control.x = touch_control.y = touch_control.t0 = touch_control.loop = null;
	
	return false;
});
$("#control").on("touchcancel", function(e){
	let x = e.originalEvent.changedTouches[0].clientX,
		y = e.originalEvent.changedTouches[0].clientY;
	console.log("touchcancel(control):", x, y);
	
	clearInterval(touch_control.loop);
	touch_control.x0 = touch_control.y0 = touch_control.x = touch_control.y = touch_control.t0 = touch_control.loop = null;
	
	return false;
});


$("#jump").on("touchstart", function(){
	if (stop)
		return;
	
	console.log("try jump");
	
	try{
		if (
			map.get(deskgood.pos.x/100,
				deskgood.pos.y/100-2,
				deskgood.pos.z/100)
			!=
				null
		){ //脚下有方块
			if (Number(new Date())-last_jump >= 1000){
				deskgood.v.y += deskgood.jump_v*(Math.random()*0.2+0.9);
				last_jump = Number(new Date());
			}
		}
	}catch(err){}
	
	return false;
});


let touch_screen = {
	t: null,
	pos: {x: null, y: null},
	loop: null
};
$("canvas:eq(0)").on("touchstart", function (e){
	if (stop)
		return;
	
	let x = e.originalEvent.targetTouches[0].pageX;
	let y = e.originalEvent.targetTouches[0].pageY
	console.log("touchstart(screen):", x, y, Number(new Date()));
	
	[x0,y0] = [x, y];
	
	touch_screen.t = new Date();
	touch_screen.pos = {x,y};
	touch_screen.loop = setTimeout(()=>{ //长按（删除）
		touch_screen.loop = null;
		if (Math.sqrt(
			Math.pow(touch_screen.pos.x-x, 2)+
			Math.pow(touch_screen.pos.y-y, 2)
		) < 36){ //误差36px
			let click = get_choice_object(true, x, y);
			for (let i in click){
				if (click[i].faceIndex){
					if (click[i].object instanceof THREE.Mesh){
						let x = click[i].object.position.x,
							y = click[i].object.position.y,
							z = click[i].object.position.z;
						if (Math.sqrt(
							Math.pow(x - deskgood.pos.x, 2)+
							Math.pow(y - deskgood.pos.y, 2)+
							Math.pow(z - deskgood.pos.z, 2)
						) < 500){ //距离小于500
							/*let free = -1;
							if (deskgood.tools[deskgood.choice] == 0){
								free = deskgood.choice;
							}else{
								for (let j in deskgood.tools){
									if (deskgood.tools[j] == 0){
										free = j;
										break;
									}
								}
							}*/
							let free = deskgood.tools[deskgood.choice]==0? deskgood.choice: deskgood.tools.indexOf(0);
							if (free == -1){
								console.info("not free!");
								message("<font style=\"font-size:14px\">两只手拿4m³方块已经够多了，反正我是拿不下了</font>", "short", 3000);
								/* try{
									plus.nativeUI.toast("<font style=\"font-size:14px\">两只手拿4m³方块已经够多了，反正我是拿不下了</font>",
										{
											type:"richtext",
											verticalAlign: "top",
											richTextStyle:{
												align:"center"
											}
										}
									);
								}catch(err){} */
							}else{
								console.log("delete:", click[i].object.position);
								deskgood.tools[free] = map.get(x/100, y/100, z/100).id; //放在手中
								deskgood.tools_things_refresh(); //刷新方块
								map.delete(x/100, y/100, z/100); //删除方块
								map.updateRound(x/100, y/100, z/100); //更新方块
								//scene.remove(click[i].object);
								//every[ click[i].object.position.x/100 ][ click[i].object.position.y/100 ][ click[i].object.position.z/100 ] = 0;
								try{
									plus.device.vibrate(16); //挖掘震动
								}catch(e){ //原生震动
									if("vibrate" in navigator){
										navigator.vibrate(16);
									}
								}
								/* if (
									every[ click[i].object.position.x/100+1 ][ click[i].object.position.y/100 ][ click[i].object.position.z/100 ] 
								) */
							}
							break;
						}
					}
				}
			}
		}
	}, 1000);
	
	return false;
});
$("canvas:eq(0)").on("touchmove", function (e){
	if (stop)
		return false;
	
	if (x0 === null | y0 === null)
		return false;
	
	let x = e.originalEvent.targetTouches[0].pageX;
	let y = e.originalEvent.targetTouches[0].pageY;
	console.log("touchmove:", x, y);
	
	let [dx, dy] = [x-x0, y-y0];
	[x0, y0] = [x, y];
	console.log("move:", dx, dy);
	deskgood.lookAt.left_right += dx/document.getElementsByTagName("canvas")[0].offsetWidth*90*deskgood.sensitivity;
	deskgood.lookAt.top_bottom -= dy/document.getElementsByTagName("canvas")[0].offsetHeight*90*deskgood.sensitivity;
	
	if (deskgood.lookAt.left_right > 360)
		while (deskgood.lookAt.left_right > 360)
			deskgood.lookAt.left_right -= 360;
	if (deskgood.lookAt.left_right < 0)
		while (deskgood.lookAt.left_right < 0)
			deskgood.lookAt.left_right += 360;
	
	if (deskgood.lookAt.top_bottom > 89.9)
		deskgood.lookAt.top_bottom = 89.9;
	if (deskgood.lookAt.top_bottom < -89.9)
		deskgood.lookAt.top_bottom = -89.9;
	
	deskgood.look_refresh(); //刷新
	
	if (Math.sqrt(
		Math.pow(touch_screen.pos.x-x, 2)+
		Math.pow(touch_screen.pos.y-y, 2)
	) >= 100){ //误差100px
		touch_screen.pos.x = -666;
		touch_screen.pos.y = -666;
	}
	return false;
});
$("canvas:eq(0)").on("touchend", function (e){
	if (stop)
		return;
	
	let x = e.originalEvent.changedTouches[0].pageX;
	let y = e.originalEvent.changedTouches[0].pageY;
	//console.log("touchend:", x, y, Number(new Date()));
	
	x0 = null, y0 = null;
	
	if (touch_screen.loop !== null){ //短按（放置）
		clearTimeout(touch_screen.loop);
		touch_screen.loop = null;
		if (Math.sqrt(
			Math.pow(touch_screen.pos.x-x, 2)+
			Math.pow(touch_screen.pos.y-y, 2)
		) < 36){ //误差36px
			let click = get_choice_object(true, x, y);
			for (let i in click){
				if (click[i].object instanceof THREE.Mesh){
					if (
						Math.sqrt(
							Math.pow(click[i].object.position.x - deskgood.pos.x, 2)+
							Math.pow(click[i].object.position.y - deskgood.pos.y, 2)+
							Math.pow(click[i].object.position.z - deskgood.pos.z, 2)
					) < 500){ //距离<500
						if (
							map.get(click[i].object.position.x/100,
								click[i].object.position.y/100,
								click[i].object.position.z/100)
							&&
							map.get(click[i].object.position.x/100,
								click[i].object.position.y/100,
								click[i].object.position.z/100).id
							==
								9
						){ //命令方块
							state("command");
							return;
						}
					}
					if (deskgood.tools[deskgood.choice] == 0) //空气
						return;
					let x = click[i].object.position.x,
						y = click[i].object.position.y,
						z = click[i].object.position.z;
					switch (click[i].faceIndex){
						case 0:
						case 1:
							x += 100;
							break;
						case 2:
						case 3:
							x -= 100;
							break;
						case 4:
						case 5:
							y += 100;
							break;
						case 6:
						case 7:
							y -= 100;
							break;
						case 8:
						case 9:
							z += 100;
							break;
						case 10:
						case 11:
							z -= 100;
							break;
						default:
							return console.error("faceIndex wrong:", click[i].faceIndex);
					}
					if (Math.sqrt(
						Math.pow(x-deskgood.pos.x, 2)+
						Math.pow(y-deskgood.pos.y, 2)+
						Math.pow(z-deskgood.pos.z, 2)
					) < 500){ //距离<5m
						map.addID(deskgood.tools[deskgood.choice], {
							x: x/100,
							y: y/100,
							z: z/100
						}, template);
						/* map.add(new Thing(template[ deskgood.tools[deskgood.choice] ]).block.makeMaterial().block.deleteTexture().block.makeMesh(), {
							x: x/100,
							y: y/100,
							z: z/100
						}); */
						map.updateRound(x/100, y/100, z/100); //更新方块及周围方块
						deskgood.tools[deskgood.choice] = 0; //删除手里的方块
						deskgood.tools_things_refresh(); //刷新方块
						break; //跳出 寻找有效放置的 循环
					}
					/*if (click[i].faceIndex == 0 | click[i].faceIndex == 1){
						if (Math.sqrt(
							Math.pow((click[i].object.position.x+100) - deskgood.pos.x, 2)+
							Math.pow(click[i].object.position.y - deskgood.pos.y, 2)+
							Math.pow(click[i].object.position.z - deskgood.pos.z, 2)
						) < 500){ //距离<50
							let mesh = new THREE.Mesh(block_geometry, template[ deskgood.tools[deskgood.choice]].material);
							mesh.position.x = click[i].object.position.x+100;
							mesh.position.y = click[i].object.position.y;
							mesh.position.z = click[i].object.position.z;
							
							mesh.castShadow = true;
							mesh.receiveShadow = true;
							
							scene.add(mesh); //网格模型添加到场景中
							every[ click[i].object.position.x/100+1 ][ click[i].object.position.y/100 ][ click[i].object.position.z/100 ] = deskgood.tools[deskgood.choice];
							deskgood.tools[deskgood.choice] = 0; //删除手里的方块
							deskgood.tools_things_refresh(); //刷新方块
							break;
						}
					}else if (click[i].faceIndex == 2 | click[i].faceIndex == 3){
						if (Math.sqrt(
							Math.pow((click[i].object.position.x-100) - deskgood.pos.x, 2)+
							Math.pow(click[i].object.position.y - deskgood.pos.y, 2)+
							Math.pow(click[i].object.position.z - deskgood.pos.z, 2)
						) < 500){ //距离<500
							let mesh = new THREE.Mesh(block_geometry, template[ deskgood.tools[deskgood.choice]].material);
							mesh.position.x = click[i].object.position.x-100;
							mesh.position.y = click[i].object.position.y;
							mesh.position.z = click[i].object.position.z;
							
							mesh.castShadow = true;
							mesh.receiveShadow = true;
							
							scene.add(mesh); //网格模型添加到场景中
							every[ click[i].object.position.x/100-1 ][ click[i].object.position.y/100 ][ click[i].object.position.z/100 ] = deskgood.tools[deskgood.choice];
							deskgood.tools[deskgood.choice] = 0; //删除手里的方块
							deskgood.tools_things_refresh(); //刷新方块
							break;
						}
					}else if (click[i].faceIndex == 4 | click[i].faceIndex == 5){
						if (Math.sqrt(
								Math.pow(click[i].object.position.x - deskgood.pos.x, 2)+
						 	Math.pow((click[i].object.position.y+100) - deskgood.pos.y, 2)+
							Math.pow(click[i].object.position.z - deskgood.pos.z, 2)
						) < 500){ //距离<500
							let mesh = new THREE.Mesh(block_geometry, template[ deskgood.tools[deskgood.choice]].material);
							mesh.position.x = click[i].object.position.x;
							mesh.position.y = click[i].object.position.y+100;
							mesh.position.z = click[i].object.position.z;
							
							mesh.castShadow = true;
							mesh.receiveShadow = true;
							
							scene.add(mesh); //网格模型添加到场景中
							every[ click[i].object.position.x/100 ][ click[i].object.position.y/100+1 ][ click[i].object.position.z/100 ] = deskgood.tools[deskgood.choice];
							deskgood.tools[deskgood.choice] = 0; //删除手里的方块
							deskgood.tools_things_refresh(); //刷新方块
							break;
						}
					}else if (click[i].faceIndex == 6 | click[i].faceIndex == 7){
							if (Math.sqrt(
							Math.pow(click[i].object.position.x - deskgood.pos.x, 2)+
							Math.pow((click[i].object.position.y-100) - deskgood.pos.y, 2)+
							Math.pow(click[i].object.position.z - deskgood.pos.z, 2)
						) < 500){ //距离<500
							let mesh = new THREE.Mesh(block_geometry, template[ deskgood.tools[deskgood.choice]].material);
							mesh.position.x = click[i].object.position.x;
							mesh.position.y = click[i].object.position.y-100;
							mesh.position.z = click[i].object.position.z;
							
							mesh.castShadow = true;
							mesh.receiveShadow = true;
							
							scene.add(mesh); //网格模型添加到场景中
							every[ click[i].object.position.x/100 ][ click[i].object.position.y/100-1 ][ click[i].object.position.z/100 ] = deskgood.tools[deskgood.choice];
							deskgood.tools[deskgood.choice] = 0; //删除手里的方块
							deskgood.tools_things_refresh(); //刷新方块
							break;
						}
					}else if (click[i].faceIndex == 8 | click[i].faceIndex == 9){
						if (Math.sqrt(
							Math.pow(click[i].object.position.x - deskgood.pos.x, 2)+
							Math.pow(click[i].object.position.y - deskgood.pos.y, 2)+
							Math.pow((click[i].object.position.z+100) - deskgood.pos.z, 2)
						) < 500){ //距离<500
							let mesh = new THREE.Mesh(block_geometry, template[ deskgood.tools[deskgood.choice]].material);
							mesh.position.x = click[i].object.position.x;
							mesh.position.y = click[i].object.position.y;
							mesh.position.z = click[i].object.position.z+100;
							
							mesh.castShadow = true;
							mesh.receiveShadow = true;
							
							scene.add(mesh); //网格模型添加到场景中
							every[ click[i].object.position.x/100 ][ click[i].object.position.y/100 ][ click[i].object.position.z/100+1 ] = deskgood.tools[deskgood.choice];
							deskgood.tools[deskgood.choice] = 0; //删除手里的方块
							deskgood.tools_things_refresh(); //刷新方块
							break;
						}
					}else if (click[i].faceIndex == 10 | click[i].faceIndex == 11){
						if (Math.sqrt(
							Math.pow(click[i].object.position.x - deskgood.pos.x, 2)+
							Math.pow(click[i].object.position.y - deskgood.pos.y, 2)+
							Math.pow((click[i].object.position.z-100) - deskgood.pos.z, 2)
						) < 500){ //距离<500
							let mesh = new THREE.Mesh(block_geometry, template[ deskgood.tools[deskgood.choice]].material);
							mesh.position.x = click[i].object.position.x;
							mesh.position.y = click[i].object.position.y;
							mesh.position.z = click[i].object.position.z-100;
							
							mesh.castShadow = true;
							mesh.receiveShadow = true;
							
							scene.add(mesh); //网格模型添加到场景中
							every[ click[i].object.position.x/100 ][ click[i].object.position.y/100 ][ click[i].object.position.z/100-1 ] = deskgood.tools[deskgood.choice];
							deskgood.tools[deskgood.choice] = 0; //删除手里的方块
							deskgood.tools_things_refresh(); //刷新方块
							break;
						}
					}*/
				}
			}
		}
	}
});
$("canvas:eq(0)").on("touchcancel", function (e){
	if (stop)
		return;
	
	let x = e.originalEvent.changedTouches[0].pageX;
	let y = e.originalEvent.changedTouches[0].pageY;
	console.log("touchcancel:", x, y, Number(new Date()));
	
	x0 = null, y0 = null;
	
	if (touch_screen.loop !== null){ //短按（放置）
		clearTimeout(touch_screen.loop);
	}
});


function get_choice_object(phone, x, y){
	let raycaster = new THREE.Raycaster(); //光线投射，用于确定鼠标点击位置
	let mouse = new THREE.Vector2(); //创建二维平面
	mouse.x = phone? 2*(x/WIDTH)-1: 0;
	mouse.y = phone? -2*(y/HEIGHT)+1: 0;
	//mouse.x = phone? (x/window.innerWidth)*0.9-0.6: 0;
	//mouse.y = phone? (y/window.innerHeight)*1.8-0.6: 0;
	console.log("get:", x, y, mouse.x, mouse.y);
	//以camera为z坐标，确定所点击物体的3D空间位置
	raycaster.setFromCamera(mouse, camera);
	//确定所点击位置上的物体数量
	let intersects = raycaster.intersectObjects(scene.children);
	//选中后进行的操作
	if(intersects.length){
		return intersects;
	}
	return null;
}

//屏蔽鼠标右键
document.oncontextmenu = function (e){
	//var e = e || window.event;
	//e.returnValue = false;
	return false;
};
//屏蔽选择文字
/*document.onselectstart = function (){
	return false;
};*/


setInterval(function(){
	if (deskgood.v.y == Infinity && deskgood.pos.y == Infinity){
		document.body.innerHTML = "";
		document.write(`
<body style="background-color: black; color: white; margin:0; padding:0;">
<h1 style="font-size:16vmin; width:100%; margin:0; text-align:center; position:absolute; top:50%; transform:translateY(-50%);">欢迎来到天堂！<br/>welcome to Infinity.</h1>
		`);
	}else if (deskgood.pos.y < -1800*100){
		document.body.innerHTML = "";
		document.write(`
<body style="background-color: black; color: white; margin:0; padding:0;">
<h1 style="font-size:16vmin; width:100%; margin:0; text-align:center; position:absolute; top:50%; transform:translateY(-50%);">欢迎来到地狱！<br/>welcome to L-18.</h1>
		`);
	}
},1000);

function GetQueryString(name){
	var reg = new RegExp("(^|&)"+ name +"=([^&]*)(&|$)");
	var r = window.location.search.substr(1).match(reg);
	if(r!=null)return  unescape(r[2]); return null;
}

function message(text, time1="long", time2=5000){
	if (typeof plus == "undefined"){
		let msg = $(`<dialog>${text}</dialog>`);
		;
		$(document.body).append(
			msg.attr("open", "true")
				.css("position","absolute")
				.css("top","16vmin")
				.hide()
		);
		msg.fadeIn("slow");
		setTimeout(()=>{
			msg.fadeOut("slow");
		},time2);
	}else{
		plus.nativeUI.toast(
			text,
			{
				type: "richtext",
				duration: time1,
				verticalAlign: "top",
				richTextStyle: {
					align:"center",
				}
			}
		);
	}
}
</script>
	</body>
</html>
