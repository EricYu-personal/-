<!DOCTYPE html>
<!-- Copyright © 2020 by wzh -->
<html lang="zh">
	<head>
		<meta charset="UTF-8" />
		<meta content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport" />
		<title>我的世界</title>
		
		<!--icon-->
		<link rel="icon" href="./img/icon.png" type="image/x-icon"/>
		
		<style>
			/* 我的世界颜色：
			按钮：(116,116,116),
			物品：(140,140,140),
			背景：(199,199,199),
			852*480 => 400*40
			*/
			@font-face{
				font-family:kt; /*楷体*/
				src:url("./fonts/kt.ttf");
			}
			@font-face{
				font-family:hwxk; /*华文楷体*/
				src:url("./fonts/hwxk.ttf");
			}
			@font-face{
				font-family:fzybxskt; /*方正硬笔行书楷体*/
				src:url("./fonts/fzybxskt.ttf");
			}
			@font-face{
				font-family:fzqtjt; /*方正启体简体*/
				src:url("./fonts/fzqtjt.ttf");
			}
			@font-face{
				font-family:qq1; /*QQ*/
				src:url("./fonts/qq1.ttf");
			}
			@font-face{
				font-family:qq2; /*QQ*/
				src:url("./fonts/qq2.ttf");
			}
			@font-face{
				font-family:huawei; /*QQ*/
				src:url("./fonts/huawei.ttf");
			}
			
			::selection {
			    color: #fff;
			    background: #f9cc9d;
			}
			:not(textarea):not(input):not(#__vconsole *){ /* 禁止复制选中 */
				-webkit-touch-callout: none; /* iOS Safari */
				-webkit-user-select: none; /* Chrome/Safari/Opera */
				-khtml-user-select: none; /* Konqueror */
				-moz-user-select: none; /* Firefox */
				-ms-user-select: none; /* Internet Explorer/Edge */
				user-select: none; /* Non-prefixed version, currently not supported by any browser */
			}
			
			body{
				margin: 0;
				overflow: hidden;
				/* 隐藏body窗口区域滚动条 */
			}
			@media not screen and (orientation:portrait){ /* 电脑 */
				#warning{
					display: none;
				}
			}
			h1{
				position: absolute;
				width: 100%;
				height: 100%;
				margin: 0;
				/* font-size: 8.6vmin; */
				font-family: qq1, serif;
				/*padding-top: 20%;*/
				text-align: center;
				
				color: #fff;
				background-color: #000;
				background-image: radial-gradient(#666, #232, #011);
				
				text-shadow:
					0 0 10px rgba(255,0,0, .4),
					0 0 20px rgba(0,0,255, .5),
					0 0 30px rgba(255,255,0, .7),
					
					0 0 10px rgba(255,0,0, .4),
					0 0 20px rgba(0,0,255, .5),
					0 0 30px rgba(255,255,0, .7),
					
					0 0 10px rgba(255,0,0, .4),
					0 0 20px rgba(0,0,255, .5),
					0 0 30px rgba(255,255,0, .7);
			}
			#schedule{
				animation-name: backgroundColor;
				animation-duration: 1s;
				animation-iteration-count: infinite;
			}
			h1::before{
				content: "\a\a";
				white-space: pre;
			}
			h1::after{
				content: "Copyright © 2020 by wzh";
				white-space: pre;
				font-size: 2vmin;
				
				position: absolute;
				bottom: 6vh;
				left: 50%;
				transform: translateX(-50%);
				
				text-shadow: 0.5px 0px 0px #aaa, /*右*/
					-0.5px 0px 0px #ddd, /*左*/
					0px 0.5px 0px #ddd, /*上*/
					0px -0.5px 0px #aaa; /*下*/
			}
			b{
				font-family: fzqtjt, serif;
			}
			span{
				font-family: kt, serif;
			}
			
			@keyframes backgroundColor{
				0%{
					background-image: radial-gradient(#333, #112, #011);
				}
				25%{
					background-image: radial-gradient(#555, #223, #122);
				}
				50%{
					background-image: radial-gradient(#666, #334, #233);
				}
				75%{
					background-image: radial-gradient(#888, #445, #344);
				}
				100%{
					background-image: radial-gradient(#999, #556, #455);
				}
			}
			progress{
				background-color: red;
				width: 63vw;
			}
			progress::-webkit-progress-bar{
				background-color: gray;
				background-image: linear-gradient(45deg, black, gray, #aaa);
			}
			progress::-webkit-progress-value{
				background-color: green;
				background-image: repeating-linear-gradient(
					135deg,
					red 0vw,
					orange 9vw,
					yellow 18vw,
					green 27vw,
					blue 36vw,
					indigo 45vw,
					purple 54vw
				);
			}
			
			#warning > button{
				width: 80%;
				height: 60px;
				position: relative;
				top: 26px;
				font-size: 8vmin;
				font-family: hwxk, serif;
			}
			*{
				font-family: qq2, serif;
				outline: none;
			}
			
			dialog{
				position: absolute;
				top: 16vmin;
				
				max-width: 50vw;
				border-radius: 6px;
				
				z-index: 4;
			}
			
			#control{
				position: absolute;
				bottom: 16%;
				left: 10%;
				background: #aaa;
				opacity: 0.66;
				width: 66px;
				height: 66px;
				border-radius: 50%;
			}
			#jump{
				position: absolute;
				bottom: 16%;
				right: 10%;
				background: #aaa;
				opacity: 0.66;
				width: 46px;
				height: 46px;
				border-radius: 50%;
			}
			
			#tools{
				position: absolute;
				bottom: 12px;
				left: 50%;
				transform: translateX(-50%);
				width: 300px;
				height: 50px;
			}
			#tools > img{
				width: 16%;
				height: 100%;
				display: inline-block;
				margin: 0 -2px;
				border-color: #aaa;
				border-width: 3px;
				border-style: groove;
			}
			
			textarea{
				resize: none;
			}
			
			#bag, #command{
				width: 80vw;
				height: 80vh;
				
				position: absolute;
				left: 50%;
				top: 50%;
				transform: translate(-50%, -50%);
				
				display: none;
				z-index: 1;
				
				background-color: #c4c4c4;
				border: 3px #fff outset;
				padding: 1.6%;
			}
			/*#command{
				width: 86.66%;
				height: 86.66%;
			}*/
			
			#command > textarea{
				width: 100%;
				height: 88.6%;
				
				color: black;
				background-color: #d6d6d6;
				border: 2px #fff inset;
				font-size: 3vw;
			}
			#command > button{
				width: 48%;
				height: 9%;
				margin: 0 0.6%;
				font-size: 5vmin;
			}
			
			#bag > div{
				height: 20%;
				font-size: 3.7vw;
				margin: 6px;
			}
			#bag > div > ul{
				display: -webkit-flex; 
				display: -moz-box;
				display: -mz-flexbox;
				display: flex; 
				
				width: 50%;
				overflow-x: auto;
				overflow: none;
				
				list-style: none;
				margin: 0;
				margin-left: 5.2vw;
				margin-top: -36px;
				padding: 0;
			}
			#bag > div > ul > li{
				float: left;
				flex: 0 0 auto;
			}
			#bag > div > ul > li > *{
				width: 100%;
				height: 100%;
			}
			.thing{
				/* position: absolute; */
				width: 7vw;
				height: 7vw;
				
				display: inline-block;
				border: 3px inset #fff;
				margin: 0.3vw;
			}
			.delete{
				/* position: absolute; */
				width: 7vw;
				height: 7vw;
				
				font-size: 26px;
				display: inline-block;
				border: 3px inset #fff;
				margin: 0.3vw;
			}
		</style>
		
		<script src="./js/jquery.min.js"></script>
		<script>
		if (typeof(require) != "undefined")
			window.$ = window.jQuery = require("./js/jquery.min.js");
		</script>
		<script src="https://cdn.jsdelivr.net/npm/eruda"></script>
		<script src="https://cdn.bootcss.com/vConsole/3.3.4/vconsole.min.js"></script>
		<script>eruda.init();</script>
		<script>new VConsole();</script>
		<script src="./js/three.min.js"></script>
		<script src="./js/simplex-noise.js"></script>
		<script src="./js/dat.gui.min.js"></script>
		<script src="./js/stats.min.js"></script>
		<script src="./js/SQL.js"></script>
		<!--<script src="./node_modules/three/examples/js/controls/PointerLockControls.js"></script>-->
	</head>
	
	<body bgcolor="black">
		<div id="tools">
			<img/>
			<img/>
			<img/>
			<img/>
			<img src="./img/more.png" onclick="state('bag');" />
		</div>
		
		<div id="command">
			<textarea>
deskgood.goY(10000*100);
deskgood.move(0,10000*100,0);
deskgood.moveTo(0,10000*100);
//这是注释，告诉你这三个命令都可以把deskgood送上万米高空"))</textarea>
			<button onclick="state('command');">关闭</button>
			<button onclick="run($('#command > textarea').val());">运行</button>
		</div>
		<div id="bag">
			<div>
				头：
				<ul>
					<li class="thing"></li>
					<li class="thing"></li>
					<li class="thing"></li>
					<li class="thing"></li>
					<li class="thing"></li>
					<li class="thing"></li>
					<li class="thing"></li>
					<li class="thing"></li>
					<li class="thing"></li>
					<li class="delete"><img src="img/delete.png" /></li>
				</ul>
			</div>
			<div>
				身：
				<ul>
					<li class="thing"></li>
					<li class="delete"><img src="img/delete.png" /></li>
				</ul>
			</div>
			<div>
				腿：
				<ul>
					<li class="thing"></li>
					<li class="delete"><img src="img/delete.png" /></li>
				</ul>
			</div>
			<div>
				脚：
				<ul>
					<li class="thing"></li>
					<li class="delete"><img src="img/delete.png" /></li>
				</ul>
			</div>
		</div>
		<h1 id="schedule" style="z-index: 2;">
			<header>贴图加载中……</header>
			进度：<progress></progress>
			<span>0</span>%<br/>
			<b>生命诚可贵，生命只有一次，请珍爱生命</b>
		</h1>
		<h1 id="warning" style="z-index: 3;">
			推荐使用横屏运行（启用浏览器横屏或<a href="https://github.com/wzh656/MinecraftWeb/releases/download/v0.4.0-alpha/Minecraft-full.apk">下载apk（完整版）</a>or<a href="https://github.com/wzh656/MinecraftWeb/releases/download/v0.4.0-alpha/Minecraft-simplified.apk">（简化版）</a>）<br/>
			<button onclick="this.parentElement.remove();">继续竖屏</button>
		</h1>
		<audio id="bgm" perload loop style="display: none;" src="./music/1.m4a" ></audio>
		<!--<audio id="bgm" autoplay perload loop style="display: none;" src="https://vdse.bdstatic.com/876934f28995e8042230ec598237c67e.mp4?authorization=bce-auth-v1/fb297a5cc0fb434c971b8fa103e8dd7b/2017-05-11T09:02:31Z/-1//ab5b458a478fae53b754e194ab270b96f23aa23ba71c2e63b06fc06d0543040c"></audio>-->
		<noscript><h1 style="z-index: 5;">你的浏览器不支持JavaScript，无法运行！</h1></noscript>
<script>
document.addEventListener("plusready", function(){
	plus.device.setWakelock(true); //屏幕常亮
	
	if (sessionStorage.getItem("already_send") == "true")
		return; //不再发送
	
	let types = {}; 
		types[plus.networkinfo.CONNECTION_UNKNOW] = "Unknown connection";
		types[plus.networkinfo.CONNECTION_NONE] = "None connection";
		types[plus.networkinfo.CONNECTION_ETHERNET] = "Ethernet connection";
		types[plus.networkinfo.CONNECTION_WIFI] = "WiFi connection";
		types[plus.networkinfo.CONNECTION_CELL2G] = "Cellular 2G connection";
		types[plus.networkinfo.CONNECTION_CELL3G] = "Cellular 3G connection";
		types[plus.networkinfo.CONNECTION_CELL4G] = "Cellular 4G connection";
	let data = {
		"device_imei(设备的国际移动设备身份码)": plus.device.imei,
		"device_imsi(设备的国际移动用户识别码)": JSON.stringify(plus.device.imsi),
		"device_model(设备的型号)": plus.device.model,
		"device_vendor(设备的生产厂商)": plus.device.vendor,
		"device_uuid(设备的唯一标识)": plus.device.uuid,
		"screen_currentSize(屏幕信息)": JSON.stringify(plus.screen.getCurrentSize()),
		"networkInfo_currentType(网络信息)": types[plus.networkinfo.getCurrentType()],
		"os_language(系统语言信息)": plus.os.language,
		"os_name(系统的名称)": plus.os.name,
		"os_vendor(系统的供应商信息)": plus.os.vendor,
		"os_version(系统版本信息)": plus.os.version
	};
	console.log($.post("http://api.s.wps.cn/api/form/f39d2d9d/mainPreviewa", data)); //发送信息
	console.log(data);
	sessionStorage.setItem("already_send", "true"); //已发送
});
</script>

<script>
function run(code){
	try{
		eval(code);
	}catch(err){
		console.error("【命令】\n代码运行出错，错误信息（自行翻译）：\n"+err);
		alert("代码运行出错，错误信息（自行翻译,可在VConsole查看）：\n"+err);
		/* $.get("http://fanyi.youdao.com/translate",{
			doctype: "json",
			type: "auto",
			i: err
		},function(data, state, xhr){
			console.log(data);
			try{
				if (state == "success" & !!data.translateResult[0][0].tgt){
					console.error("【命令方块】\n代码运行出错，错误信息：\n"+err+"\n译文（有道翻译提供）："+data.translateResult[0][0].tgt);
					alert("代码运行出错，错误信息（可在VConsole查看）：\n"+err+"\n译文（有道翻译提供）："+data.translateResult[0][0].tgt);
				}else{
					console.error("【命令方块】\n代码运行出错，错误信息（自行翻译）：\n"+err);
					alert("代码运行出错，错误信息（自行翻译,可在VConsole查看）：\n"+err);
				}
			}catch(e){
				console.error("【命令方块】\n代码运行出错，错误信息（自行翻译）：\n"+err);
				alert("代码运行出错，错误信息（自行翻译,可在VConsole查看）：\n"+err);
			}
		}); */
	}
}
function playBGM(){
	let bgm = $("#bgm")[0];
	if (bgm.paused){
		let random = Math.random();
		if (random < 0.5){
			bgm.volume = 1;
			bgm.src = "./music/1.m4a";
			bgm.play();
			console.info("bgm(BackGround Music)", "begin(1.m4a)", "time:"+new Date());
		}else{
			bgm.volume = 1;
			bgm.src = "./music/2.m4a";
			bgm.play();
			console.info("bgm(BackGround Music)", "begin(2.m4a)", "time:"+new Date());
		}
		setTimeout(function(){
			let bgm_folder = gui.addFolder("背景音乐(bgm)")
			bgm_folder.add(bgm, "volume", 0, 1, 0.01).name("音量(volume)");
			bgm_folder.add(bgm, "paused").name("是否暂停(paused)").listen();
			bgm_folder.add({f:()=>{
				bgm.pause();
			}}, "f").name("暂停(pause)");
			bgm_folder.add({f:()=>{
				bgm.play();
			}}, "f").name("播放(play)");
			bgm_folder.add(bgm, "currentTime", 0, bgm.duration, 0.001).name("播放进度(current time)").listen();
			bgm_folder.add(bgm, "src").name("音乐路径(src)");
		},1000);
	}else{
		//console.log("already", bgm.paused);
		bgm.play();
	}
}
document.addEventListener("plusready", playBGM);
document.addEventListener("touchstart", playBGM);

var stop = true;
/**
* 判断手机电脑
*/
if (/ipad|iphone|midp|rv:1.2.3.4|ucweb|android|windows ce|windows mobile/.test(
		navigator.userAgent.toLowerCase()
	)
){ //手机
	let control = document.createElement("div");
	let jump = document.createElement("div");
	
	control.id = "control";
	jump.id = "jump";
	
	document.body.appendChild(control);
	document.body.appendChild(jump);
	
	stop = false;
	
	/*let vconsole = document.createElement("script");
	vconsole.src = "https://cdn.bootcss.com/vConsole/3.3.4/vconsole.min.js";
	vconsole.onload = function(){
		new VConsole();
		document.getElementById("__vconsole").childNodes[1].style.opacity = 0.5;
		document.getElementById("__vconsole").childNodes[1].style.borderRadius = "66px";
	};
	document.body.appendChild(vconsole);*/
	//new VConsole();
}else{ //电脑
	let mouse = document.createElement("div");
	let parts = [
		document.createElement("div"),	//竖
		document.createElement("div")	//横
	];
	parts[0].style.width = "2px";
	parts[0].style.height = "30px";
	parts[0].style.backgroundColor = "rgba(255, 255, 255, 0.666666)";
	parts[0].style.position = "absolute";
	parts[0].style.left = "50%";
	parts[0].style.top = "50%";
	parts[0].style.transform = "translate(-50%,-50%)";
	
	parts[1].style.width = "30px";
	parts[1].style.height = "2px";
	parts[1].style.backgroundColor = "rgba(255, 255, 255, 0.666666)";
	parts[1].style.position = "absolute";
	parts[1].style.left = "50%";
	parts[1].style.top = "50%";
	parts[1].style.transform = "translate(-50%,-50%)";
	
	mouse.appendChild(parts[0]);
	mouse.appendChild(parts[1]);
	mouse.style.width = "30px";
	mouse.style.height = "30px";
	mouse.style.position = "absolute";
	mouse.style.left = "50%";
	mouse.style.top = "50%";
	mouse.style.transform = "translate(-50%,-50%)";
	mouse.id = "mouse";
	mouse.style.cursor = "none";
	
	document.body.appendChild(mouse);
	
	
	let help = document.createElement("h1");
	help.innerHTML = `
		WSAD/↑↓←→: 前后左右; 空格:跳跃; 连按W/ctrl+W:疾跑<br/>
		Esc: 退出锁定鼠标并保存游戏<br/>
		请先点击任意处锁定鼠标以开始游戏`
	;
	help.style.opacity = 0.5;
	help.id = "help";
	document.body.appendChild(help);
	
	//遮罩层事件
	help.addEventListener("click", function (){
		/* if (stop){ //请求解除指针锁定
			document.exitPointerLock =
				document.exitPointerLock ||
				document.mozExitPointerLock ||
				document.webkitExitPointerLock
			;
			document.exitPointerLock();
		}else{ */ 
			//请求指针锁定
			document.body.requestPointerLock =
				document.body.requestPointerLock ||
				document.body.mozRequestPointerLock ||
				document.body.webkitRequestPointerLock
			;
			//解除鼠标锁定
			document.exitPointerLock =
				document.exitPointerLock ||
				document.mozExitPointerLock ||
				document.webkitExitPointerLock
			;
			document.body.requestPointerLock();
			stop = false;
			playBGM();
		// }
	}, false);
	
	//输入锁定改变事件
	let pointerlockchange = function(){
		if (typeof stop == "string")
			return;
		
		if (
			document.pointerLockElement === document.body ||
			document.mozPointerLockElement === document.body ||
			document.webkitPointerLockElement === document.body
		){ //已锁定
			console.log("pointerLock yes");
			stop = false;
			$("#help").css("display", "none");
		}else{ //未锁定
			console.log("pointerLock no");
			stop = true;
			$("#help").css("display", "inline-block");
			save();
		}
	};
	
	//输入锁定改变错误
	let pointerlockerror = function(){
		console.error("鼠标锁定错误");
		alert("鼠标锁定错误\n请重试或切换/升级浏览器");
	};
	
	// Hook pointer lock state change events
	document.addEventListener("pointerlockchange", pointerlockchange, false);
	document.addEventListener("mozpointerlockchange", pointerlockchange, false);
	document.addEventListener("webkitpointerlockchange", pointerlockchange, false);
	
	document.addEventListener("pointerlockerror", pointerlockerror, false);
	document.addEventListener("mozpointerlockerror", pointerlockerror, false);
	document.addEventListener("webkitpointerlockerror", pointerlockerror, false);
}


/**
* dat.gui
*/
let gui = new dat.GUI({
	name: "控制/调试",
	useLocalStorage: false, // 使用LocalStorage来存储
	closeOnTop: true // 关闭按钮是否在顶部
});
gui.close();
gui.add({f:function(){
	run(prompt("请输入命令：","deskgood.goY(3000*100);"))
}}, "f").name("运行(run)命令");
gui.add(window, "save").name("保存(save)");
gui.add(location, "reload").name("刷新(reload)");
/* window.addEventListener("beforeunload", function(event){
	event.preventDefault();
	event.returnValue = "未保存！";
	return "未保存！";
}); */


/**
* 初始化
*/
function Thing(opinion){
	//物品ID
	this.id = Number(opinion.id);
	//this.id = Thing.prototype.idLength++; //同时自增
	
	//名称
	if (opinion.name){
		this.name = String(opinion.name);
	}
	
	//方块
	this.block = {};
	if (opinion.block){
		if (opinion.block.face){ //贴图 位置
			this.block.face = [];
			for (let i=0; i<opinion.block.face.length; i++)
				if (opinion.block.parent && opinion.block.parent[i])
					this.block.face[i] = opinion.block.parent[i] + opinion.block.face[i]
				else
					this.block.face[i] = `./img/blocks/${this.id}/` + opinion.block.face[i];
		}
		this.block.editFace = (index, value)=>{
			if (index != undefined){ //有索引（单个）
				if (value != undefined){ //赋值
					this.block.face[index] = value;
				}else{ //取值
					return this.block.face[index];
				}
			}else{ //无索引（所有）
				if (value != undefined){ //赋值
					for (let i=0; i<value.length; i++)
						this.block.face[i] = value[i];
				}else{
					return this.block.face;
				}
			}
			return this;
		}
		
		if (opinion.block.texture){ //贴图 数据
			this.block.texture = [];
			for (let i=0; i<opinion.block.texture.length; i++)
				if (opinion.block.texture[i])
					this.block.texture[i] = opinion.block.texture[i];
		}
		this.block.setTexture = (texture, index)=>{
			if (!this.block.texture){
				this.block.texture = [];
			}
			if (index != undefined){ //有索引
				this.block.texture[index] = texture;
			}else{ //无索引
				for (let i=0; i<texture.length; i++){
					this.block.texture[i] = texture[i];
				}
			}
			return this;
		}
		this.block.deleteTexture = (index)=>{
			if (index != undefined){ //有索引
				this.block.texture[index].dispose(); //清除内存
				delete this.block.texture[index];
			}else{ //无索引
				for (let i of this.block.texture)
					i.dispose(); //清除内存
				delete this.block.texture;
			}
			return this;
		}
		
		if (opinion.block.material){ //材质
			this.block.material = opinion.block.material;
		}
		this.block.makeMaterial = ()=>{
			this.block.material = [
				new THREE.MeshLambertMaterial({ map:this.block.texture[0], transparent:true/*, visible:false*/ }),
				new THREE.MeshLambertMaterial({ map:this.block.texture[1], transparent:true/*, visible:false*/ }),
				new THREE.MeshLambertMaterial({ map:this.block.texture[2], transparent:true/*, visible:false*/ }),
				new THREE.MeshLambertMaterial({ map:this.block.texture[3], transparent:true/*, visible:false*/ }),
				new THREE.MeshLambertMaterial({ map:this.block.texture[4], transparent:true/*, visible:false*/ }),
				new THREE.MeshLambertMaterial({ map:this.block.texture[5], transparent:true/*, visible:false*/ })
			]; //材质对象 MeshLambertMaterial
			return this;
		}
		this.block.deleteMaterial = ()=>{
			for (let i of this.block.material)
				i.dispose(); //清除内存
			delete this.block.material;
			return this;
		}
		
		if (opinion.block.mesh){ //网格模型
			this.block.mesh = opinion.block.mesh;
		}
		this.block.makeMesh = (geometry)=>{
			if (geometry){
				this.block.mesh = new THREE.Mesh(geometry, this.block.material); //网格模型对象Mesh
			}else{ //使用默认
				this.block.mesh = new THREE.Mesh(Thing.prototype.geometry, this.block.material); //网格模型对象Mesh
			}
			this.block.mesh.castShadow = true;
			this.block.mesh.receiveShadow = true;
			return this;
		}
		this.block.deleteMesh = (index)=>{
			this.block.mesh.material.dispose();
			this.block.mesh.geometry.dispose(); //清除内存
			delete this.block.mesh;
			return this;
		}
	}
	
	//持有时的效果
	this.hold = {};
	if (opinion.hold){
		if (opinion.hold.tool){
			this.hold.tool = opinion.hold.tool;
		}
		if (opinion.hold.head){
			this.hold.head = opinion.hold.head;
		}
		if (opinion.hold.body){
			this.hold.body = opinion.hold.body;
		}
		if (opinion.hold.leg){
			this.hold.leg = opinion.hold.leg;
		}
		if (opinion.hold.foot){
			this.hold.foot = opinion.hold.foot;
		}
	}
}
//Thing.prototype.idLength = 0;
Thing.prototype.geometry = new THREE.BoxGeometry(100, 100, 100);

SimplexNoise.prototype.more3D = function(xin, yin, zin, more){
	let sum = 0;
	for (let i=1; i<more; i*=2){
		sum += this.noise3D(xin*i, yin*i, zin*i)/i;
	}
	return sum;
};
function seed_error(noise, t, id, x, z){
	return noise.more3D(id, x/t.q, z/t.q, 3) *t.k +t.b;
}
function seed_height(noise, t, x, z){
	let value = ( noise.more3D(0.6,	x/t.q, z/t.q, 3)+
		noise.more3D(-3.1415926,	x/t.q, z/t.q, 3)+
		noise.more3D(54.782,		x/t.q, z/t.q, 3) )/3;
	value = 1-Math.sin( (1-value)*90/180*Math.PI );
	return value *t.k +t.b +seed_error(noise, t.e, -1428.57, x, z);
}
function seed_type(noise, t, x, z){
	let value = Math.abs( noise.noise3D(333.35, x/t.q, z/t.q) );
	return value<0.4? 0: value<0.8? 1: 2;
}
function seed_scale(noise, t, x, z){
	return noise.more3D(6.6, x/t.q, z/t.q, 6) *t.k +t.b +seed_error(noise, t.e, -52.6338, x, z);
}
function BlockMap(size, seed, perloadLength){
	//一区块大小
	this.size = {};
	this.size.x = Math.round(size[1].x - size[0].x)+1;
	this.size.y = Math.round(size[1].y - size[0].y)+1;
	this.size.z = Math.round(size[1].z - size[0].z)+1;
	this.size[0] = {};
	this.size[1] = {};
	this.size[0].x = Math.round(size[0].x); //-8
	this.size[0].y = Math.round(size[0].y); //0
	this.size[0].z = Math.round(size[0].z); //-8
	this.size[1].x = Math.round(size[1].x); //8
	this.size[1].y = Math.round(size[1].y); //32
	this.size[1].z = Math.round(size[1].z); //8
	
	//所有方块
	this.map = [];
	//已初始化的区块
	this.initedBlock = [];
	//活动区块（加载完毕）
	this.activeBlock = [];
	//区块预加载范围
	this.perloadLength = perloadLength;
	//种子设置
	if (seed){
		/* h:height, s:scale{
			ave: 均值,
			de: 最大波动程度,
			q: 波动程度
		}*/
		this.seed = {
			seed: seed.seed,
			h: {
				max: seed.height.max,
				min: seed.height.min,
				//ave: seed.height.ave,
				/*de: seed.height.de,*/
				q: seed.height.q,
				e: {
					max: seed.height.error.max,
					min: seed.height.error.min,
					q: seed.height.error.q
				}
			},
			s: {
				max: seed.scale.max,
				min: seed.scale.min,
				/*ave: seed.scale.ave,
				de: seed.scale.de,*/
				q: seed.scale.q,
				e: {
					max: seed.scale.error.max,
					min: seed.scale.error.min,
					q: seed.scale.error.q
				}
			},
			t: {
				max: 2,
				min: 0,
				q: seed.type.q
			}
		};
		this.seed.noise = new SimplexNoise(this.seed.seed);
		/* this.seed.h.k = (this.seed.h.max - this.seed.h.min)/2;
		this.seed.h.b = (this.seed.h.max + this.seed.h.min)/2;
		this.seed.s.k = (this.seed.s.max - this.seed.s.min)/2;
		this.seed.s.b = (this.seed.s.max + this.seed.s.min)/2; */
		this.seed.h.k = this.seed.h.max - this.seed.h.min;
		this.seed.h.b = this.seed.h.min;
		this.seed.h.e.k = (this.seed.h.e.max - this.seed.h.e.min)/2;
		this.seed.h.e.b = (this.seed.h.e.max + this.seed.h.e.min)/2;
		this.seed.s.k = (this.seed.s.max - this.seed.s.min)/2;
		this.seed.s.b = (this.seed.s.max + this.seed.s.min)/2;
		this.seed.s.e.k = (this.seed.s.e.max - this.seed.s.e.min)/2;
		this.seed.s.e.b = (this.seed.s.e.max + this.seed.s.e.min)/2;
	}
	
	
	
	//获取方块（不可编辑）
	this.get = (x, y, z)=>{  // 没有方块:null,不在范围:undefined,加载中:false
		[x, y, z] = [x, y, z].map(Math.round); //规范化
		
		try{
			if (this.map[x][y][z] == undefined){
				return undefined;
			}else{
				return this.map[x][y][z];
			}
		}catch(err){ //超过范围
			return undefined;
		}
	};
	
	//添加方块
	this.add = (thing, pos)=>{
		[pos.x, pos.y, pos.z] = [pos.x, pos.y, pos.z].map(Math.round); //规范化
		
		//console.log(thing.block.mesh, pos)
		thing.block.mesh.position.x = pos.x*100;
		thing.block.mesh.position.y = pos.y*100;
		thing.block.mesh.position.z = pos.z*100;
		//thing.block.visible = false; //默认不绘制
		
		scene.add(thing.block.mesh); //网格模型添加到场景中
		//thing.block.mesh = thing.block.mesh;
		this.map[pos.x][pos.y][pos.z] = thing;
	};
	//根据 模板和ID 添加方块
	this.addID = (id, pos, template)=>{
		if (id == 0){
			[pos.x, pos.y, pos.z] = [pos.x, pos.y, pos.z].map(Math.round); //规范化
			this.map[pos.x][pos.y][pos.z] = null; //空气
			return;
		}
		
		this.add(
			new Thing(template[id])
				.block.makeMaterial()
				.block.deleteTexture()
				.block.makeMesh(),
			{
				x:pos.x,
				y:pos.y,
				z:pos.z,
			}
		); //以模板建立
	};
	
	//删除方块
	this.delete = (x, y, z)=>{
		[x, y, z] = [x, y, z].map(Math.round); //规范化
		
		if (!this.get(x,y,z)) // 没有方块(null)/不在范围(undefined)/加载中(false)
			return;
		
		for (let i of this.map[x][y][z].block.mesh.material)
			i.dispose();
		this.map[x][y][z].block.mesh.geometry.dispose(); //清除内存
		scene.remove(this.map[x][y][z].block.mesh);
		this.map[x][y][z] = null;
	};
	
	
	//更新方块
	this.update = (x, y, z)=>{
		[x, y, z] = [x, y, z].map(Math.round); //规范化
		
		if (!this.get(x,y,z)) // 没有方块(null)/不在范围(undefined)/加载中(false)
			return;
		
		this.map[x][y][z].block.material[0].visible = !this.get(x+1, y, z);
		this.map[x][y][z].block.material[1].visible = !this.get(x-1, y, z);
		this.map[x][y][z].block.material[2].visible = !this.get(x, y+1, z);
		this.map[x][y][z].block.material[3].visible = !this.get(x, y-1, z);
		this.map[x][y][z].block.material[4].visible = !this.get(x, y, z+1);
		this.map[x][y][z].block.material[5].visible = !this.get(x, y, z-1);
	};
	
	//更新方块及周围
	this.updateRound = (x,y,z)=>{
		this.update(x, y, z);
		this.update(x+1, y, z);
		this.update(x-1, y, z);
		this.update(x, y+1, z);
		this.update(x, y-1, z);
		this.update(x, y, z+1);
		this.update(x, y, z-1);
	};
	
	//更新区块内所有方块（同步）
	this.updateBlock = (x, z)=>{
		let ox = x*this.size.x,
			oz = z*this.size.z; //区块中心坐标
		
		for (let dx=this.size[0].x; dx<=this.size[1].x; dx++){
			for (let dy=this.size[0].y; dy<=this.size[1].y; dy++){
				for (let dz=this.size[0].z; dz<=this.size[1].z; dz++){
					this.update(ox+dx, dy, oz+dz);
				}
			}
		}
	};
	//更新区块内所有方块（异步）
	this.updateBlockAsync = (x, z, callback)=>{
		//console.log("updateBlock:",x,z,+new Date);
		let ox = x*this.size.x,
			oz = z*this.size.z; //区块中心坐标
		
		if (callback){ //有回调（必须setInterval）
			let dx = this.size[0].x;
			let updateBlock_id = setInterval(()=>{
				if (dx > this.size[1].x){
					clearInterval(updateBlock_id);
					callback();
					return;
				}
				
				//正常代码
				for (let dy=this.size[0].y; dy<=this.size[1].y; dy++){
					for (let dz=this.size[0].z; dz<=this.size[1].z; dz++){
						this.update(ox+dx, dy, oz+dz);
					}
				}
				
				dx++;
			},0);
		}else{ //无回调（不分顺序）
			for (let dx=this.size[0].x; dx<=this.size[1].x; dx++){
				setTimeout(()=>{
					
					//正常代码
					for (let dy=this.size[0].y; dy<=this.size[1].y; dy++){
						for (let dz=this.size[0].z; dz<=this.size[1].z; dz++){
							this.update(ox+dx, dy, oz+dz);
						}
					}
					
				},0);
			}
		}
		
		/* for (let dx=this.size[0].x; dx<=this.size[1].x; dx++){
			for (let dy=this.size[0].y; dy<=this.size[1].y; dy++){
				for (let dz=this.size[0].z; dz<=this.size[1].z; dz++){
					this.update(ox+dx, dy, oz+dz);
				}
			}
		} */
	};
	
	
	//初始化区块
	this.initBlock = (x, z)=>{
		[x, z] = [x, z].map(Math.round); //规范化
		let ox = x*this.size.x,
			oz = z*this.size.z; //区块中心坐标
		
		if (this.initedBlock.every(function(value, index, arr){
			return value[0] != x || value[1] != z;
		})) //每个都不一样（不存在）
			this.initedBlock.push([x,z]);
		
		for (let dx=this.size[0].x; dx<=this.size[1].x; dx++){
			this.map[ox+dx] = this.map[ox+dx] || [];
			for (let dy=this.size[0].y; dy<=this.size[1].y; dy++){
				this.map[ox+dx][dy] = this.map[ox+dx][dy] || [];
				for (let dz=this.size[0].z; dz<=this.size[1].z; dz++){
					this.map[ox+dx][dy][oz+dz] = false/* null */;
				}
			}
		}
	};
	
	//加载列
	this.loadColumn = (x, z, edit)=>{
		[x, z] = [x, z].map(Math.round); //规范化
		let t = this.seed; //临时变量
		let height = seed_height(t.noise, t.h, x, z);
		if (height < 1){
			height = 1;
		}else if (height > 64){
			height = 64;
		}
		/* let noise = ( t.noise.more3D(0.6, x/t.h.q, z/t.h.q, 3)+
		t.noise.more3D(-3.1415926, x/t.h.q, z/t.h.q, 3)+
		t.noise.more3D(54.782, x/t.h.q, z/t.h.q, 3) )/3;
		noise = 1-Math.sin( (1-noise)*90/180*Math.PI );
		let height = noise *t.h.k +t.h.b+
		t.noise.more3D(-1428.57, x/t.h.e.q, z/t.h.e.q, 3) *t.h.e.k +t.h.e.b; */
		
		/*let noise = Math.abs(t.noise.more3D(0.6, x/t.h.q/2, z/t.h.q/2, 5));
		let height = noise*noise*noise*(noise*(noise*6-15)+10) //*t.h.k +t.h.b;
		height = Math.pow(t.h.k, height) + t.h.b;*/
		// debugger
		// let a = 1/(1+Math.pow(Math.E, 3)), // 1/(1+e^3)
		// 	b = 1/(1+Math.pow(Math.E, -3)), // 1/(1+e^(-3))
		// 	noise = (1+Math.pow(Math.E, -3*noise)-a)/(b-a); // (1+e^(-3x)-a)/(b-a)
		// let height = (t.h.max -t.h.min)/(t.h.ave -1) *Math.pow(t.h.ave, noise) *(t.h.min *t.h.ave -t.h.max)/(t.h.ave -1);
		// let height = Math.pow(1000, 0.5+0.5*noise, 3), 10);
		// let height = t.noise.noise3D(0.6, x/t.h.q, z/t.h.q) *t.h.de + t.h.ave;
		
		let grass = false;
		let type = seed_type(t.noise, t.t, x, z);
		// 54+ 高原（草木不生，积雪覆盖）
		// 40+ 高山（无树，有草）
		// 26+ 丘陵（树）
		// type
		if (height > 54){
			grass = true;
		}else if (height > 40){
			
		}else if (height > 26){
			
		}else{
			
		}
		for (let dy=this.size[1].y; dy>=this.size[0].y; dy--){ //注意：从上到下
			
			let earth = height - height * seed_scale(t.noise, t.s, x, z);
			/* let earth = height - height * (t.noise.more3D(6.6, x/t.s.q, z/t.s.q, 6) *t.s.k +t.s.b)+
			t.noise.more3D(-52.6338, x/t.s.e.q, z/t.s.e.q, 3) *t.s.e.k +t.s.e.b; */
			let id = 0;
			if (dy > height){
				id = 0; // 空气/真空 (null)：不用加载
			}else if (dy > earth){
				switch (type){
					case 0: //森林
						if (grass){
							id = 3; //泥土
						}else{
							id = 2; //草方块
							grass = true;
						}
						break;
					case 1: //草原
						if (grass){
							id = 3; //泥土
						}else{
							id = 2; //草方块
							grass = true;
						}
						break;
					case 2: //沙漠
						id = 6;
						break;
				}
			}else{
				if (!grass && t.noise.more3D(375.12, x, z, 3)<0.99){
					switch (type){
						case 0: //森林
							id = 2; //草方块
							grass = true;
							break;
						case 1: //草原
							id = 2; //草方块
							grass = true;
							break;
						case 2: //沙漠
							id = 6;
							grass = true;
							break;
					}
				}else{
					id = 5; //石头
				}
			}
			
			if (!new Array(...edit).some((value, index, arr) => {
				let ret = value.x == x &&
					value.y == dy &&
					value.z == z;
				if (ret){ //被编辑
					this.addID(value.id, {
						x: x,
						y: dy,
						z: z
					}, template);
				}
				return ret;
			})){ //未编辑
				this.addID(id, {
					x: x,
					y: dy,
					z: z
				}, template);
			}
			
		}
	}
	//加载区块（同步）
	this.loadBlock = (x, z)=>{
		[x, z] = [x, z].map(Math.round); //规范化
		let ox = x*this.size.x,
			oz = z*this.size.z; //区块中心坐标
			
		if (this.activeBlock.every(function(value, index, arr){
			return value[0] != x || value[1] != z;
		})) //每个都不一样（不存在）
			this.activeBlock.push([x,z]);
		
		for (let dx=this.size[0].x; dx<=this.size[1].x; dx++){
			for (let dz=this.size[0].z; dz<=this.size[1].z; dz++){
				
			}
		}
	}
	//加载区块（异步）
	this.loadBlockAsync = (x, z, callback, dir="")=>{
		if (typeof callback != "function")
			[dir, callback] = [callback, dir];
		
		[x, z] = [x, z].map(Math.round); //规范化
		let ox = x*this.size.x,
			oz = z*this.size.z, //区块中心坐标
			t = this.seed; //临时变量
		
		sql.selectData("file", ["x", "y", "z", "id", "attr"],
			`type=0 AND`+
			` (x BETWEEN ${ ox+this.size[0].x } AND ${ ox+this.size[1].x }) AND`+
			` (z BETWEEN ${ oz+this.size[0].z } AND ${ oz+this.size[1].z })`,
			(edit) => {
				
				console.log("edit(sql):",edit);
				
				switch (dir.substr(0,2)){
					case "x-":
						if (callback){ //有回调（必须setInterval）
							let dx = this.size[1].x;
							let loadBlock_id = setInterval(()=>{
								if (dx < this.size[0].x){
									clearInterval(loadBlock_id);
									
									if (this.activeBlock.every(function(value, index, arr){
										return value[0] != x || value[1] != z;
									})) //每个都不一样（不存在）
										this.activeBlock.push([x,z]);
									
									callback();
									return;
								}
								
								//正常代码
								for (let dz=this.size[0].z; dz<=this.size[1].z; dz++){
									this.loadColumn(ox+dx, oz+dz, edit);
								}
								
								dx--;
							},0);
						}else{ //无回调（不分顺序）
							if (this.activeBlock.every(function(value, index, arr){
								return value[0] != x || value[1] != z;
							})) //每个都不一样（不存在）
								this.activeBlock.push([x,z]);
							
							for (let dx=this.size[1].x; dx<=this.size[0].x; dx--){
								setTimeout(()=>{
									//正常代码
									for (let dz=this.size[0].z; dz<=this.size[1].z; dz++){
										this.loadColumn(ox+dx, oz+dz, edit);
									}
								},0);
							}
						}
						break;
					
					case "z+":
						if (callback){ //有回调（必须setInterval）
							let dz = this.size[0].z;
							let loadBlock_id = setInterval(()=>{
								if (dz > this.size[1].z){
									clearInterval(loadBlock_id);
									
									if (this.activeBlock.every(function(value, index, arr){
										return value[0] != x || value[1] != z;
									})) //每个都不一样（不存在）
										this.activeBlock.push([x,z]);
									
									callback();
									return;
								}
								
								//正常代码
								for (let dx=this.size[0].x; dx<=this.size[1].x; dx++){
									this.loadColumn(ox+dx, oz+dz, edit);
								}
								
								dz++;
							},0);
						}else{ //无回调（不分顺序）
							if (this.activeBlock.every(function(value, index, arr){
								return value[0] != x || value[1] != z;
							})) //每个都不一样（不存在）
								this.activeBlock.push([x,z]);
							
							for (let dz=this.size[0].z; dz<=this.size[1].z; dz++){
								setTimeout(()=>{
									//正常代码
									for (let dx=this.size[0].x; dx<=this.size[1].x; dx++){
										this.loadColumn(ox+dx, oz+dz, edit);
									}
								},0);
							}
						}
						break;
					
					case "z-":
						if (callback){ //有回调（必须setInterval）
							let dz = this.size[1].z;
							let loadBlock_id = setInterval(()=>{
								if (dz < this.size[0].z){
									clearInterval(loadBlock_id);
									
									if (this.activeBlock.every(function(value, index, arr){
										return value[0] != x || value[1] != z;
									})) //每个都不一样（不存在）
										this.activeBlock.push([x,z]);
									
									callback();
									return;
								}
								
								//正常代码
								for (let dx=this.size[0].x; dx<=this.size[1].x; dx++){
									this.loadColumn(ox+dx, oz+dz, edit);
								}
								
								dz--;
							},0);
						}else{ //无回调（不分顺序）
							if (this.activeBlock.every(function(value, index, arr){
								return value[0] != x || value[1] != z;
							})) //每个都不一样（不存在）
								this.activeBlock.push([x,z]);
							
							for (let dz=this.size[1].z; dz<=this.size[0].z; dz--){
								setTimeout(()=>{
									//正常代码
									for (let dx=this.size[0].x; dx<=this.size[1].x; dx++){
										this.loadColumn(ox+dx, oz+dz, edit);
									}
								},0);
							}
						}
						break;
					
					default: // "x+" or else
						if (callback){ //有回调（必须setInterval）
							let dx = this.size[0].x;
							let loadBlock_id = setInterval(()=>{
								if (dx > this.size[1].x){
									clearInterval(loadBlock_id);
									
									if (this.activeBlock.every(function(value, index, arr){
										return value[0] != x || value[1] != z;
									})) //每个都不一样（不存在）
										this.activeBlock.push([x,z]);
									
									callback();
									return;
								}
								
								//正常代码
								for (let dz=this.size[0].z; dz<=this.size[1].z; dz++){
									this.loadColumn(ox+dx, oz+dz, edit);
								}
								
								dx++;
							},0);
						}else{ //无回调（不分顺序）
							if (this.activeBlock.every(function(value, index, arr){
								return value[0] != x || value[1] != z;
							})) //每个都不一样（不存在）
								this.activeBlock.push([x,z]);
							
							for (let dx=this.size[0].x; dx<=this.size[1].x; dx++){
								setTimeout(()=>{
									//正常代码
									for (let dz=this.size[0].z; dz<=this.size[1].z; dz++){
										this.loadColumn(ox+dx, oz+dz, edit);
									}
								},0);
							}
						}
						break;
						
				}
				
			}
		)
	};
	
	//卸载区块（同步）
	this.unloadBlock = (x, z)=>{
		[x, z] = [x, z].map(Math.round); //规范化
		let ox = x*this.size.x,
			oz = z*this.size.z; //区块中心坐标
		
		for (let i in this.activeBlock)
			if (this.activeBlock[i][0] == x && this.activeBlock[i][1] == z)
				this.activeBlock.splice(i,1); //从i开始删除一个元素
		for (let i in this.initedBlock)
			if (this.initedBlock[i][0] == x && this.initedBlock[i][1] == z)
				this.initedBlock.splice(i,1); //从i开始删除一个元素
		
		for (let dx=this.size[0].x; dx<=this.size[1].x; dx++){
			for (let dy=this.size[0].y; dy<=this.size[1].y; dy++){
				for (let dz=this.size[0].z; dz<=this.size[1].z; dz++){
					if (ox+dx == 24){
						//
					};
					if (this.map[ox+dx][dy][oz+dz] != null){
						for (let i of this.map[ox+dx][dy][oz+dz].block.mesh.material)
							i.dispose();
						this.map[ox+dx][dy][oz+dz].block.mesh.geometry.dispose(); //清除内存
						scene.remove(this.map[ox+dx][dy][oz+dz].block.mesh);
					}
					delete this.map[ox+dx][dy][oz+dz];
				}
			}
		}
	};
	//卸载区块（异步）
	this.unloadBlockAsync = (x, z, callback)=>{
		[x, z] = [x, z].map(Math.round); //规范化
		let ox = x*this.size.x,
			oz = z*this.size.z; //区块中心坐标
		
		for (let i in this.activeBlock)
			if (this.activeBlock[i][0] == x && this.activeBlock[i][1] == z)
				this.activeBlock.splice(i,1); //从i开始删除一个元素
		for (let i in this.initedBlock)
			if (this.initedBlock[i][0] == x && this.initedBlock[i][1] == z)
				this.initedBlock.splice(i,1); //从i开始删除一个元素
		
		if (callback){ //有回调（必须setInterval）
			let dx = this.size[0].x;
			let unloadBlock_id = setInterval(()=>{
				if (dx > this.size[1].x){
					clearInterval(unloadBlock_id);
					callback();
					return;
				}
				
				//正常代码
				for (let dy=this.size[0].y; dy<=this.size[1].y; dy++){
					for (let dz=this.size[0].z; dz<=this.size[1].z; dz++){
						if (this.map[ox+dx][dy][oz+dz] != null){ //非空气
							for (let i of this.map[ox+dx][dy][oz+dz].block.mesh.material)
								i.dispose();
							this.map[ox+dx][dy][oz+dz].block.mesh.geometry.dispose(); //清除内存
							scene.remove(this.map[ox+dx][dy][oz+dz].block.mesh);
						}
						delete this.map[ox+dx][dy][oz+dz];
					}
				}
				
				dx++;
			},0);
		}else{ //无回调（不分顺序）
			for (let dx=this.size[0].x; dx<=this.size[1].x; dx++){
				setTimeout(()=>{
					
					//正常代码
					for (let dy=this.size[0].y; dy<=this.size[1].y; dy++){
						for (let dz=this.size[0].z; dz<=this.size[1].z; dz++){
							if (this.map[ox+dx][dy][oz+dz]){ //非空气 & 非未加载
								for (let i of this.map[ox+dx][dy][oz+dz].block.mesh.material)
									i.dispose();
								this.map[ox+dx][dy][oz+dz].block.mesh.geometry.dispose(); //清除内存
								scene.remove(this.map[ox+dx][dy][oz+dz].block.mesh);
							}
							delete this.map[ox+dx][dy][oz+dz];
						}
					}
					
				},0);
			}
		}
	};
	
	//预加载区块
	this.perloadBlock = (length = this.perloadLength)=>{
		let block = [];
		for (let x=-1; x<=1; x++){
			for (let z=-1; z<=1; z++){
				let push = [
					Math.round((deskgood.pos.x + x*length)/100/map.size.x),
					Math.round((deskgood.pos.z + z*length)/100/map.size.z),
					(
						x>0 & z>0?
							(Math.random()<0.5?
								"x+1":"z+1"):
						x>0 & z<0?
							(Math.random()<0.5?
								"x+1":"z+1"):
						x<0 & z>0?
							(Math.random()<0.5?
								"x-1":"z+1"):
						x<0 & z<0?
							(Math.random()<0.5?
								"x-1":"z-1"):
						x > 0? "x+2":
						x < 0? "x-2":
						z > 0? "z+2":
						z < 0? "z-2":
						Math.random()<0.5?
							(Math.random()<0.5?
								"x+0":"x-0")
							:
							(Math.random()<0.5?
								"z+0":"z-0")
					)
				];
				let find = false;
				for (let i in block){
					if (block[i][0] == push[0] && block[i][1] == push[1]){ //相同
						if (Number(block[i][2].slice(-1)) <= Number(push[2].slice(-1))){
							block[i] = push;
							find = true;
							break;
						}
					}
				}
				if (!find)
					block.push(push);
			}
		}
		for (let i in block){
			if (this.initedBlock.every(function(value, index, arr){
				return value[0] != block[i][0] || value[1] != block[i][1];
			})){ //每个都不一样（不存在 & 不在加载中）
				this.initBlock(block[i][0], block[i][1]);
				this.loadBlockAsync(...block[i], ()=>{
					this.updateBlockAsync(block[i][0], block[i][1]); //更新区块
				}); //用噪声填充区块
			}
		}
		
		for (let i of this.activeBlock)
			if (
				(i[0] != 0 || i[1] != 0)&&
				block.every((value, index, arr)=>{
					return i[0] != value[0] || i[1] != value[1];
				}) //不与任何block相等
			)
				this.unloadBlockAsync(...i); //卸载区块
	};
	
	/* //保存为数组字符串
	this.save = ()=>{
		let arr = [];
		for (let x=this.size[0].x; x<=this.size[1].x; x++){
			for (let y=this.size[0].y; y<=this.size[1].y; y++){
				for (let z=this.size[0].z; z<=this.size[1].z; z++){
					arr.push(this.map[x][y][z]);
				}
			}
		}
		return JSON.stringify(arr);
		//localStorage.setItem("我的世界.存档.方块", JSON.stringify(arr));
	};
	//加载保存的数组字符串
	this.useSave = (arr)=>{
		//let arr = JSON.parse(localStorage.getItem("我的世界.存档.方块"));
		let index = 0;
		for (let x=this.size[0].x; x<=this.size[1].x; x++){
			for (let y=this.size[0].y; y<=this.size[1].y; y++){
				for (let z=this.size[0].z; z<=this.size[1].z; z++){
					this.map[x][y][z] = arr[index++];
				}
			}
		}
	}; */
}

const face_url = [
	["side.png", "side.png", "up.png", "down.png", "side.png", "side.png"],
	["face.png", "face.png", "face.png", "face.png", "face.png", "face.png"]
];
const template = []; //模板
template.push(new Thing({
	id: 0,
	name: "空气"
}));
template.push(new Thing({
	id: 1,
	name: "命令方块",
	block: {
		face: face_url[0]
	}
}));
template.push(new Thing({
	id: 2,
	name: "草方块",
	block: {
		face: face_url[0]
	}
}));
template.push(new Thing({
	id: 3,
	name: "泥土",
	block: {
		face: face_url[1]
	}
}));
template.push(new Thing({
	id: 4,
	name: "原石",
	block: {
		face: face_url[1]
	}
}));
template.push(new Thing({
	id: 5,
	name: "石头",
	block: {
		face: face_url[1]
	}
}));
template.push(new Thing({
	id: 6,
	name: "沙子",
	block: {
		face: face_url[1]
	}
}));
template.push(new Thing({
	id: 7,
	name: "仙人掌",
	block: {
		face: face_url[0]
	}
}));
template.push(new Thing({
	id: 8,
	name: "橡木",
	block: {
		face: ["side.png", "side.png", "up_down.png", "up_down.png", "side.png", "side.png"],
	}
}));
template.push(new Thing({
	id: 9,
	name: "木板",
	block: {
		face: face_url[1]
	}
}));
template.push(new Thing({
	id: 10,
	name: "砖",
	block: {
		face: face_url[1]
	}
}));

if (localStorage.getItem("我的世界_seed") === null){
	location.href = "home.html";
	message("无法读取数据！<br/>请重新创建游戏", 3);
}
let map = new BlockMap([
	{x: -8, y: 0, z: -8},
	{x: 8, y: 64, z: 8}
],{
	seed: localStorage.getItem("我的世界_seed"),
	height: JSON.parse(localStorage.getItem("我的世界_height")) || {
		min: 1,
		max: 64,
		//ave: 10,
		q: 166,
		error:{
			min: -1,
			max: 1,
			q: 36
		}
	},
	scale: JSON.parse(localStorage.getItem("我的世界_scale")) || {
		min: 0.4,
		max: 0.1,
		q: 66,
		error:{
			min: -0.1,
			max: 0.1,
			q: 36
		}
	},
	type: {
		q: 166
	}
},300);
document.title = "我的世界:"+map.seed.seed||"读取数据失败";

/**
* 创建场景对象Scene
*/
let scene = new THREE.Scene();
scene.fog = new THREE.Fog("#fff", 0.01, 300*100);
//						 雾气颜色，近处的距离，远处的距离(66m)
let scene_folder = gui.addFolder("场景(scene)");
	scene_folder.add(scene.children, "length", 0, 10000).name("物体(object)个数").listen();
	scene_folder.add(map.seed, "seed").name("地图种子");
	let scene_fog_folder = scene_folder.addFolder("雾(fog)");
		scene_fog_folder.add(scene.fog, "far", 15*100, 1000*100, 100);
		scene_fog_folder.add(scene.fog, "near", 0.001, 10);
		scene_fog_folder.addColor(scene.fog, "color");
	let scene_block_folder = scene_folder.addFolder("区块(block)");
		scene_block_folder.add(map, "perloadLength", 1, 1000, 1).name("预加载范围/px");


/**
 * 天气(sprite精灵)
 */
weather = Math.random()<0.75? 0: Math.random()*Math.random()*Math.random()/300*1000;//Math.abs(1-(Math.log(Math.random()+0.003)+6)/6);
console.info(`降水概率:${weather}滴/s/m²`, `降水范围：地图有效区域（<x:${map.size[0].x}~${map.size[1].x}>*<z:${map.size[0].z}~${map.size[1].z}>）`);
let sprite_system = [],
	sprite_lastTime = null,
	sprite_material = new THREE.SpriteMaterial({
		// color: "#4c51a7", //设置精灵矩形区域颜色
		// rotation: Math.PI/180*45, //旋转精灵对象45度，弧度值
		map: new THREE.TextureLoader().load("img/rain.png"), //设置精灵纹理贴图
	});
setInterval(function(){
	if (sprite_lastTime == null)
		sprite_lastTime = new Date();
	let t = Math.round((new Date() - sprite_lastTime)/1000*map.size.x*map.size.z*weather);
	sprite_lastTime = new Date();
	
	if (stop)
		return;
	
	//雨滴降落
	for (let i=0; i<sprite_system.length; i++){
		sprite_system[i].position.y -= 10*1000*t/1000*(Math.random()*0.2+0.9); //10m/s //sprite_system[i].v*t/1000;
		if (map.get(
				sprite_system[i].position.x/100,
				sprite_system[i].position.y/100,
				sprite_system[i].position.z/100
			) //有方块
			||sprite_system[i].position.y < 0
		){
			sprite_system[i].material.dispose(); //清除内存
			scene.remove(sprite_system[i]);
			sprite_system.splice(i,1);
		}
	}
	
	while (t--){
		if (Math.random() <= weather){
			//创建精灵模型对象，不需要几何体geometry参数
			let sprite = new THREE.Sprite(sprite_material);
			scene.add(sprite);
			let pX = Math.random()*2000-1000, //[-1000,1000)
				pY = Math.random()*150*100+200*100, //[150m,200m)
				pZ = Math.random()*2000-1000; //[-1000,1000)
			
			sprite.position.set(pX, pY, pZ); //设置精灵位置
			//控制精灵大小，比如可视化中精灵大小表征数据大小
			sprite.scale.set(Math.random()*4+6, Math.random()*8+12, 1); //只需要设置x、y两个分量就可以 x:[6,10) y:[12,20)
			sprite_system.push(sprite);
		}
	}
}, 0);


let weather_folder = gui.addFolder("天气(weather)");
	weather_folder.add(window, "weather", 0, 1/300*1000, 1e-3).name("降水系数").onChange((value)=>{weather = Math.pow(value*300/1000,3)/300*1000});
	weather_folder.add(sprite_system, "length", 0, 1000, 1).name("雨滴(sprite)个数").listen();
	weather_folder.add({clean: function(){
		for (let i in sprite_system){
			scene.remove(sprite_system[i]);
		}
		sprite_system.splice(0, sprite_system.length);
	}},"clean").name("清空(clean)");


/**
* 创建网格模型
*/
// let block_geometry = new THREE.BoxGeometry(100, 100, 100);
// TextureLoader创建一个纹理加载器对象，可以加载图片作为几何体纹理
// let num = 0;
let perload_condition = 0;
let block_load = {
	i: 1,
	id: null
}
// for (let i=1; i<template.length; i++){
$("#schedule progress")[0].max = template.length;
block_load.id = setInterval(function(){
	for (let j=0; j<template[block_load.i].block.face.length; j++){
		template[block_load.i].block.setTexture(
			new THREE.TextureLoader()
				.load( template[block_load.i].block.face[j] ), j);
		//$("#schedule2").text( Math.round( (j+1)/6*100 *100)/100 );
	}
	
	//单个block加载完毕
	$("#schedule span").text( Math.round( block_load.i++/(template.length-1)*100 *100)/100 );
	$("#schedule progress")[0].value = block_load.i;
	//$("#schedule2").text(0);
	
	if (block_load.i >= template.length){ //所有block加载完毕
		clearInterval(block_load.id);
		delete block_load;
		$("#schedule header").text("载入方块中……");
		
		map.initBlock(0, 0); //初始化区块
		map.loadBlockAsync(0, 0, function(){
			map.updateBlockAsync(0, 0); //更新区块
			if (++perload_condition >= 2){
				map.perloadBlock();
			}
			console.log(perload_condition)
			$("#schedule span").text("100");
			$("#schedule progress")[0].value = template.length;
			setTimeout(function(){
				render(); //纹理贴图加载成功后，调用渲染函数执行渲染操作
				$("#schedule").remove();
			},0);
		}); //用噪声填充区块
	}
},0);

/* let textureLoader = new THREE.TextureLoader();
for (let i=1; i<template.length; i++){
	for (let j=0; j<6; j++){
		textureLoader.load(`./img/blocks/${i}/${template[i].block.face[j]}`, function (texture){
			template[i].block.setTexture(texture, j);
			
			if (template[i].block.texture.length < 6)
				return;
			for (let k=0; k<template[i].block.texture.length; k++)
				if (!template[i].block.texture[k])
					return;
			
			//单个block加载完毕
			//template[i].block.makeMaterial().block.deleteTexture();
			//template[i].block.makeMesh().deleteMaterial();
			$("#schedule2").text( Math.round(i/template.length*100*100)/100 );
			
			for (let k=1; k<template.length; k++)
				if (!template[k].block.texture/*material*//*)
					return;
			
			//所有block加载完毕
			$("#schedule_message").text("载入方块中……");
			$("#schedule1").text("50");
			if (localStorage.getItem("我的世界.存档.方块")){
				map.useSave( JSON.parse(localStorage.getItem("我的世界.存档.方块")) );
				console.log("achieve loading");
				$("#schedule1").text("100");
				//纹理贴图加载成功后，调用渲染函数执行渲染操作
				render();
				$("#schedule").remove();
			}else{ //初始化地形
				map.loadBlock(0, 0);
				map.initBlock(0, 0);
				
				$("#schedule1").text("100");
				//纹理贴图加载成功后，调用渲染函数执行渲染操作
				render();
				$("#schedule").remove();
				/*let load = {
					x: null,
					loop: null
				}
				load.x = map.size[0].x;
				load.loop = setInterval(function (){
					for (let y=map.size[0].y; y<=map.size[1].y; y++){
						for (let z=map.size[0].z; z<=map.size[1].z; z++){
							let id = 0;
							if (y == 0){
								id = 3;
							}else if (y == 1){
								if (load.x < 0){
									id = 1;
								}else if (load.x > 6){
									id = 2;
								}else{
									id = 4;
								}
							}else if (y < 6){
								id = 6;
							}
							if (id != 0)
								map.add(new Thing(template[id]).block.makeMaterial().block.deleteTexture().block.makeMesh(), {x:load.x, y, z}); //以模板建立
								//map.update(load.x ,y ,z); //刷新是否添加方块
								// template[id].block.deleteMesh();
						}
					}
					
					$("#schedule2").text( Math.round((load.x-map.size[0].x)/map.size.x*100*100)/100 );
					
					console.log("finish loading:", load.x);
					if (++load.x > map.size[1].x){
						console.log("achieve loading");
						map.updateAll();
						$("#schedule1").text("100");
						//纹理贴图加载成功后，调用渲染函数执行渲染操作
						render();
						$("#schedule").remove();
						clearInterval(load.loop);
						/* delete load.loop;
						delete load.x; *//*
					}
				},0);*//*
			}
		});
	}
} */

/* let floor_geometry = new THREE.PlaneGeometry(1000, 1000, 6, 6);
let floor_material = new THREE.MeshBasicMaterial({ color:"#fff"});
//floor_material.wireframe = true; //仅框架
floor_mesh = new THREE.Mesh(floor_geometry, floor_material);
// 由于平地添加后默认是在正前方 所以需要旋转一下
floor_mesh.rotation.x = -0.5 * Math.PI;
floor_mesh.position.y = -10;
scene.add(floor_mesh); */


// 改变AxesHelper构造函数的参数，可以改变三维坐标轴的大小
// 参数设置坐标轴大小:1000
var axesHelper = new THREE.AxesHelper(1666);
scene.add(axesHelper);


/**
* 光源设置
*/

/*//点光源
let point = new THREE.PointLight(0xffffff);
point.position.set(0, 10*100, 0); //点光源位置
scene.add(point); //点光源添加到场景中*/
let scene_light_folder = scene_folder.addFolder("光源(light)");

//平行光
var directionalLight = new THREE.DirectionalLight("#fff", 1);
directionalLight.position.set(2, 1, 2);
directionalLight.castShadow = true;
directionalLight.onlyShadow = true;
directionalLight.shadow.mapSize.width = Math.pow(2, 10);  // default:512
directionalLight.shadow.mapSize.height = Math.pow(2, 10); // default:512
directionalLight.shadow.camera.near = 0.5;
directionalLight.shadow.camera.far = 200*100;
directionalLight.shadow.camera.left = -200*100;
directionalLight.shadow.camera.right = 200*100;
directionalLight.shadow.camera.top = 200*100;
directionalLight.shadow.camera.bottom = -200*100;
setTimeout(function(){
	message(
	`<font style="font-size:16px">`+
		`如果设备`+
			`<b>性能差</b>`+
			`，使用光影效果将会导致`+
			`<b>卡顿</b>。`+
			`<button onclick="directionalLight.castShadow=false;message('妈妈再也不用担心手机卡还发烫了（只担心画质丑的一批）',3);">`+
				`点此可关闭光影`+
			`</button>`+
		`</font>`, 5);
},1000);
/* document.addEventListener("plusready", function(){
	plus.nativeUI.toast(
		
		{
			type:"richtext",
			duration:"long",
			verticalAlign: "top",
			richTextStyle:{align:"center"}
		}
	);
}); */
scene.add(directionalLight);
// 光照指向平地
//directionalLight.target = ;
let scene_light_directionalLight_folder = scene_light_folder.addFolder("平行光(directionalLight)");
	scene_light_directionalLight_folder.add(directionalLight, "castShadow").name("阴影").listen();
	let scene_light_directionalLight_mapSize_folder = scene_light_directionalLight_folder.addFolder("阴影贴图大小(mapSize)");
		scene_light_directionalLight_mapSize_folder.add(directionalLight.shadow.mapSize, "width", Math.pow(2,9), Math.pow(2,12), Math.pow(2,9));
		scene_light_directionalLight_mapSize_folder.add(directionalLight.shadow.mapSize, "height", Math.pow(2,9), Math.pow(2,12), Math.pow(2,9));
	let scene_light_directionalLight_position_folder = scene_light_directionalLight_folder.addFolder("位置(position)");
		scene_light_directionalLight_position_folder.add(directionalLight.position, "x", -3, 3, 0.1);
		scene_light_directionalLight_position_folder.add(directionalLight.position, "y", -3, 3, 0.1);
		scene_light_directionalLight_position_folder.add(directionalLight.position, "z", -3, 3, 0.1);

//辅助线
//var directionalLight_CameraHelper = new THREE.CameraHelper(directionalLight.shadow.camera);
//scene.add(directionalLight_CameraHelper);

//户外光源
var hemiLight = new THREE.HemisphereLight("#87ceeb", "#f5deb3", 0.4/*"#aaf", "#888", 1*/);
hemiLight.position.set(0,500,0);
scene.add(hemiLight);

let scene_light_hemiLight_folder = scene_light_folder.addFolder("户外光源(hemiLight)");
	let scene_light_hemiLight_position_folder = scene_light_hemiLight_folder.addFolder("位置(position)");
		scene_light_hemiLight_position_folder.add(hemiLight.position, "x", -3, 3, 0.1);
		scene_light_hemiLight_position_folder.add(hemiLight.position, "y", -3, 3, 0.1);
		scene_light_hemiLight_position_folder.add(hemiLight.position, "z", -3, 3, 0.1);

//环境光
let ambient = new THREE.AmbientLight(0x444444);
scene.add(ambient);

let scene_light_ambient_folder = scene_light_folder.addFolder("环境光(ambient)");
	scene_light_ambient_folder.addColor(ambient, "color");

/**
* 相机设置
*/
/* let width = window.innerWidth; //窗口宽度
let height = window.innerHeight; //窗口高度
let k = width / height; //窗口宽高比
let s = 1000; //三维场景显示范围控制系数，系数越大，显示的范围越大
//创建相机对象
let camera = new THREE.OrthographicCamera(-s * k, s * k, s, -s, 1, 1000);
camera.position.set(0, 200, 0); //设置相机位置
camera.lookAt(scene.position); //设置相机方向(指向的场景对象) */

let WIDTH = window.innerWidth,
	HEIGHT = window.innerHeight;

var camera = new THREE.PerspectiveCamera(45, WIDTH/HEIGHT, 1, 1000*100);
//								 view_angle, aspect, near, far(1km)
camera.position.set(0, ( Math.floor(seed_height(map.seed.noise, map.seed.h, 0, 0))+2 )*100, 0); //设置相机位置
camera.lookAt(scene.position); //设置相机方向(指向的场景对象)
/*setTimeout(function(){
	console.info(camera);
},1000);*/

/**
* 创建渲染器对象
*/
let renderer = new THREE.WebGLRenderer();
renderer.setSize(WIDTH, HEIGHT);//设置渲染区域尺寸
renderer.setClearColor("#eef", 1); //设置背景颜色
renderer.domElement.style.margin = "0";
document.body.appendChild(renderer.domElement); //body元素中插入canvas对象
renderer.domElement.style.cursor = "none";
renderer.shadowMapEnabled = true; //阴影
//执行渲染操作   指定场景、相机作为参数
renderer.render(scene, camera);

renderer.color = {
	get clearColor(){
		return renderer.getClearColor();
	},
	set clearColor(value){
		console.log("set clear color:", value);
		renderer.setClearColor(
			"rgb("+
				Math.round(value.r)+","+
				Math.round(value.g)+","+
				Math.round(value.b)+
			")"
		, 1);
	}
};
let renderer_folder = gui.addFolder("渲染器(renderer)");
	renderer_folder.addColor(renderer.color, "clearColor");

window.onresize = function(){
	WIDTH = window.innerWidth;
	HEIGHT = window.innerHeight;
	renderer.setSize(window.innerWidth, window.innerHeight);
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix(); //更新投影矩阵
};


/**
* 背景
*/
function dateToNumber(h=0, m=0, s=0){
	return (s/60+m)/60+h;
}
//0~5:45	5:45	6:15		6:45~18:25	18:55		19:25		19:25~24
//天黑		日出(R)	日出(G,B)	白天		日落(G,B)	日落(R)		天黑
setTimeout(function(){
	let h = new Date();
	//h = (h.getSeconds()+h.getMilliseconds()/1000)/60*24
	h = h.getHours() + h.getMinutes()/60 + h.getSeconds()/3600;
	if (h > dateToNumber(19,25) | h < dateToNumber(5,45)){ // 天黑
		ambient.color = new THREE.Color("#223");
		//renderer.setClearColor("#334", 1);
	}else if (h > dateToNumber(18,25) | h < dateToNumber(6,45)){ // 日出/日落
		ambient.color = new THREE.Color("#f9a");
		//renderer.setClearColor("#a34", 1);
	}else{ //白天
		ambient.color = new THREE.Color("#aac");
		//renderer.setClearColor("#eef", 1);
	}
	renderer.setClearColor(
		"rgb("+
			Math.round(Math.min( 230/(1+Math.pow(6,-36/30*(h- dateToNumber(5,45) )))+10, 230-(230/(1+Math.pow(6,-36/30*(h- dateToNumber(19,25) ))))+10 ))+","+
			Math.round(Math.min( 230/(1+Math.pow(6,-36/30*(h- dateToNumber(6,15) )))+10, 230-(230/(1+Math.pow(6,-36/30*(h- dateToNumber(18,55) ))))+10 ))+","+
			Math.round(Math.min( 230/(1+Math.pow(6,-36/30*(h- dateToNumber(6,15) )))+20, 230-(230/(1+Math.pow(6,-36/30*(h- dateToNumber(18,55) ))))+20 ))+
		")"
	);
}, 0);
setInterval(function(){
	let h = new Date();
	// h = (h.getSeconds()+h.getMilliseconds()/1000)/60*24
	h = h.getHours() + h.getMinutes()/60 + h.getSeconds()/3600;
	if (h > dateToNumber(19,25) | h < dateToNumber(5,45)){ // 天黑
		ambient.color = new THREE.Color("#223");
		//renderer.setClearColor("#334", 1);
	}else if (h > dateToNumber(18,25) | h < dateToNumber(6,45)){ // 日出/日落
		ambient.color = new THREE.Color("#f9a");
		//renderer.setClearColor("#a34", 1);
	}else{ //白天
		ambient.color = new THREE.Color("#aac");
		//renderer.setClearColor("#eef", 1);
	}
	renderer.setClearColor(
		"rgb("+
			Math.round(Math.min( 230/(1+Math.pow(6,-36/30*(h- dateToNumber(5,45) )))+10, 230-(230/(1+Math.pow(6,-36/30*(h- dateToNumber(19,25) ))))+10 ))+","+
			Math.round(Math.min( 230/(1+Math.pow(6,-36/30*(h- dateToNumber(6,15) )))+10, 230-(230/(1+Math.pow(6,-36/30*(h- dateToNumber(18,55) ))))+10 ))+","+
			Math.round(Math.min( 230/(1+Math.pow(6,-36/30*(h- dateToNumber(6,15) )))+20, 230-(230/(1+Math.pow(6,-36/30*(h- dateToNumber(18,55) ))))+20 ))+
		")"
	);
	/*console.log(
		"time:"+h,
		"\nR:",
		230/(1+Math.pow(6,-36/30*(h- dateToNumber(5,45) )))+10, 230-(230/(1+Math.pow(6,-36/30*(h- dateToNumber(19,25) ))))+10,
		"\nG:",
		230/(1+Math.pow(6,-36/30*(h- dateToNumber(6,15) )))+10, 230-(230/(1+Math.pow(6,-36/30*(h- dateToNumber(18,55) ))))+10,
		"\nB:",
		230/(1+Math.pow(6,-36/30*(h- dateToNumber(6,15) )))+20, 230-(230/(1+Math.pow(6,-36/30*(h- dateToNumber(18,55) ))))+20,
		"\nRESULT:",
		"rgb("+
			Math.round(Math.min( 230/(1+Math.pow(6,-36/30*(h- dateToNumber(5,45) )))+10, 230-(230/(1+Math.pow(6,-36/30*(h- dateToNumber(19,25) ))))+10 ))+","+
			Math.round(Math.min( 230/(1+Math.pow(6,-36/30*(h- dateToNumber(6,15) )))+10, 230-(230/(1+Math.pow(6,-36/30*(h- dateToNumber(18,55) ))))+10 ))+","+
			Math.round(Math.min( 230/(1+Math.pow(6,-36/30*(h- dateToNumber(6,15) )))+20, 230-(230/(1+Math.pow(6,-36/30*(h- dateToNumber(18,55) ))))+20 ))+
		")"
	);*/
}, 5*1000); // 5s/次


/**
* stats
*/
let stats = new Stats();
stats.showPanel(0);
document.body.appendChild(stats.dom);


/**
* 玩家(deskgood)
*/
function ray(start, end, near, far){
	if (start.x === undefined) start.x = deskgood.pos.x;
	if (start.y === undefined) start.y = deskgood.pos.y;
	if (start.z === undefined) start.z = deskgood.pos.z;
	if (end.x === undefined) end.x = 0;
	if (end.y === undefined) end.y = 0;
	if (end.z === undefined) end.z = 0;
	/* if (!end.y)
		console.log("ray", start, end,far) */
	
	let ray = new THREE.Raycaster(
		new THREE.Vector3(start.x, start.y, start.z),
		new THREE.Vector3(end.x, end.y, end.z),
		near,
		far
	);
	ray.camera = camera;
	let objs = ray.intersectObjects(scene.children);
	return objs.filter(obj => obj.faceIndex !== null); //过滤
}

var deskgood = {
	v: {
		x: 0,
		y: 0,
		z: 0
	},
	pos: camera.position,
	/*size: {
		"x+": 50,
		"x-": 50,
		"y+": 50,
		"y-": 150,
		"z+": 50,
		"z-": 50
	},*/
	jump_v: 5,
	up: camera.up,
	lookAt: {
		left_right: 0,
		top_bottom: -10,
		/* _left_right: 0,
		_top_bottom: -10,
		get left_right(){
			return this._left_right;
		},
		set left_right(value){
			this._left_right = value;
			deskgood.look_refresh();
		},
		get top_bottom(){
			return this._top_bottom;
		},
		set top_bottom(value){
			this._top_bottom = value;
			deskgood.look_refresh();
		} */
	},
	look: {
		x: 1,
		y: 0,
		z: 0
	},
	tools: [0,0,0,0],
	choice: 0,
	sensitivity: 1, //灵敏度
	die(reason){
		sql.deleteTable("file", undefined, function(){
			localStorage.removeItem("我的世界_seed");
			
			alert(
				"游戏结束！\n"+
				"角色deskgood死亡\n"+
				"死因："+(reason || "无从考证")+"\n"+
				"注：生命诚可贵，生命只有一次，请珍爱生命，deskgood无法重生，游戏即将关闭"
			);
			
			window.open("home.html", "_self").close();
			
			try{
				plus.runtime.quit();
			}catch(e){}
		});
	},
	tools_choice_refresh(){
		for (let i in deskgood.tools){
			$("#tools > img:eq("+i+")")
				.css("borderColor", (i==deskgood.choice)?"#fff":"#aaa")
				.css("borderWidth", (i==deskgood.choice)?"6px":"3px");
		}
	},
	tools_things_refresh(){
		for (let i in deskgood.tools)
			$("#tools > img")[i].src =
				deskgood.tools[i] == 0?
					"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8/AwAI/AL+eMSysAAAAABJRU5ErkJggg==" //透明图片
				:
					template[ deskgood.tools[i] ].block.face[0]
			;
	},
	look_refresh(x,y,z){
		if (x != undefined | y != undefined | z != undefined){
			[x,y,z] = [x||deskgood.look.x, y||deskgood.look.y, z||deskgood.look.z];
			let v = new THREE.Vector3(x,y,z).setLength(1); //单位向量（标准化）
			camera.lookAt(deskgood.pos.x+v.x, deskgood.pos.y+v.y, deskgood.pos.z+v.z);
			[deskgood.look.x, deskgood.look.y, deskgood.look.z] = [v.x, v.y, v.z];
		}else{
			let x =
				Math.cos(deskgood.lookAt.left_right/180*Math.PI)*
				Math.cos(deskgood.lookAt.top_bottom/180*Math.PI)
			;
			let z =
				Math.sin(deskgood.lookAt.left_right/180*Math.PI)*
				Math.cos(deskgood.lookAt.top_bottom/180*Math.PI)
			;
			let y = Math.sin(deskgood.lookAt.top_bottom/180*Math.PI);
			camera.lookAt(deskgood.pos.x+x, deskgood.pos.y+y, deskgood.pos.z+z);
			[deskgood.look.x, deskgood.look.y, deskgood.look.z] = [x,y,z];
		}
	},
	move (x=deskgood.pos.x, y=deskgood.pos.y, z=deskgood.pos.z){
		/*[x, z] = [x, z].map(
			value => value+(0.1*Math.random()-0.05)
		); //随机化*/
		
		try{
			if (
				/*map.map[Math.round(x/100)]
					[Math.round(y/100)]
					[Math.round(z/100)]
				!== undefined
				&&*/
				map.initedBlock.some((item, index, value)=>{
					return item[0] == Math.round(x/100/map.size.x) &&
						item[1] == Math.round(z/100/map.size.z);
				}) //含有（已加载和加载中的区块）
				&&
				map.get(x/100, y/100, z/100) !== false
			){
				let t = deskgood.pos.x == x && deskgood.pos.z == z; //未改变区块
				[deskgood.pos.x, deskgood.pos.y, deskgood.pos.z] = [x,y,z];
				if (!t) map.perloadBlock();
			}else{
				throw "";
			}
		}catch(err){
			/* 未加载区块，禁止进入 */
			message(`<font style="font-size: 16px;">区块暂未加载完成，禁止进入<br/>（想加载快可以调节区块预加载范围，只要不卡死就行）</font>`, 1);
		}
	},
	go (x=0, y=0, z=0){
		[x, y, z] = [x, y, z].map(
			value => value*(Math.random()*0.2+0.9)
		); //随机化
		
		let rt = [0,0,0]; //返回值
		//X
		if (x > 0){
			//上半身
			let objs = ray(
				{x: deskgood.pos.x-50},
				{x: 1},
				0,
				x+60
			);
			if (objs.length){ //被阻挡
				let fx = Math.min(...objs.map(v => v.point.x))-10; //获取碰撞点，计算移动位置
				rt[0] = fx-(deskgood.pos.x+x);
				deskgood.moveX(fx);
				console.log("x+ 上 碰撞",x, objs, objs.map(v => v.object.position), objs.map(v => v.point.x), fx, rt[0])
			}else{ //无阻挡
				deskgood.moveX(deskgood.pos.x+x);
			}
			//下半身
			objs = ray(
				{x: deskgood.pos.x-50, y: deskgood.pos.y-100},
				{x: 1},
				0,
				x+60
			);
			if (objs.length){ //被阻挡
				let fx = Math.min(...objs.map(v => v.point.x))-10; //获取碰撞点，计算移动位置
				rt[0] = fx-(deskgood.pos.x+x);
				deskgood.moveX(fx);
				console.log("x+ 下 碰撞",x, objs, objs.map(v => v.object.position), objs.map(v => v.point.x), fx, rt[0])
			}else{ //无阻挡
				deskgood.moveX(deskgood.pos.x+x);
			}
		}else if (x < 0){
			//上半身
			let objs = ray(
				{x: deskgood.pos.x+50},
				{x: -1},
				0,
				-x+60
			);
			if (objs.length){ //被阻挡
				let fx = Math.max(...objs.map(v => v.point.x))+10; //获取碰撞点，计算移动位置
				rt[0] = fx-(deskgood.pos.x+x);
				deskgood.moveX(fx);
				console.log("x- 上 碰撞",x, objs, objs.map(v => v.object.position), objs.map(v => v.point.x), fx, rt[0])
			}else{ //无阻挡
				deskgood.moveX(deskgood.pos.x+x);
				// console.log("x- 上 无碰撞",x)
			}
			//下半身
			objs = ray(
				{x: deskgood.pos.x+50, y: deskgood.pos.y-100},
				{x: -1},
				0,
				-x+60
			);
			if (objs.length){ //被阻挡
				let fx = Math.max(...objs.map(v => v.point.x))+10; //获取碰撞点，计算移动位置
				rt[0] = fx-(deskgood.pos.x+x);
				deskgood.moveX(fx);
				console.log("x- 下 碰撞",x, objs, objs.map(v => v.object.position), objs.map(v => v.point.x), fx, rt[0])
			}else{ //无阻挡
				deskgood.moveX(deskgood.pos.x+x);
				// console.log("x- 下 无碰撞",x)
			}
		}
		
		//Y
		if (y > 0){ //上
			let objs = ray(
				{y: deskgood.pos.y+50},
				{y: 1},
				0,
				y
			);
			if (objs.length){ //被阻挡
				/*let fy = Math.min(...ray(
					{y: deskgood.pos.y+50},
					{y: 1}
				).map(v => v.point.y))-50;*/
				let fy = Math.min(...objs.map(v => v.point.y))-50; //获取碰撞点，计算移动位置
				rt[1] = fy-(deskgood.pos.y+y);
				deskgood.moveY(fy);
			}else{ //无阻挡
				deskgood.moveY(deskgood.pos.y+y);
			}
		}else if (y < 0){ //下
			let objs = ray(
				{y: deskgood.pos.y-150},
				{y: -1},
				0,
				-y
			);
			if (objs.length){ //被阻挡
				/*let fy = Math.max(...ray(
					{y: deskgood.pos.y-150},
					{y: -1}
				).map(v => v.point.y))+150;*/
				let fy = Math.max(...objs.map(v => v.point.y))+150; //获取碰撞点，计算移动位置
				rt[1] = fy-(deskgood.pos.y+y);
				deskgood.moveY(fy);
			}else{ //无阻挡
				deskgood.moveY(deskgood.pos.y+y);
			}
		}
		
		//z
		if (z > 0){
			//上半身
			let objs = ray(
				{z: deskgood.pos.z-50},
				{z: 1},
				0,
				z+60
			);
			if (objs.length){ //被阻挡
				let fz = Math.min(...objs.map(v => v.point.z))-10; //获取碰撞点，计算移动位置
				rt[2] = fz-(deskgood.pos.z+z);
				deskgood.moveZ(fz);
				console.log("z+ 上 碰撞",z, objs, objs.map(v => v.object.position), objs.map(v => v.point.z), fz, rt[2])
			}else{ //无阻挡
				deskgood.moveZ(deskgood.pos.z+z);
			}
			//下半身
			objs = ray(
				{z: deskgood.pos.z-50, y: deskgood.pos.y-100},
				{z: 1},
				0,
				z+60
			);
			if (objs.length){ //被阻挡
				let fz = Math.min(...objs.map(v => v.point.z))-10; //获取碰撞点，计算移动位置
				rt[2] = fz-(deskgood.pos.z+z);
				deskgood.moveZ(fz);
				console.log("z+ 下 碰撞",z, objs, objs.map(v => v.object.position), objs.map(v => v.point.z), fz, rt[2])
			}else{ //无阻挡
				deskgood.moveZ(deskgood.pos.z+z);
			}
		}else if (z < 0){
			//上半身
			let objs = ray(
				{z: deskgood.pos.z+50},
				{z: -1},
				0,
				-z+60
			);
			if (objs.length){ //被阻挡
				let fz = Math.max(...objs.map(v => v.point.z))+10; //获取碰撞点，计算移动位置
				rt[2] = fz-(deskgood.pos.z+z);
				deskgood.moveZ(fz);
				console.log("z- 上 碰撞",z, objs, objs.map(v => v.object.position), objs.map(v => v.point.z), fz, rt[2])
			}else{ //无阻挡
				deskgood.moveZ(deskgood.pos.z+z);
				// console.log("z- 上 无碰撞",z)
			}
			//下半身
			objs = ray(
				{z: deskgood.pos.z+50, y: deskgood.pos.y-100},
				{z: -1},
				0,
				-z+60
			);
			if (objs.length){ //被阻挡
				let fz = Math.max(...objs.map(v => v.point.z))+10; //获取碰撞点，计算移动位置
				rt[2] = fz-(deskgood.pos.z+z);
				deskgood.moveZ(fz);
				console.log("z- 下 碰撞",z, objs, objs.map(v => v.object.position), objs.map(v => v.point.z), fz, rt[2])
			}else{ //无阻挡
				deskgood.moveZ(deskgood.pos.z+z);
				// console.log("z- 下 无碰撞",z)
			}
		}
		
		return rt;
		
		/*if (x & z)
			console.log(x,y,z);
		
		let rt = [false, false, false];
		//x
		if (x > 0){ //向前
			for (var i=deskgood.pos.x; i<=deskgood.pos.x+x; i+=dx){
				if (map.get(i/100,
						deskgood.pos.y/100,
						deskgood.pos.z/100)
					!=
						null
				){
					rt[0] = true;
					console.log("撞到脸，s:"+((deskgood.pos.x+x)-i));
					break;
				}
				if (map.get((i+10)/100,
						deskgood.pos.y/100-1,
						deskgood.pos.z/100)
					!=
						null
				){
					rt[0] = true;
					console.log("撞到脚，s:"+((deskgood.pos.x+x)-i));
					break;
				}
			}
			deskgood.pos.x = i;
		}else if (x < 0){ //向后
			for (var i=deskgood.pos.x; i>=deskgood.pos.x+x; i-=dx){
				if (map.get((i-10)/100,
						deskgood.pos.y/100,
						deskgood.pos.z/100)
					!=
						null
				){
					rt[0] = true;
					console.log("撞到后脑，s:"+(i-(deskgood.pos.x+x)));
					break;
				}
				if (map.get((i-10)/100,
						deskgood.pos.y/100-1,
						deskgood.pos.z/100)
					!=
						null
				){
					rt[0] = true;
					console.log("撞到脚，s:"+(i-(deskgood.pos.x+x)));
					break;
				}
			}
			deskgood.pos.x = i;
		}
		//y
		if (y > 0){ //向上
			for (var j=deskgood.pos.y; j<=deskgood.pos.y+y; j+=dy){
				if (map.get(deskgood.pos.x/100,
						j/100,
						deskgood.pos.z/100)
					!=
						null
				){
					rt[1] = true;
					let s = (deskgood.pos.y-150+y)-j;
					if (s)
						console.log("撞到天花板，s:", s);
					break;
				}
			}
			deskgood.pos.y = j;
		}else if (y < 0){ //向下
			for (var j=deskgood.pos.y-150; j>=deskgood.pos.y-150+y; j-=dy){
				if (map.get(deskgood.pos.x/100,
						j/100,
						deskgood.pos.z/100)
					!=
						null
				){
					rt[1] = true;
					let s = j-(deskgood.pos.y-150+y);
					if (s)
						// console.log("撞到地面，s:", s);
					break;
				}
			}
			deskgood.pos.y = j+150;
		}
		
		//z
		if (z > 0){ //向右
			for (var k=deskgood.pos.z; k<=deskgood.pos.z+z; k+=dz){
				if (map.get((k+10)/100,
						deskgood.pos.y/100,
						deskgood.pos.z/100)
					!=
						null
				){
					rt[2] = true;
					console.log("撞到头，s:"+((deskgood.pos.z+z)-i));
					break;
				}
				if (map.get((k+10)/100,
						deskgood.pos.y/100-1,
						deskgood.pos.z/100)
					!=
						null
				){
					rt[2] = true;
					console.log("撞到腿，s:"+((deskgood.pos.z+z)-k));
					break;
				}
			}
			deskgood.pos.z = k;
		}else if (z < 0){ //向左
			for (var k=deskgood.pos.z; k>=deskgood.pos.z+z; k-=dz){
				if (map.get((k-10)/100,
						deskgood.pos.y/100,
						deskgood.pos.z/100)
					!=
						null
				){
					rt[2] = true;
					console.log("撞到头，s:"+(k-(deskgood.pos.z+z)));
					break;
				}
				if (map.get((k-10)/100,
						deskgood.pos.y/100-1,
						deskgood.pos.z/100)
					!=
						null
				){
					rt[2] = true;
					console.log("撞到腿，s:"+(k-(deskgood.pos.z+z)));
					break;
				}
			}
			deskgood.pos.z = k;
		}
		return rt;*/
	}
}
deskgood.moveTo = deskgood.move;
deskgood.moveX = x=>deskgood.move(x);
deskgood.moveY = y=>deskgood.move(undefined, y);
deskgood.moveZ = z=>deskgood.move(undefined, undefined, z);
deskgood.goX = x=>deskgood.go(x);
deskgood.goY = y=>deskgood.go(0,y);
deskgood.goZ = z=>deskgood.go(0,0,z);


// SQL
const sql = new SQL("Minecraft", "1.0", "我的世界游戏存档", 10*1024*1024);
sql.setErrCallback(function(err){
	console.error("SQL运行出错：", err, err.message);
	alert("存档 读取/写入 错误");
});
sql.createTable("file", [
	"type UNSIGNED TINYINT",
	"x INT",
	"y INT",
	"z INT",
	"id UNSIGNED TINYINT",
	"attr TEXT"
]);
sql.selectData("file", ["x", "y", "z", "id", "attr"], "type=1", function(result){
	if (result.length){
		deskgood.pos.x = result[0].x;
		deskgood.pos.y = result[0].y;
		deskgood.pos.z = result[0].z;
		deskgood.sensitivity = result[0].id;
		[deskgood.lookAt.left_right, deskgood.lookAt.top_bottom] = result[0].attr.split(" ").map(Number);
		deskgood.look_refresh();
		if (++perload_condition >= 2){
			map.perloadBlock();
		}
		console.log(perload_condition)
	}
});
sql.selectData("file", ["x", "y", "z"], "type=2", function(result){
	if (result.length){
		deskgood.v.x = result[0].x;
		deskgood.v.y = result[0].y;
		deskgood.v.z = result[0].z;
	}
});
sql.selectData("file", ["id", "attr"], "type=3 AND x=0", function(result){ //物品栏
	if (result.length){
		for (let i in deskgood.tools){
			deskgood.tools[i] = result[i].id;
			//...
		}
		deskgood.tools_things_refresh();
	}
});
sql.selectData("file", ["id"], "type=3 AND x=1", function(result){ //选择物品
	if (result.length){
		deskgood.choice = result[0].id;
		deskgood.tools_choice_refresh();
	}
});
function save(){
	sql.deleteData("file", "type=1", undefined, function(){
		sql.insertData("file", ["type", "x", "y", "z", "id", "attr"], [
			1,
			Math.round(deskgood.pos.x),
			Math.round(deskgood.pos.y),
			Math.round(deskgood.pos.z),
			deskgood.sensitivity,
			`"${deskgood.lookAt.left_right} ${deskgood.lookAt.top_bottom}"`
		]);
	});
	sql.deleteData("file", "type=2", undefined, function(){
		sql.insertData("file", ["type", "x", "y", "z"], [
			2,
			Math.round(deskgood.v.x),
			Math.round(deskgood.v.y),
			Math.round(deskgood.v.z)
		]);
	});
	sql.deleteData("file", "type=3", undefined, function(){
		for (let i of deskgood.tools){
			sql.insertData("file", ["type", "x", "id", "attr"], [
				3,
				0, //物品栏
				i,
				`""` //...
			]);
		}
		sql.insertData("file", ["type", "x", "id"], [
			3,
			1, //选择物品
			deskgood.choice
		]);
	});
	
	console.log("存档+1中……");
	// return;
	/* localStorage.setItem("我的世界.存档.方块", map.save());
	localStorage.setItem("我的世界.存档.玩家.位置", JSON.stringify(deskgood.pos));
	localStorage.setItem("我的世界.存档.玩家.朝向", JSON.stringify(deskgood.lookAt));
	localStorage.setItem("我的世界.存档.玩家.物品.工具栏", JSON.stringify({
		tools: deskgood.tools,
		choice: deskgood.choice
	}));
	console.log("备份成功"); */
}
setInterval(save, 10*1000); // 10s

/* //读取
if (localStorage.getItem("我的世界.存档.玩家.位置")){
	deskgood.pos.x = JSON.parse(localStorage.getItem("我的世界.存档.玩家.位置")).x;
	deskgood.pos.y = JSON.parse(localStorage.getItem("我的世界.存档.玩家.位置")).y;
	deskgood.pos.z = JSON.parse(localStorage.getItem("我的世界.存档.玩家.位置")).z;
}
if (localStorage.getItem("我的世界.存档.玩家.朝向")){
	deskgood.lookAt.left_right = JSON.parse(localStorage.getItem("我的世界.存档.玩家.朝向")).left_right;
	deskgood.lookAt.top_bottom = JSON.parse(localStorage.getItem("我的世界.存档.玩家.朝向")).top_bottom;
}
if (localStorage.getItem("我的世界.存档.玩家.物品.工具栏")){
	deskgood.tools = JSON.parse(localStorage.getItem("我的世界.存档.玩家.物品.工具栏")).tools;
	deskgood.choice = Number(JSON.parse(localStorage.getItem("我的世界.存档.玩家.物品.工具栏")).choice);
} */

for (let i in deskgood.tools){
	/* if (deskgood.tools[i] != 0){
		$("#tools > img")[i].src = "./img/blocks/"+deskgood.tools[i]+"/"+template[deskgood.tools[i]].face[0];
	} */
	$("#tools > img")[i].onclick = ()=>{
		deskgood.choice = i;
		deskgood.tools_choice_refresh();
	};
}

//初始化
deskgood.tools_choice_refresh();
deskgood.tools_things_refresh();
deskgood.look_refresh();

//gui
let deskgood_folder = gui.addFolder("玩家/观察者(deskgood)");
deskgood_folder.open();
	deskgood_folder.add(window, "stop").listen();
	deskgood_folder.add({
		f(){deskgood.die("使用命令自杀")}
	}, "f").name("Game Over（自杀 deskgood.die()）");
	deskgood_folder.add(deskgood, "sensitivity", 0.1, 10).name("灵敏度");
	deskgood_folder.add(deskgood, "jump_v", 1, 10).name("跳跃速度");
	let deskgood_position_folder = deskgood_folder.addFolder("位置/px");
	deskgood_position_folder.open();
		deskgood_position_folder.add(deskgood.pos, "x", -1000, 1000, 0.01).listen();
		deskgood_position_folder.add(deskgood.pos, "y", -1000, 128*100, 0.01).listen();
		deskgood_position_folder.add(deskgood.pos, "z", -1000, 1000, 0.01).listen();
	let deskgood_v_folder = deskgood_folder.addFolder("速度/(m/s)");
		deskgood_v_folder.add(deskgood.v, "x", -10, 10, 1e-3).listen();
		deskgood_v_folder.add(deskgood.v, "y", -100, 100, 1e-3).listen().onChange((value) => {
			deskgood.v.y = Math.pow(Math.abs(value)/100,3)*100*value/Math.abs(value);
		});
		deskgood_v_folder.add(deskgood.v, "z", -10, 10, 1e-3).listen();
	let deskgood_lookAt_folder = deskgood_folder.addFolder("朝向（球坐标系）");
		deskgood_lookAt_folder.add(deskgood.lookAt, "left_right", 0, 360).listen().name("左右（水平）");
		deskgood_lookAt_folder.add(deskgood.lookAt, "top_bottom", -90, 90).listen().name("上下（竖直）");
	let deskgood_look_folder = deskgood_folder.addFolder("朝向（笛卡尔坐标系）");
		deskgood_look_folder.add(deskgood.look, "x", -1, 1, 0.01).listen().onChange(x => deskgood.look_refresh(x));
		deskgood_look_folder.add(deskgood.look, "y", -1, 1, 0.01).listen().onChange(y => deskgood.look_refresh(undefined, y));
		deskgood_look_folder.add(deskgood.look, "z", -1, 1, 0.01).listen().onChange(z => deskgood.look_refresh(undefined, undefined, z));
	let deskgood_up_folder = deskgood_folder.addFolder("天旋地转（小心头晕）");
		deskgood_up_folder.add(deskgood.up, "x", -1, 1, 0.01).onChange(function(){
			message("<font style='font-size: 16px;'>头晕别怪我</font>", 3);
			/* plus.nativeUI.toast(
				"<font size=\"16\">头晕别怪我</font>",
				{
					type: "richtext",
					verticalAlign: "top",
					richTextStyle: {align:"center"}
				}
			); }catch(err){} */
		});
		deskgood_up_folder.add(deskgood.up, "y", -1, 1, 0.01).onChange(function(){
			message("<font style='font-size: 16px;'>头晕别怪我</font>", 3);
				/* plus.nativeUI.toast(
					"<font size=\"16\">头晕别怪我</font>",
					{
						type: "richtext",
						verticalAlign: "top",
						richTextStyle: {align:"center"}
					}
				); }catch(err){} */
			});
		deskgood_up_folder.add(deskgood.up, "z", -1, 1, 0.01).onChange(function(){
			message("<font style='font-size: 16px;'>头晕别怪我</font>", 3);
				/* plus.nativeUI.toast(
					"<font size=\"16\">头晕别怪我</font>",
					{
						type: "richtext",
						verticalAlign: "top",
						richTextStyle: {align:"center"}
					}
				); }catch(err){} */
			});
	let deskgood_tools_folder = deskgood_folder.addFolder("工具栏(tools)");
	deskgood_tools_folder.open();
		deskgood_tools_folder.add(deskgood, "choice", 0, 3, 1).listen().name("选择工具").onChange(deskgood.tools_choice_refresh);
		let deskgood_tools_things_folder = deskgood_tools_folder.addFolder("物品");
		deskgood_tools_things_folder.open();
			deskgood_tools_things_folder.add(deskgood.tools, 0, 0, 9, 1).listen().onChange(deskgood.tools_things_refresh);
			deskgood_tools_things_folder.add(deskgood.tools, 1, 0, 9, 1).listen().onChange(deskgood.tools_things_refresh);
			deskgood_tools_things_folder.add(deskgood.tools, 2, 0, 9, 1).listen().onChange(deskgood.tools_things_refresh);
			deskgood_tools_things_folder.add(deskgood.tools, 3, 0, 9, 1).listen().onChange(deskgood.tools_things_refresh);


/* //多线程
let deskgood_worker = null;
if(deskgood_worker == null){
	deskgood_worker = new Worker("./js/deskgood.js");
}
deskgood_worker.postMessage([deskgood.pos, deskgood.v]);
deskgood_worker.onmessage = function(e){
	// deskgood.go(...e.data);
	// deskgood.pos.x = e.data[0].x;
	// deskgood.pos.y = e.data[0].y;
	// deskgood.pos.z = e.data[0].z;
	// deskgood.v.x = e.data[1].x;
	// deskgood.v.y = e.data[1].y;
	// deskgood.v.z = e.data[1].z;
}; */

let T0 = new Date();//上次时间
function render(){
	let t = new Date()-T0;//时间差
	T0 = new Date();//把本次时间赋值给上次时间
	requestAnimationFrame(render);
	renderer.render(scene, camera);//执行渲染操作
	
	let warn = [];
	try{
		if (map.get(deskgood.pos.x/100,
				deskgood.pos.y/100,
				deskgood.pos.z/100)
			!=
				null
		){ //头被卡住
			warn.push("头被卡住？");
			message("<font style='font-size: 16px;'>想窒息吗？还往头上放方块，看你怎么出来！</font>", 1);
			/* try{
				plus.nativeUI.toast(
					"<font size=\"16\">想窒息吗？还往头上放方块，看你怎么出来！</font>",
					{
						type:"richtext",
						verticalAlign: "top",
						richTextStyle:{align:"center"}
					}
				);
			}catch(err){} */
			/*setTimeout(function(){
				try{ plus.nativeUI.closeToast(); }catch(err){}
			},1);*/
		}
		if (map.get(deskgood.pos.x/100,
				deskgood.pos.y/100-1,
				deskgood.pos.z/100)
			!=
				null
		){ //脚被卡住
			warn.push("脚被卡住？");
		}
	}catch(err){}
	if (warn.length && !stop){
		if (!map.get(deskgood.pos.x/100,
			deskgood.pos.y/100,
			deskgood.pos.z/100
		) &&
		!map.get(deskgood.pos.x/100,
			deskgood.pos.y/100+1,
			deskgood.pos.z/100
		) &&
		+new Date()-last_jump >= 1000
		){
			last_jump = +new Date();
			deskgood.v.y += deskgood.jump_v*(Math.random()*0.2+0.9); //自动跳跃
		}
		
		if (warn[0] & warn[1]){
			console.warn(warn[0], warn[1]);
		}else{
			console.warn(warn[0]);
		}
	}
	
	if (!stop){
		let ρ = 1.25*(Math.random()*0.2+0.9), //空气密度/(kg/m³)
			c = 0.4*(Math.random()*0.2+0.9), //空气阻力系数
			s = [0.5, 0.2, 0.5], //面积/m²
			v = [deskgood.v.x, deskgood.v.y, deskgood.v.z], //速度/(m/s)
			Fw = [], //空气阻力/N
			m = 50, //质量/m
			Aw = [] //空气阻力产生的加速度/(m/s²)
		for (let i=0; i<3; i++){
			Fw[i] = (1/2) * c * ρ * s[i] * v[i]*v[i]; //F = (1/2)CρSV²
			Aw[i] = Fw[i] / m; //F=ma => a=F/m
		}
		
		deskgood.v.y -= 9.8*t/1000*(Math.random()*0.2+0.9); //重力加速度
		deskgood.v.x +=
			Math.abs(Aw[0]*t/1000) < Math.abs(deskgood.v.x)?
				Aw[0]*t/1000
			:
				-deskgood.v.x
		;
		deskgood.v.y +=
			Math.abs(Aw[1]*t/1000) < Math.abs(deskgood.v.y)?
				Aw[1]*t/1000
			:
				-deskgood.v.y
		;
		deskgood.v.z +=
			Math.abs(Aw[2]*t/1000) < Math.abs(deskgood.v.z)?
				Aw[2]*t/1000
			:
				-deskgood.v.z
		;
		//console.info("aw:",Aw, "Fw:",Fw, "v:", deskgood.v)
		
		let rt = deskgood.go(deskgood.v.x*100*t/1000, deskgood.v.y*100*t/1000, deskgood.v.z*100*t/1000);
		//					m/s*100*ms/1000 => cm/s*s => cm => px
		if (rt[0]) deskgood.v.x = 0;
		if (rt[1]) deskgood.v.y = 0;
		if (rt[2]) deskgood.v.x = 0;
	}
	
	
	stats.update();
}
// render();
// 间隔30ms周期性调用函数fun
//setInterval("render()",16.7)

/* let controls = new THREE.OrbitControls(camera,renderer.domElement);//创建控件对象
controls.addEventListener("change", render);//监听鼠标、键盘事件 */

function state(id, pointerLock){
	if ($("#"+id).css("display") != "none"){ //已显示
		$("#"+id).css("display", "none");
		stop = false;
		document.body.requestPointerLock();
		console.log(id, ":close");
	}else{ //未显示
		$("#"+id).css("display", "block");
		stop = id;
		document.exitPointerLock();
		console.log(id, ":open");
	}
	
	return;
}

let keydown = {
	key: new Set(),
	double_run: [],
	t0: null
};
document.addEventListener("keydown", function (e){
	if (e.keyCode == 69){ //E 切换背包
		if (stop == "bag" | stop == false){
			console.log("E:", keydown.key);
			state("bag");
			return false;
		}
	}
	if (e.keyCode == 27 & stop == "command"){ //ESC 退出命令方块
		state("command");
		return false;
	}
	
	if (stop){
		keydown.double_run = [];
		return false;
	}
	
	if (e.keyCode == 27){ //ESC 暂停游戏
		console.log("ESC:", keydown.key);
		
		stop = true;
		$("canvas:eq(0),#mouse").css("cursor", "default");
		save();
		document.exitPointerLock();
		
		return false;
	}
	if (e.keyCode == 121){ //F10 打开gui
		console.log("F10:", keydown.key);
		if (gui.closed){
			gui.open();
		}else{
			gui.close();
		}
		return false;
	}
	if (e.keyCode == 87 | e.keyCode == 38){
		if (keydown.double_run.length == 0){
			keydown.double_run[0] = +new Date();
		}else if (keydown.double_run.length == 2 && +new Date()-keydown.double_run[1] < 500){ //连按
			keydown.double_run = true;
			console.log("run");
		}
	}
	
	keydown.key.add(e.keyCode);
	
	return false;
});
document.addEventListener("keyup", function (e){
	keydown.key.delete(e.keyCode);
	
	if (e.keyCode == 87 | e.keyCode == 38){
		if (keydown.double_run.length == 1 && +new Date()-keydown.double_run[0] < 500){
			keydown.double_run[1] = +new Date();
		}else{
			keydown.double_run = [];
		}
	}
	return false;
});
let last_jump = +new Date()-1000;
setInterval(function(){
	if (stop){
		keydown.key = new Set();
		keydown.t0 = null;
		return;
	}
	let t;
	if (keydown.t0){
		t = +new Date()-keydown.t0;
		keydown.t0 = +new Date();
	}else{
		keydown.t0 = +new Date();
		return;
	}
	
	let x=0, y=0, z=0;
	
	if (keydown.key.size)
		console.log("keydown:", keydown.key);
	
	if ((keydown.key.has(87) | keydown.key.has(38)) & keydown.key.has(17)){ //control 按下
		keydown.double_run = true;
		console.log("run");
	}
	
	if (keydown.key.has(87) | keydown.key.has(38)){ //前
		console.log("front:", keydown.key);
		x += Math.cos( (deskgood.lookAt.left_right+0) /180*Math.PI) *(keydown.double_run==true?3:1) *(Math.random()*0.2+0.9);
		z += Math.sin( (deskgood.lookAt.left_right+0) /180*Math.PI) *(keydown.double_run==true?3:1) *(Math.random()*0.2+0.9);
	}
	if (keydown.key.has(83) | keydown.key.has(40)){ //后
		console.log("behind:", keydown.key);
		x += Math.cos( (deskgood.lookAt.left_right+180) /180*Math.PI) *(Math.random()*0.2+0.9);
		z += Math.sin( (deskgood.lookAt.left_right+180) /180*Math.PI) *(Math.random()*0.2+0.9);
	}
	if (keydown.key.has(65) | keydown.key.has(37)){ //左
		console.log("left:", keydown.key);
		x += Math.cos( (deskgood.lookAt.left_right-90) /180*Math.PI) *(Math.random()*0.2+0.9);
		z += Math.sin( (deskgood.lookAt.left_right-90) /180*Math.PI) *(Math.random()*0.2+0.9);
	}
	if (keydown.key.has(68) | keydown.key.has(39)){ //右
		console.log("right:", keydown.key);
		x += Math.cos( (deskgood.lookAt.left_right+90) /180*Math.PI) *(Math.random()*0.2+0.9);
		z += Math.sin( (deskgood.lookAt.left_right+90) /180*Math.PI) *(Math.random()*0.2+0.9);
	}
	if (keydown.key.has(32)){ //上
		console.log("up:", keydown.key);
		y += 1*(Math.random()*0.2+0.9);
	}
	if (keydown.key.has(16)){ //下
		console.log("down:", keydown.key);
		y += -1*(Math.random()*0.2+0.9);
	}
	
	/* x = x*10 + (x>0? 10: x<0? -10: 0);
	z = z*10 + (z>0? 10: z<0? -10: 0);
	
	try{
		if (
			map.get((deskgood.pos.x+x)/100,
				deskgood.pos.y/100,
				deskgood.pos.z/100)
			!=
				null
		){ //无法向X移动
			x = 0;
		}
	}catch(err){}
	try{
		if (map.get((deskgood.pos.x+x)/100,
				deskgood.pos.y/100-1,
				deskgood.pos.z/100)
			!=
				null
		){ //无法向X移动
			x = 0;
		}
	}catch(err){}
	
	try{
		if (map.get(deskgood.pos.x/100,
				deskgood.pos.y/100,
				(deskgood.pos.z+z)/100)
			!=
				null
		){ //无法向Z移动
			z = 0;
		}
	}catch(err){}
	try{
		if (map.get(
				deskgood.pos.x/100,
				deskgood.pos.y/100-1,
				(deskgood.pos.z+z)/100)
			!=
				null
		){ //无法向Z移动
			z = 0;
		}
	}catch(err){}
	
	x -= (x>0? 10: x<0? -10: 0);
	z -= (z>0? 10: z<0? -10: 0);
	
	deskgood.pos.x += x*(Math.random()*0.2+0.9);
	deskgood.pos.z += z*(Math.random()*0.2+0.9); */
	
	if (x && z)
		console.log("go",x,z);
	
	if (x || y || z)
		deskgood.go(x*t*0.1, 0, z*t*0.1); // 1m/s = 100px/s = 0.1px/ms
	
	try{
		if (map.get(deskgood.pos.x/100,
				deskgood.pos.y/100-1.6,
				deskgood.pos.z/100)
			!=
				null
		){ //脚下有方块
			if (+new Date()-last_jump >= 1000 & y != 0){
				console.log("jump");
				deskgood.v.y += y * deskgood.jump_v*(Math.random()*0.2+0.9);
				last_jump = +new Date();
			}
		}
	}catch(err){}
}, 16.667);


let mouse_choice = {
	view: false,
	obj: [],
	x: -1,
	y: -1,
	z: -1,
	faceIndex: -1,
	id: -1
};
let deskgood_choice_folder = deskgood_folder.addFolder("选择物体");
	deskgood_choice_folder.add(mouse_choice, "view").name("选择模式").listen();
	deskgood_choice_folder.add(mouse_choice, "x", -1000, 1000, 100).listen();
	deskgood_choice_folder.add(mouse_choice, "y", -1000, 1000, 100).listen();
	deskgood_choice_folder.add(mouse_choice, "z", -1000, 1000, 100).listen();
	deskgood_choice_folder.add(mouse_choice, "faceIndex", 0, 12, 1).listen();
	deskgood_choice_folder.add(mouse_choice, "id", 0, 9, 1).listen();

/*document.addEventListener("click", function (e){
	console.log( ray({},deskgood.look)[0] );
});*/
document.addEventListener("mousemove", function (e){
	if (stop)
		return;
	
	if (e.path[0] != document.getElementById("help") & e.path[0] != document.body){
		return;
	}
	
	let dx =
		e.movementX ||
		e.mozMovementX ||
		e.webkitMovementX ||
		0
	;
	let dy =
		e.movementY ||
		e.mozMovementY ||
		e.webkitMovementY ||
		0
	;
	
	deskgood.lookAt.left_right += dx/document.getElementsByTagName("canvas")[0].offsetWidth*360*deskgood.sensitivity;
	deskgood.lookAt.top_bottom -= dy/document.getElementsByTagName("canvas")[0].offsetHeight*360*deskgood.sensitivity;
	
	if (deskgood.lookAt.left_right > 360)
		while (deskgood.lookAt.left_right > 360)
			deskgood.lookAt.left_right -= 360;
	if (deskgood.lookAt.left_right < 0)
		while (deskgood.lookAt.left_right < 0)
			deskgood.lookAt.left_right += 360;
	
	if (deskgood.lookAt.top_bottom > 89.9)
		deskgood.lookAt.top_bottom = 89.9;
	if (deskgood.lookAt.top_bottom < -89.9)
		deskgood.lookAt.top_bottom = -89.9;
	
	deskgood.look_refresh(); //刷新
	
	for (let i in mouse_choice.obj){
		mouse_choice.obj[i].material.dispose();
		mouse_choice.obj[i].geometry.dispose(); //清除内存
		scene.remove(mouse_choice.obj[i]); //删除
		// mouse_choice.obj.splice(i,1); //已经删除！
	}
	
	try{
		let get = ray({},deskgood.look)[0];
		mouse_choice.x = get.object.position.x;
		mouse_choice.y = get.object.position.y;
		mouse_choice.z = get.object.position.z;
		mouse_choice.faceIndex = get.faceIndex;
		mouse_choice.id = map.get(
			get.object.position.x/100,
			get.object.position.y/100,
			get.object.position.z/100
		).id;
		
		if (mouse_choice.view){
			let geometry1 = new THREE.BoxGeometry(100, 100, 100);
			let material1 = new THREE.MeshBasicMaterial({
				color: "blue",
				transparent: true,
				opacity: 0.3
			});
			let material2 = new THREE.MeshBasicMaterial({
				color: "red",
				wireframe: true //只显示框架
			});
			let mesh1 = new THREE.Mesh(geometry1, material1);
			let mesh2 = new THREE.Mesh(geometry1, material2);
			mesh1.position.x = mesh2.position.x = get.object.position.x;
			mesh1.position.y = mesh2.position.y = get.object.position.y;
			mesh1.position.z = mesh2.position.z = get.object.position.z;
			scene.add(mesh1);
			scene.add(mesh2);
			mouse_choice.obj.push(mesh1);
			mouse_choice.obj.push(mesh2);
			/* let geometry2 = new THREE.BoxGeometry(map.size.x*100, map.size.y*100, map.size.z*100);
			let mesh3 = new THREE.Mesh(geometry2, new THREE.MeshBasicMaterial({
				color: "blue",
				transparent: true,
				opacity: 0.1
			}));
			mesh3.position.x = Math.round(get.object.position.x/100/map.size.x)*100;
			mesh3.position.y = map.size.y*100/2;
			mesh3.position.z = Math.round(get.object.position.z/100/map.size.z)*100;
			scene.add(mesh3);
			console.log(mesh3)
			mouse_choice.obj.push(mesh3); */
		}
	}catch(err){
		// console.error(err)
		mouse_choice = {
			view: mouse_choice.view,
			obj: [],
			x: -1,
			y: -1,
			z: -1,
			faceIndex: -1,
			id: -1
		};
	}
});

$(document).on("mousewheel DOMMouseScroll", function(event){ //on也可以 bind监听
	if (stop)
		return;
	//Chorme
	let wheel = event.originalEvent.wheelDelta;
	let detal = event.originalEvent.detail;
	let up = function(){
		deskgood.choice--;
		if (deskgood.choice < 0)
			deskgood.choice = 3;
	};
	let down = function(){
		deskgood.choice++;
		if (deskgood.choice > 3)
			deskgood.choice = 0;
	};
	if (event.originalEvent.wheelDelta){ //判断浏览器IE,谷歌滚轮事件
		if (wheel > 0) { //当滑轮向上滚动时
			console.log("上滚轮");
			up();
			deskgood.tools_choice_refresh();
		}  
		if (wheel < 0) { //当滑轮向下滚动时
			console.log("下滚轮");
			down();
			deskgood.tools_choice_refresh();
		}  
	}else if (event.originalEvent.detail){ //Firefox滚轮事件
		if (detal > 0) { //当滑轮向下滚动时
			console.log("下滚轮");
			down();
			deskgood.tools_choice_refresh();
		}
		if (detal < 0) { //当滑轮向上滚动时
			console.log("上滚轮");
			up();
			deskgood.tools_choice_refresh();
		}
	}  
});

document.addEventListener("mousedown", function (e){
	if (stop)
		return;
	
	if (e.path[0] !== document.body)
		return;
	
	if (e.button == 0){ //左键（删除）
		let click = get_choice_object();
		for (let i in click){
			if (click[i].faceIndex){
				if (click[i].object instanceof THREE.Mesh){
					let x = click[i].object.position.x,
						y = click[i].object.position.y,
						z = click[i].object.position.z;
					if (Math.sqrt(
						Math.pow(x - deskgood.pos.x, 2)+
						Math.pow(y - deskgood.pos.y, 2)+
						Math.pow(z - deskgood.pos.z, 2)
					) < 500){ //距离小于500
						/*let free = -1;
						if (deskgood.tools[deskgood.choice] == 0){
							free = deskgood.choice;
						}else{
							for (let j in deskgood.tools){
								if (deskgood.tools[j] == 0){
									free = j;
									break;
								}
							}
						}*/
						let free = deskgood.tools[deskgood.choice]==0? deskgood.choice: deskgood.tools.indexOf(0);
						if (free == -1){
							console.info("not free!");
							message("<font style='font-size:14px;'>两只手拿4m³方块已经够多了，反正我是拿不下了</font>", 3);
						}else{
							console.log("delete:", click[i].object.position);
							deskgood.tools[free] = map.get(x/100, y/100, z/100).id; //放在手中
							deskgood.tools_things_refresh(); //刷新方块
							map.delete(x/100, y/100, z/100); //删除方块
							map.updateRound(x/100, y/100, z/100); //刷新方块及周围
							//SQL
							[x, y, z] = [x, y, z].map(v => Math.round(v/100));
							sql.deleteData("file", `type=0 AND x=${x} AND y=${y} AND z=${z}`, undefined, function(){
								sql.insertData("file", ["type", "x", "y", "z", "id", "attr"], [
									0,
									x,
									y,
									z,
									0,
									`""`
								])
							});
							/*scene.remove(click[i].object);
							every[ click[i].object.position.x/100 ][ click[i].object.position.y/100 ][ click[i].object.position.z/100 ] = 0;*/
							/* if (
								every[ click[i].object.position.x/100+1 ][ click[i].object.position.y/100 ][ click[i].object.position.z/100 ] 
							) */
						}
						break;
					}
				}
			}
		}
	}else if (e.button == 2){ //右键（放置）
		let click = get_choice_object();
		for (let i in click){
			if (click[i].object instanceof THREE.Mesh){
				let x = click[i].object.position.x,
					y = click[i].object.position.y,
					z = click[i].object.position.z;
				if (
					Math.sqrt(
						Math.pow(x - deskgood.pos.x, 2)+
						Math.pow(y - deskgood.pos.y, 2)+
						Math.pow(z - deskgood.pos.z, 2)
				) < 500){ //距离<500
					if (map.get(x/100, y/100, z/100) &&
						map.get(x/100, y/100, z/100).id == 1
					){ //命令方块
						state("command");
						return;
					}
				}
				if (deskgood.tools[deskgood.choice] == 0) //空气
					return;
				switch (click[i].faceIndex){
					case 0:
					case 1:
						x += 100;
						break;
					case 2:
					case 3:
						x -= 100;
						break;
					case 4:
					case 5:
						y += 100;
						break;
					case 6:
					case 7:
						y -= 100;
						break;
					case 8:
					case 9:
						z += 100;
						break;
					case 10:
					case 11:
						z -= 100;
						break;
					default:
						return console.error("faceIndex wrong:", click[i].faceIndex);
				}
				if (Math.sqrt(
					Math.pow(x-deskgood.pos.x, 2)+
					Math.pow(y-deskgood.pos.y, 2)+
					Math.pow(z-deskgood.pos.z, 2)
				) < 500){ //距离<5m
					map.addID(deskgood.tools[deskgood.choice], {
						x: x/100,
						y: y/100,
						z: z/100
					}, template);
					/* map.add(new Thing(template[ deskgood.tools[deskgood.choice] ]).block.makeMaterial().block.deleteTexture().block.makeMesh(), {
						x: x/100,
						y: y/100,
						z: z/100
					}); */
					map.updateRound(x/100, y/100, z/100); //刷新方块及周围
					//SQL
					let thing_id = deskgood.tools[deskgood.choice];
					[x, y, z] = [x, y, z].map(v => Math.round(v/100));
					sql.deleteData("file", `type=0 AND x=${x} AND y=${y} AND z=${z}`, undefined, function(){
						sql.insertData("file", ["type", "x", "y", "z", "id", "attr"], [
							0,
							x,
							y,
							z,
							thing_id,
							`""`
						])
					});
					deskgood.tools[deskgood.choice] = 0; //删除手里的方块
					deskgood.tools_things_refresh(); //刷新方块
					break; //跳出 寻找有效放置的 循环
				}
				/*if (click[i].faceIndex == 0 | click[i].faceIndex == 1){
					x += 100;
					if (Math.sqrt(
						Math.pow((click[i].object.position.x+100) - deskgood.pos.x, 2)+
						Math.pow(click[i].object.position.y - deskgood.pos.y, 2)+
						Math.pow(click[i].object.position.z - deskgood.pos.z, 2)
					) < 500){ //距离<500
						let thing = new Thing(template[ deskgood.tools[deskgood.choice] ]);
						thing.block.makeMesh();
						let mesh = new THREE.Mesh(block_geometry, template[ deskgood.tools[deskgood.choice] ].material);
						mesh.position.x = click[i].object.position.x+100;
						mesh.position.y = click[i].object.position.y;
						mesh.position.z = click[i].object.position.z;
						
						mesh.castShadow = true;
						mesh.receiveShadow = true;
						
						scene.add(mesh); //网格模型添加到场景中
						every[ click[i].object.position.x/100+1 ][ click[i].object.position.y/100 ][ click[i].object.position.z/100 ] = deskgood.tools[deskgood.choice];
						deskgood.tools[deskgood.choice] = 0; //删除手里的方块
						deskgood.tools_things_refresh(); //刷新方块
						break;
					}
				}else if (click[i].faceIndex == 2 | click[i].faceIndex == 3){
					x -= 100;
					if (Math.sqrt(
						Math.pow((click[i].object.position.x-100) - deskgood.pos.x, 2)+
						Math.pow(click[i].object.position.y - deskgood.pos.y, 2)+
						Math.pow(click[i].object.position.z - deskgood.pos.z, 2)
					) < 500){ //距离<500
						let mesh = new THREE.Mesh(block_geometry, template[ deskgood.tools[deskgood.choice]].material);
						mesh.position.x = click[i].object.position.x-100;
						mesh.position.y = click[i].object.position.y;
						mesh.position.z = click[i].object.position.z;
						
						mesh.castShadow = true;
						mesh.receiveShadow = true;
						
						scene.add(mesh); //网格模型添加到场景中
						every[ click[i].object.position.x/100-1 ][ click[i].object.position.y/100 ][ click[i].object.position.z/100 ] = deskgood.tools[deskgood.choice];
						deskgood.tools[deskgood.choice] = 0; //删除手里的方块
						deskgood.tools_things_refresh(); //刷新方块
						break;
					}
				}else if (click[i].faceIndex == 4 | click[i].faceIndex == 5){
					if (Math.sqrt(
						Math.pow(click[i].object.position.x - deskgood.pos.x, 2)+
					 	Math.pow((click[i].object.position.y+100) - deskgood.pos.y, 2)+
						Math.pow(click[i].object.position.z - deskgood.pos.z, 2)
					) < 500){ //距离<500
						let mesh = new THREE.Mesh(block_geometry, template[ deskgood.tools[deskgood.choice]].material);
						mesh.position.x = click[i].object.position.x;
						mesh.position.y = click[i].object.position.y+100;
						mesh.position.z = click[i].object.position.z;
						
						mesh.castShadow = true;
						mesh.receiveShadow = true;
						
						scene.add(mesh); //网格模型添加到场景中
						every[ click[i].object.position.x/100 ][ click[i].object.position.y/100+1 ][ click[i].object.position.z/100 ] = deskgood.tools[deskgood.choice];
						deskgood.tools[deskgood.choice] = 0; //删除手里的方块
						deskgood.tools_things_refresh(); //刷新方块
						break;
					}
				}else if (click[i].faceIndex == 6 | click[i].faceIndex == 7){
					if (Math.sqrt(
						Math.pow(click[i].object.position.x - deskgood.pos.x, 2)+
						Math.pow((click[i].object.position.y-100) - deskgood.pos.y, 2)+
						Math.pow(click[i].object.position.z - deskgood.pos.z, 2)
					) < 500){ //距离<500
						let mesh = new THREE.Mesh(block_geometry, template[ deskgood.tools[deskgood.choice]].material);
						mesh.position.x = click[i].object.position.x;
						mesh.position.y = click[i].object.position.y-100;
						mesh.position.z = click[i].object.position.z;
						
						mesh.castShadow = true;
						mesh.receiveShadow = true;
						
						scene.add(mesh); //网格模型添加到场景中
						every[ click[i].object.position.x/100 ][ click[i].object.position.y/100-1 ][ click[i].object.position.z/100 ] = deskgood.tools[deskgood.choice];
						deskgood.tools[deskgood.choice] = 0; //删除手里的方块
						deskgood.tools_things_refresh(); //刷新方块
						break;
					}
				}else if (click[i].faceIndex == 8 | click[i].faceIndex == 9){
					if (Math.sqrt(
						Math.pow(click[i].object.position.x - deskgood.pos.x, 2)+
						Math.pow(click[i].object.position.y - deskgood.pos.y, 2)+
						Math.pow((click[i].object.position.z+100) - deskgood.pos.z, 2)
					) < 500){ //距离<500
						let mesh = new THREE.Mesh(block_geometry, template[ deskgood.tools[deskgood.choice]].material);
						mesh.position.x = click[i].object.position.x;
						mesh.position.y = click[i].object.position.y;
						mesh.position.z = click[i].object.position.z+100;
						
						mesh.castShadow = true;
						mesh.receiveShadow = true;
						
						scene.add(mesh); //网格模型添加到场景中
						every[ click[i].object.position.x/100 ][ click[i].object.position.y/100 ][ click[i].object.position.z/100+1 ] = deskgood.tools[deskgood.choice];
						deskgood.tools[deskgood.choice] = 0; //删除手里的方块
						deskgood.tools_things_refresh(); //刷新方块
						break;
					}
				}else if (click[i].faceIndex == 10 | click[i].faceIndex == 11){
					if (Math.sqrt(
						Math.pow(click[i].object.position.x - deskgood.pos.x, 2)+
						Math.pow(click[i].object.position.y - deskgood.pos.y, 2)+
						Math.pow((click[i].object.position.z-100) - deskgood.pos.z, 2)
					) < 500){ //距离<500
						let mesh = new THREE.Mesh(block_geometry, template[ deskgood.tools[deskgood.choice]].material);
						mesh.position.x = click[i].object.position.x;
						mesh.position.y = click[i].object.position.y;
						mesh.position.z = click[i].object.position.z-100;
						
						mesh.castShadow = true;
						mesh.receiveShadow = true;
						
						scene.add(mesh); //网格模型添加到场景中
						every[ click[i].object.position.x/100 ][ click[i].object.position.y/100 ][ click[i].object.position.z/100-1 ] = deskgood.tools[deskgood.choice];
						deskgood.tools[deskgood.choice] = 0; //删除手里的方块
						deskgood.tools_things_refresh(); //刷新方块
						break;
					}
				}*/
			}
		}
	}
	return false;
});


/**
* Touch
*/
let touch_control = {
	x0: null,
	y0: null,
	x: null,
	y: null,
	t0: null,
	loop: null
};
$("#control").on("touchstart", function(e){
	if (stop)
		return;
	
	let x = e.originalEvent.targetTouches[0].clientX,
		y = e.originalEvent.targetTouches[0].clientY;
	console.log("touchstart(control):", x, y);
	
	[touch_control.x0, touch_control.y0, touch_control.t0] = [x, y, +new Date()];
	
	touch_control.loop = setInterval(function(){
		if (touch_control.x0 !== null &
			touch_control.y0 !== null &
			touch_control.x !== null &
			touch_control.y !== null
		){
			let t = +new Date()-touch_control.t0;
			touch_control.t0 = +new Date();
			let dx = touch_control.x-touch_control.x0,
				dy = touch_control.y-touch_control.y0;
			let r = (
				dx>0? Math.atan(dy/dx)+Math.PI/2:
				dx<0? Math.atan(dy/dx)-Math.PI/2:
					dy>0? 0:
					dy<0? 180:
					0
			);
			let l = Math.sqrt(
				Math.pow(dx, 2)+
				Math.pow(dy, 2)
			);
			l = l>100? 0.26*t: l*t/866;
			let x = Math.cos( deskgood.lookAt.left_right/180*Math.PI+r )*l;
			let z = Math.sin( deskgood.lookAt.left_right/180*Math.PI+r )*l;
			
			console.log("touch control to move:", x, z);
			
			deskgood.go(x, 0, z);
			
			/*x += x>0? 10: x<0? -10: 0;
			z += z>0? 10: z<0? -10: 0;
			
			if (x > 0){
				for (var i=deskgood.pos.x; i<=deskgood.pos.x+x; i+=2){
					try{
						if (
							every
								[Math.round(i/100)]
								[Math.round(deskgood.pos.y/100)]
								[Math.round(deskgood.pos.z/100)]
							!=
								0
						) break;
						if (
							every
								[Math.round(i/100)]
								[Math.round(deskgood.pos.y/100)-1]
								[Math.round(deskgood.pos.z/100)]
							!=
								0
						) break;
					}catch(err){}
				}
			}else{
				for (var i=deskgood.pos.x; i>=deskgood.pos.x+x; i-=2){
					try{
						if (
							every
								[Math.round(i/100)]
								[Math.round(deskgood.pos.y/100)]
								[Math.round(deskgood.pos.z/100)]
							!=
								0
						) break;
						if (
							every
								[Math.round(i/100)]
								[Math.round(deskgood.pos.y/100)-1]
								[Math.round(deskgood.pos.z/100)]
							!=
								0
						) break;
					}catch(err){}
				}
			}
			if (z > 0){
				for (var j=deskgood.pos.z; j<=deskgood.pos.z+z; j+=2){
					try{
						if (
							every
								[Math.round(deskgood.pos.x/100)]
								[Math.round(deskgood.pos.y/100)]
								[Math.round(j/100)]
							!=
								0
						) break;
						if (
							every
								[Math.round(deskgood.pos.x/100)]
								[Math.round(deskgood.pos.y/100)-1]
								[Math.round(j/100)]
							!=
								0
						) break;
					}catch(err){}
				}
			}else{
				for (var j=deskgood.pos.z; j>=deskgood.pos.z+z; j-=2){
					try{
						if (
							every
								[Math.round(deskgood.pos.x/100)]
								[Math.round(deskgood.pos.y/100)]
								[Math.round(j/100)]
							!=
								0
						) break;
						if (
							every
								[Math.round(deskgood.pos.x/100)]
								[Math.round(deskgood.pos.y/100)-1]
								[Math.round(j/100)]
							!=
								0
						) break;
					}catch(err){}
				}
			}
			
			i -= deskgood.pos.x;
			j -= deskgood.pos.z;
			
			i -= i>0? 10: i<0? -10: 0;
			j -= j>0? 10: j<0? -10: 0;
			
			deskgood.pos.x += i*(Math.random()*0.2+0.9);
			deskgood.pos.z += j*(Math.random()*0.2+0.9);*/
		}
	}, 16.667);
	
	return false;
});
$("#control").on("touchmove", function(e){
	if (stop)
		return;
	
	let x = e.originalEvent.targetTouches[0].clientX;
	let y = e.originalEvent.targetTouches[0].clientY;
	console.log("touchmove(control):", x, y);
	
	[touch_control.x, touch_control.y] = [x, y];
	
	return false;
});
$("#control").on("touchend", function(e){
	let x = e.originalEvent.changedTouches[0].clientX,
		y = e.originalEvent.changedTouches[0].clientY;
	console.log("touchend(control):", x, y);
	
	clearInterval(touch_control.loop);
	touch_control.x0 = touch_control.y0 = touch_control.x = touch_control.y = touch_control.t0 = touch_control.loop = null;
	
	return false;
});
$("#control").on("touchcancel", function(e){
	let x = e.originalEvent.changedTouches[0].clientX,
		y = e.originalEvent.changedTouches[0].clientY;
	console.log("touchcancel(control):", x, y);
	
	clearInterval(touch_control.loop);
	touch_control.x0 = touch_control.y0 = touch_control.x = touch_control.y = touch_control.t0 = touch_control.loop = null;
	
	return false;
});


$("#jump").on("touchstart", function(){
	if (stop)
		return;
	
	console.log("try jump");
	
	try{
		if (
			map.get(deskgood.pos.x/100,
				deskgood.pos.y/100-2,
				deskgood.pos.z/100)
			!=
				null
		){ //脚下有方块
			if (Number(new Date())-last_jump >= 1000){
				deskgood.v.y += deskgood.jump_v*(Math.random()*0.2+0.9);
				last_jump = Number(new Date());
			}
		}
	}catch(err){}
	
	return false;
});


let touch_screen = {
	t: null,
	pos: {x: null, y: null},
	loop: null
};
$("canvas:eq(0)").on("touchstart", function (e){
	if (stop)
		return;
	
	let x = e.originalEvent.targetTouches[0].pageX;
	let y = e.originalEvent.targetTouches[0].pageY
	console.log("touchstart(screen):", x, y, Number(new Date()));
	
	[x0,y0] = [x, y];
	
	touch_screen.t = new Date();
	touch_screen.pos = {x,y};
	touch_screen.loop = setTimeout(()=>{ //长按（删除）
		touch_screen.loop = null;
		if (Math.sqrt(
			Math.pow(touch_screen.pos.x-x, 2)+
			Math.pow(touch_screen.pos.y-y, 2)
		) < 36){ //误差36px
			let click = get_choice_object(true, x, y);
			for (let i in click){
				if (click[i].faceIndex){
					if (click[i].object instanceof THREE.Mesh){
						let x = click[i].object.position.x,
							y = click[i].object.position.y,
							z = click[i].object.position.z;
						if (Math.sqrt(
							Math.pow(x - deskgood.pos.x, 2)+
							Math.pow(y - deskgood.pos.y, 2)+
							Math.pow(z - deskgood.pos.z, 2)
						) < 500){ //距离小于500
							/*let free = -1;
							if (deskgood.tools[deskgood.choice] == 0){
								free = deskgood.choice;
							}else{
								for (let j in deskgood.tools){
									if (deskgood.tools[j] == 0){
										free = j;
										break;
									}
								}
							}*/
							let free = deskgood.tools[deskgood.choice]==0? deskgood.choice: deskgood.tools.indexOf(0);
							if (free == -1){
								console.info("not free!");
								message("<font style='font-size:14px;'>两只手拿4m³方块已经够多了，反正我是拿不下了</font>", 3);
								/* try{
									plus.nativeUI.toast("<font style=\"font-size:14px\">两只手拿4m³方块已经够多了，反正我是拿不下了</font>",
										{
											type:"richtext",
											verticalAlign: "top",
											richTextStyle:{
												align:"center"
											}
										}
									);
								}catch(err){} */
							}else{
								console.log("delete:", click[i].object.position);
								deskgood.tools[free] = map.get(x/100, y/100, z/100).id; //放在手中
								deskgood.tools_things_refresh(); //刷新方块
								map.delete(x/100, y/100, z/100); //删除方块
								map.updateRound(x/100, y/100, z/100); //更新方块
								//SQL
								[x, y, z] = [x, y, z].map(v => Math.round(v/100));
								sql.deleteData("file", `type=0 AND x=${x} AND y=${y} AND z=${z}`, undefined, function(){
									sql.insertData("file", ["type", "x", "y", "z", "id", "attr"], [
										0,
										x,
										y,
										z,
										0,
										`""`
									])
								});
								//scene.remove(click[i].object);
								//every[ click[i].object.position.x/100 ][ click[i].object.position.y/100 ][ click[i].object.position.z/100 ] = 0;
								try{
									plus.device.vibrate(16); //挖掘震动
								}catch(e){ //原生震动
									if("vibrate" in navigator){
										navigator.vibrate(16);
									}
								}
								/* if (
									every[ click[i].object.position.x/100+1 ][ click[i].object.position.y/100 ][ click[i].object.position.z/100 ] 
								) */
							}
							break;
						}
					}
				}
			}
		}
	}, 1000);
	
	return false;
});
$("canvas:eq(0)").on("touchmove", function (e){
	if (stop)
		return false;
	
	if (x0 === null | y0 === null)
		return false;
	
	let x = e.originalEvent.targetTouches[0].pageX;
	let y = e.originalEvent.targetTouches[0].pageY;
	console.log("touchmove:", x, y);
	
	let [dx, dy] = [x-x0, y-y0];
	[x0, y0] = [x, y];
	console.log("move:", dx, dy);
	deskgood.lookAt.left_right += dx/document.getElementsByTagName("canvas")[0].offsetWidth*90*deskgood.sensitivity;
	deskgood.lookAt.top_bottom -= dy/document.getElementsByTagName("canvas")[0].offsetHeight*90*deskgood.sensitivity;
	
	if (deskgood.lookAt.left_right > 360)
		while (deskgood.lookAt.left_right > 360)
			deskgood.lookAt.left_right -= 360;
	if (deskgood.lookAt.left_right < 0)
		while (deskgood.lookAt.left_right < 0)
			deskgood.lookAt.left_right += 360;
	
	if (deskgood.lookAt.top_bottom > 89.9)
		deskgood.lookAt.top_bottom = 89.9;
	if (deskgood.lookAt.top_bottom < -89.9)
		deskgood.lookAt.top_bottom = -89.9;
	
	deskgood.look_refresh(); //刷新
	
	if (Math.sqrt(
		Math.pow(touch_screen.pos.x-x, 2)+
		Math.pow(touch_screen.pos.y-y, 2)
	) >= 100){ //误差100px
		touch_screen.pos.x = -666;
		touch_screen.pos.y = -666;
	}
	return false;
});
$("canvas:eq(0)").on("touchend", function (e){
	if (stop)
		return;
	
	let x = e.originalEvent.changedTouches[0].pageX;
	let y = e.originalEvent.changedTouches[0].pageY;
	//console.log("touchend:", x, y, Number(new Date()));
	
	x0 = null, y0 = null;
	
	if (touch_screen.loop !== null){ //短按（放置）
		clearTimeout(touch_screen.loop);
		touch_screen.loop = null;
		if (Math.sqrt(
			Math.pow(touch_screen.pos.x-x, 2)+
			Math.pow(touch_screen.pos.y-y, 2)
		) < 36){ //误差36px
			let click = get_choice_object(true, x, y);
			for (let i in click){
				if (click[i].object instanceof THREE.Mesh){
					if (
						Math.sqrt(
							Math.pow(click[i].object.position.x - deskgood.pos.x, 2)+
							Math.pow(click[i].object.position.y - deskgood.pos.y, 2)+
							Math.pow(click[i].object.position.z - deskgood.pos.z, 2)
					) < 500){ //距离<500
						if (
							map.get(click[i].object.position.x/100,
								click[i].object.position.y/100,
								click[i].object.position.z/100)
							&&
							map.get(click[i].object.position.x/100,
								click[i].object.position.y/100,
								click[i].object.position.z/100).id
							==
								1
						){ //命令方块
							state("command");
							return;
						}
					}
					if (deskgood.tools[deskgood.choice] == 0) //空气
						return;
					let x = click[i].object.position.x,
						y = click[i].object.position.y,
						z = click[i].object.position.z;
					switch (click[i].faceIndex){
						case 0:
						case 1:
							x += 100;
							break;
						case 2:
						case 3:
							x -= 100;
							break;
						case 4:
						case 5:
							y += 100;
							break;
						case 6:
						case 7:
							y -= 100;
							break;
						case 8:
						case 9:
							z += 100;
							break;
						case 10:
						case 11:
							z -= 100;
							break;
						default:
							return console.error("faceIndex wrong:", click[i].faceIndex);
					}
					if (Math.sqrt(
						Math.pow(x-deskgood.pos.x, 2)+
						Math.pow(y-deskgood.pos.y, 2)+
						Math.pow(z-deskgood.pos.z, 2)
					) < 500){ //距离<5m
						map.addID(deskgood.tools[deskgood.choice], {
							x: x/100,
							y: y/100,
							z: z/100
						}, template);
						/* map.add(new Thing(template[ deskgood.tools[deskgood.choice] ]).block.makeMaterial().block.deleteTexture().block.makeMesh(), {
							x: x/100,
							y: y/100,
							z: z/100
						}); */
						map.updateRound(x/100, y/100, z/100); //更新方块及周围方块
						let thing_id = deskgood.tools[deskgood.choice];
						//SQL
						[x, y, z] = [x, y, z].map(v => Math.round(v/100));
						sql.deleteData("file", `type=0 AND x=${x} AND y=${y} AND z=${z}`, undefined, function(){
							sql.insertData("file", ["type", "x", "y", "z", "id", "attr"], [
								0,
								x,
								y,
								z,
								thing_id,
								`""`
							])
						});
						deskgood.tools[deskgood.choice] = 0; //删除手里的方块
						deskgood.tools_things_refresh(); //刷新方块
						break; //跳出 寻找有效放置的 循环
					}
					/*if (click[i].faceIndex == 0 | click[i].faceIndex == 1){
						if (Math.sqrt(
							Math.pow((click[i].object.position.x+100) - deskgood.pos.x, 2)+
							Math.pow(click[i].object.position.y - deskgood.pos.y, 2)+
							Math.pow(click[i].object.position.z - deskgood.pos.z, 2)
						) < 500){ //距离<50
							let mesh = new THREE.Mesh(block_geometry, template[ deskgood.tools[deskgood.choice]].material);
							mesh.position.x = click[i].object.position.x+100;
							mesh.position.y = click[i].object.position.y;
							mesh.position.z = click[i].object.position.z;
							
							mesh.castShadow = true;
							mesh.receiveShadow = true;
							
							scene.add(mesh); //网格模型添加到场景中
							every[ click[i].object.position.x/100+1 ][ click[i].object.position.y/100 ][ click[i].object.position.z/100 ] = deskgood.tools[deskgood.choice];
							deskgood.tools[deskgood.choice] = 0; //删除手里的方块
							deskgood.tools_things_refresh(); //刷新方块
							break;
						}
					}else if (click[i].faceIndex == 2 | click[i].faceIndex == 3){
						if (Math.sqrt(
							Math.pow((click[i].object.position.x-100) - deskgood.pos.x, 2)+
							Math.pow(click[i].object.position.y - deskgood.pos.y, 2)+
							Math.pow(click[i].object.position.z - deskgood.pos.z, 2)
						) < 500){ //距离<500
							let mesh = new THREE.Mesh(block_geometry, template[ deskgood.tools[deskgood.choice]].material);
							mesh.position.x = click[i].object.position.x-100;
							mesh.position.y = click[i].object.position.y;
							mesh.position.z = click[i].object.position.z;
							
							mesh.castShadow = true;
							mesh.receiveShadow = true;
							
							scene.add(mesh); //网格模型添加到场景中
							every[ click[i].object.position.x/100-1 ][ click[i].object.position.y/100 ][ click[i].object.position.z/100 ] = deskgood.tools[deskgood.choice];
							deskgood.tools[deskgood.choice] = 0; //删除手里的方块
							deskgood.tools_things_refresh(); //刷新方块
							break;
						}
					}else if (click[i].faceIndex == 4 | click[i].faceIndex == 5){
						if (Math.sqrt(
								Math.pow(click[i].object.position.x - deskgood.pos.x, 2)+
						 	Math.pow((click[i].object.position.y+100) - deskgood.pos.y, 2)+
							Math.pow(click[i].object.position.z - deskgood.pos.z, 2)
						) < 500){ //距离<500
							let mesh = new THREE.Mesh(block_geometry, template[ deskgood.tools[deskgood.choice]].material);
							mesh.position.x = click[i].object.position.x;
							mesh.position.y = click[i].object.position.y+100;
							mesh.position.z = click[i].object.position.z;
							
							mesh.castShadow = true;
							mesh.receiveShadow = true;
							
							scene.add(mesh); //网格模型添加到场景中
							every[ click[i].object.position.x/100 ][ click[i].object.position.y/100+1 ][ click[i].object.position.z/100 ] = deskgood.tools[deskgood.choice];
							deskgood.tools[deskgood.choice] = 0; //删除手里的方块
							deskgood.tools_things_refresh(); //刷新方块
							break;
						}
					}else if (click[i].faceIndex == 6 | click[i].faceIndex == 7){
							if (Math.sqrt(
							Math.pow(click[i].object.position.x - deskgood.pos.x, 2)+
							Math.pow((click[i].object.position.y-100) - deskgood.pos.y, 2)+
							Math.pow(click[i].object.position.z - deskgood.pos.z, 2)
						) < 500){ //距离<500
							let mesh = new THREE.Mesh(block_geometry, template[ deskgood.tools[deskgood.choice]].material);
							mesh.position.x = click[i].object.position.x;
							mesh.position.y = click[i].object.position.y-100;
							mesh.position.z = click[i].object.position.z;
							
							mesh.castShadow = true;
							mesh.receiveShadow = true;
							
							scene.add(mesh); //网格模型添加到场景中
							every[ click[i].object.position.x/100 ][ click[i].object.position.y/100-1 ][ click[i].object.position.z/100 ] = deskgood.tools[deskgood.choice];
							deskgood.tools[deskgood.choice] = 0; //删除手里的方块
							deskgood.tools_things_refresh(); //刷新方块
							break;
						}
					}else if (click[i].faceIndex == 8 | click[i].faceIndex == 9){
						if (Math.sqrt(
							Math.pow(click[i].object.position.x - deskgood.pos.x, 2)+
							Math.pow(click[i].object.position.y - deskgood.pos.y, 2)+
							Math.pow((click[i].object.position.z+100) - deskgood.pos.z, 2)
						) < 500){ //距离<500
							let mesh = new THREE.Mesh(block_geometry, template[ deskgood.tools[deskgood.choice]].material);
							mesh.position.x = click[i].object.position.x;
							mesh.position.y = click[i].object.position.y;
							mesh.position.z = click[i].object.position.z+100;
							
							mesh.castShadow = true;
							mesh.receiveShadow = true;
							
							scene.add(mesh); //网格模型添加到场景中
							every[ click[i].object.position.x/100 ][ click[i].object.position.y/100 ][ click[i].object.position.z/100+1 ] = deskgood.tools[deskgood.choice];
							deskgood.tools[deskgood.choice] = 0; //删除手里的方块
							deskgood.tools_things_refresh(); //刷新方块
							break;
						}
					}else if (click[i].faceIndex == 10 | click[i].faceIndex == 11){
						if (Math.sqrt(
							Math.pow(click[i].object.position.x - deskgood.pos.x, 2)+
							Math.pow(click[i].object.position.y - deskgood.pos.y, 2)+
							Math.pow((click[i].object.position.z-100) - deskgood.pos.z, 2)
						) < 500){ //距离<500
							let mesh = new THREE.Mesh(block_geometry, template[ deskgood.tools[deskgood.choice]].material);
							mesh.position.x = click[i].object.position.x;
							mesh.position.y = click[i].object.position.y;
							mesh.position.z = click[i].object.position.z-100;
							
							mesh.castShadow = true;
							mesh.receiveShadow = true;
							
							scene.add(mesh); //网格模型添加到场景中
							every[ click[i].object.position.x/100 ][ click[i].object.position.y/100 ][ click[i].object.position.z/100-1 ] = deskgood.tools[deskgood.choice];
							deskgood.tools[deskgood.choice] = 0; //删除手里的方块
							deskgood.tools_things_refresh(); //刷新方块
							break;
						}
					}*/
				}
			}
		}
	}
});
$("canvas:eq(0)").on("touchcancel", function (e){
	if (stop)
		return;
	
	let x = e.originalEvent.changedTouches[0].pageX;
	let y = e.originalEvent.changedTouches[0].pageY;
	console.log("touchcancel:", x, y, Number(new Date()));
	
	x0 = null, y0 = null;
	
	if (touch_screen.loop !== null){ //短按（放置）
		clearTimeout(touch_screen.loop);
	}
});


function get_choice_object(phone, x, y){
	let raycaster = new THREE.Raycaster(); //光线投射，用于确定鼠标点击位置
	let mouse = new THREE.Vector2(); //创建二维平面
	mouse.x = phone? 2*(x/WIDTH)-1: 0;
	mouse.y = phone? -2*(y/HEIGHT)+1: 0;
	//mouse.x = phone? (x/window.innerWidth)*0.9-0.6: 0;
	//mouse.y = phone? (y/window.innerHeight)*1.8-0.6: 0;
	console.log("get:", x, y, mouse.x, mouse.y);
	//以camera为z坐标，确定所点击物体的3D空间位置
	raycaster.setFromCamera(mouse, camera);
	//确定所点击位置上的物体数量
	let intersects = raycaster.intersectObjects(scene.children);
	//选中后进行的操作
	if(intersects.length){
		return intersects;
	}
	return null;
}

//屏蔽鼠标右键
document.oncontextmenu = function (e){
	var e = e || window.event;
	e.returnValue = false;
	return false;
};
//屏蔽选择文字
/*document.onselectstart = function (){
	return false;
};*/


setInterval(function(){
	if (deskgood.v.y == Infinity && deskgood.pos.y == Infinity){
		document.body.innerHTML = "";
		document.write(`
<body style="background-color: black; color: white; margin:0; padding:0;">
<h1 style="font-size:16vmin; width:100%; margin:0; text-align:center; position:absolute; top:50%; transform:translateY(-50%);">欢迎来到天堂！<br/>welcome to Infinity.</h1>
		`);
	}else if (deskgood.pos.y < -1800*100){
		document.body.innerHTML = "";
		document.write(`
<body style="background-color: black; color: white; margin:0; padding:0;">
<h1 style="font-size:16vmin; width:100%; margin:0; text-align:center; position:absolute; top:50%; transform:translateY(-50%);">欢迎来到地狱！<br/>welcome to L-18.</h1>
		`);
	}
},1000);

function GetQueryString(name){
	var reg = new RegExp("(^|&)"+ name +"=([^&]*)(&|$)");
	var r = window.location.search.substr(1).match(reg);
	if(r!=null)return  unescape(r[2]); return null;
}

function message(text, time=5){
	/*if (navigator.userAgent.toLowerCase().indexOf("html5plus") != -1){
		if (typeof plus != "undefined"){
			plus.nativeUI.toast(
				text,
				{
					type: "richtext",
					duration: time1,
					verticalAlign: "top",
					richTextStyle: {
						align:"center",
					}
				}
			);
		}else{
			document.addEventListener("plusready", function(){
				plus.nativeUI.toast(
					text,
					{
						type: "richtext",
						duration: time1,
						verticalAlign: "top",
						richTextStyle: {
							align:"center",
						}
					}
				);
			});
		}
	}else{*/
		let msg = $(`<dialog>${text}</dialog>`);
		$(document.body).append(
			msg.attr("open", "true").hide()
		);
		msg.fadeIn("slow");
		setTimeout(()=>{
			msg.fadeOut("slow");
		}, time*1000);
	//}
}
</script>
	</body>
</html>
